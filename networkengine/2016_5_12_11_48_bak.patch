Index: CMakeLists.txt
===================================================================
--- CMakeLists.txt	(revision 49)
+++ CMakeLists.txt	(working copy)
@@ -24,6 +24,8 @@
     set( CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG ${PROJECT_SOURCE_DIR}/output/win32d )
 	set( CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE ${PROJECT_SOURCE_DIR}/output/win32 )
 	include_directories(${PROJECT_SOURCE_DIR}/dep/libevent/inc/win32)
+	set( CMAKE_CXX_FLAGS_RELEASE "/MT")
+	SET( CMAKE_CXX_FLAGS_DEBUG "/MTd /ZI /Od")
 else()
     set( CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG ${PROJECT_SOURCE_DIR}/output/linux32d )
 	set( CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE ${PROJECT_SOURCE_DIR}/output/linux32 )
@@ -42,7 +44,9 @@
 		debug ${PROJECT_SOURCE_DIR}/../rapidlib/output/win32d/rapidlib.lib
 		ws2_32.lib
 		)
-	set(LIBEVENT_LIB ${PROJECT_SOURCE_DIR}/../../rapid_dep/libevent/lib/win32/libevent.lib)
+	set(LIBEVENT_LIB
+		optimized ${PROJECT_SOURCE_DIR}/../../rapid_dep/libevent/lib/win32/event.lib
+		debug ${PROJECT_SOURCE_DIR}/../../rapid_dep/libevent/lib/win32d/event.lib)
 else()
 	SET(LINK_LIBRARY
 		optimized ${PROJECT_SOURCE_DIR}/../rapidlib/output/linux32/rapidlib.a 
Index: dep/libevent/inc/event2/buffer.h
===================================================================
--- dep/libevent/inc/event2/buffer.h	(revision 49)
+++ dep/libevent/inc/event2/buffer.h	(working copy)
@@ -1,842 +1,1076 @@
-/*
- * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _EVENT2_BUFFER_H_
-#define _EVENT2_BUFFER_H_
-
-/** @file event2/buffer.h
-
-  Functions for buffering data for network sending or receiving.
-
-  An evbuffer can be used for preparing data before sending it to
-  the network or conversely for reading data from the network.
-  Evbuffers try to avoid memory copies as much as possible.  As a
-  result, evbuffers can be used to pass data around without actually
-  incurring the overhead of copying the data.
-
-  A new evbuffer can be allocated with evbuffer_new(), and can be
-  freed with evbuffer_free().  Most users will be using evbuffers via
-  the bufferevent interface.  To access a bufferevent's evbuffers, use
-  bufferevent_get_input() and bufferevent_get_output().
-
-  There are several guidelines for using evbuffers.
-
-  - if you already know how much data you are going to add as a result
-    of calling evbuffer_add() multiple times, it makes sense to use
-    evbuffer_expand() first to make sure that enough memory is allocated
-    before hand.
-
-  - evbuffer_add_buffer() adds the contents of one buffer to the other
-    without incurring any unnecessary memory copies.
-
-  - evbuffer_add() and evbuffer_add_buffer() do not mix very well:
-    if you use them, you will wind up with fragmented memory in your
-	buffer.
-
-  - For high-performance code, you may want to avoid copying data into and out
-    of buffers.  You can skip the copy step by using
-    evbuffer_reserve_space()/evbuffer_commit_space() when writing into a
-    buffer, and evbuffer_peek() when reading.
-
-  In Libevent 2.0 and later, evbuffers are represented using a linked
-  list of memory chunks, with pointers to the first and last chunk in
-  the chain.
-
-  As the contents of an evbuffer can be stored in multiple different
-  memory blocks, it cannot be accessed directly.  Instead, evbuffer_pullup()
-  can be used to force a specified number of bytes to be contiguous. This
-  will cause memory reallocation and memory copies if the data is split
-  across multiple blocks.  It is more efficient, however, to use
-  evbuffer_peek() if you don't require that the memory to be contiguous.
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <event2/event-config.h>
-#include <stdarg.h>
-#ifdef _EVENT_HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-#ifdef _EVENT_HAVE_SYS_UIO_H
-#include <sys/uio.h>
-#endif
-#include <event2/util.h>
-
-/**
-   An evbuffer is an opaque data type for efficiently buffering data to be
-   sent or received on the network.
-
-   @see event2/event.h for more information
-*/
-struct evbuffer
-#ifdef _EVENT_IN_DOXYGEN
-{}
-#endif
-;
-
-/**
-    Pointer to a position within an evbuffer.
-
-    Used when repeatedly searching through a buffer.  Calling any function
-    that modifies or re-packs the buffer contents may invalidate all
-    evbuffer_ptrs for that buffer.  Do not modify these values except with
-    evbuffer_ptr_set.
- */
-struct evbuffer_ptr {
-	ev_ssize_t pos;
-
-	/* Do not alter the values of fields. */
-	struct {
-		void *chain;
-		size_t pos_in_chain;
-	} _internal;
-};
-
-/** Describes a single extent of memory inside an evbuffer.  Used for
-    direct-access functions.
-
-    @see evbuffer_reserve_space, evbuffer_commit_space, evbuffer_peek
- */
-#ifdef _EVENT_HAVE_SYS_UIO_H
-#define evbuffer_iovec iovec
-/* Internal use -- defined only if we are using the native struct iovec */
-#define _EVBUFFER_IOVEC_IS_NATIVE
-#else
-struct evbuffer_iovec {
-	/** The start of the extent of memory. */
-	void *iov_base;
-	/** The length of the extent of memory. */
-	size_t iov_len;
-};
-#endif
-
-/**
-  Allocate storage for a new evbuffer.
-
-  @return a pointer to a newly allocated evbuffer struct, or NULL if an error
-	occurred
- */
-struct evbuffer *evbuffer_new(void);
-/**
-  Deallocate storage for an evbuffer.
-
-  @param buf pointer to the evbuffer to be freed
- */
-void evbuffer_free(struct evbuffer *buf);
-
-/**
-   Enable locking on an evbuffer so that it can safely be used by multiple
-   threads at the same time.
-
-   NOTE: when locking is enabled, the lock will be held when callbacks are
-   invoked.  This could result in deadlock if you aren't careful.  Plan
-   accordingly!
-
-   @param buf An evbuffer to make lockable.
-   @param lock A lock object, or NULL if we should allocate our own.
-   @return 0 on success, -1 on failure.
- */
-int evbuffer_enable_locking(struct evbuffer *buf, void *lock);
-
-/**
-   Acquire the lock on an evbuffer.  Has no effect if locking was not enabled
-   with evbuffer_enable_locking.
-*/
-void evbuffer_lock(struct evbuffer *buf);
-
-/**
-   Release the lock on an evbuffer.  Has no effect if locking was not enabled
-   with evbuffer_enable_locking.
-*/
-void evbuffer_unlock(struct evbuffer *buf);
-
-
-/** If this flag is set, then we will not use evbuffer_peek(),
- * evbuffer_remove(), evbuffer_remove_buffer(), and so on to read bytes
- * from this buffer: we'll only take bytes out of this buffer by
- * writing them to the network (as with evbuffer_write_atmost), by
- * removing them without observing them (as with evbuffer_drain),
- * or by copying them all out at once (as with evbuffer_add_buffer).
- *
- * Using this option allows the implementation to use sendfile-based
- * operations for evbuffer_add_file(); see that function for more
- * information.
- *
- * This flag is on by default for bufferevents that can take advantage
- * of it; you should never actually need to set it on a bufferevent's
- * output buffer.
- */
-#define EVBUFFER_FLAG_DRAINS_TO_FD 1
-
-/** Change the flags that are set for an evbuffer by adding more.
- *
- * @param buffer the evbuffer that the callback is watching.
- * @param cb the callback whose status we want to change.
- * @param flags One or more EVBUFFER_FLAG_* options
- * @return 0 on success, -1 on failure.
- */
-int evbuffer_set_flags(struct evbuffer *buf, ev_uint64_t flags);
-/** Change the flags that are set for an evbuffer by removing some.
- *
- * @param buffer the evbuffer that the callback is watching.
- * @param cb the callback whose status we want to change.
- * @param flags One or more EVBUFFER_FLAG_* options
- * @return 0 on success, -1 on failure.
- */
-int evbuffer_clear_flags(struct evbuffer *buf, ev_uint64_t flags);
-
-/**
-  Returns the total number of bytes stored in the evbuffer
-
-  @param buf pointer to the evbuffer
-  @return the number of bytes stored in the evbuffer
-*/
-size_t evbuffer_get_length(const struct evbuffer *buf);
-
-/**
-   Returns the number of contiguous available bytes in the first buffer chain.
-
-   This is useful when processing data that might be split into multiple
-   chains, or that might all be in the first chain.  Calls to
-   evbuffer_pullup() that cause reallocation and copying of data can thus be
-   avoided.
-
-   @param buf pointer to the evbuffer
-   @return 0 if no data is available, otherwise the number of available bytes
-     in the first buffer chain.
-*/
-size_t evbuffer_get_contiguous_space(const struct evbuffer *buf);
-
-/**
-  Expands the available space in an evbuffer.
-
-  Expands the available space in the evbuffer to at least datlen, so that
-  appending datlen additional bytes will not require any new allocations.
-
-  @param buf the evbuffer to be expanded
-  @param datlen the new minimum length requirement
-  @return 0 if successful, or -1 if an error occurred
-*/
-int evbuffer_expand(struct evbuffer *buf, size_t datlen);
-
-/**
-   Reserves space in the last chain or chains of an evbuffer.
-
-   Makes space available in the last chain or chains of an evbuffer that can
-   be arbitrarily written to by a user.  The space does not become
-   available for reading until it has been committed with
-   evbuffer_commit_space().
-
-   The space is made available as one or more extents, represented by
-   an initial pointer and a length.  You can force the memory to be
-   available as only one extent.  Allowing more extents, however, makes the
-   function more efficient.
-
-   Multiple subsequent calls to this function will make the same space
-   available until evbuffer_commit_space() has been called.
-
-   It is an error to do anything that moves around the buffer's internal
-   memory structures before committing the space.
-
-   NOTE: The code currently does not ever use more than two extents.
-   This may change in future versions.
-
-   @param buf the evbuffer in which to reserve space.
-   @param size how much space to make available, at minimum.  The
-      total length of the extents may be greater than the requested
-      length.
-   @param vec an array of one or more evbuffer_iovec structures to
-      hold pointers to the reserved extents of memory.
-   @param n_vec The length of the vec array.  Must be at least 1;
-       2 is more efficient.
-   @return the number of provided extents, or -1 on error.
-   @see evbuffer_commit_space()
-*/
-int
-evbuffer_reserve_space(struct evbuffer *buf, ev_ssize_t size,
-    struct evbuffer_iovec *vec, int n_vec);
-
-/**
-   Commits previously reserved space.
-
-   Commits some of the space previously reserved with
-   evbuffer_reserve_space().  It then becomes available for reading.
-
-   This function may return an error if the pointer in the extents do
-   not match those returned from evbuffer_reserve_space, or if data
-   has been added to the buffer since the space was reserved.
-
-   If you want to commit less data than you got reserved space for,
-   modify the iov_len pointer of the appropriate extent to a smaller
-   value.  Note that you may have received more space than you
-   requested if it was available!
-
-   @param buf the evbuffer in which to reserve space.
-   @param vec one or two extents returned by evbuffer_reserve_space.
-   @param n_vecs the number of extents.
-   @return 0 on success, -1 on error
-   @see evbuffer_reserve_space()
-*/
-int evbuffer_commit_space(struct evbuffer *buf,
-    struct evbuffer_iovec *vec, int n_vecs);
-
-/**
-  Append data to the end of an evbuffer.
-
-  @param buf the evbuffer to be appended to
-  @param data pointer to the beginning of the data buffer
-  @param datlen the number of bytes to be copied from the data buffer
-  @return 0 on success, -1 on failure.
- */
-int evbuffer_add(struct evbuffer *buf, const void *data, size_t datlen);
-
-
-/**
-  Read data from an evbuffer and drain the bytes read.
-
-  If more bytes are requested than are available in the evbuffer, we
-  only extract as many bytes as were available.
-
-  @param buf the evbuffer to be read from
-  @param data the destination buffer to store the result
-  @param datlen the maximum size of the destination buffer
-  @return the number of bytes read, or -1 if we can't drain the buffer.
- */
-int evbuffer_remove(struct evbuffer *buf, void *data, size_t datlen);
-
-/**
-  Read data from an evbuffer, and leave the buffer unchanged.
-
-  If more bytes are requested than are available in the evbuffer, we
-  only extract as many bytes as were available.
-
-  @param buf the evbuffer to be read from
-  @param data_out the destination buffer to store the result
-  @param datlen the maximum size of the destination buffer
-  @return the number of bytes read, or -1 if we can't drain the buffer.
- */
-ev_ssize_t evbuffer_copyout(struct evbuffer *buf, void *data_out, size_t datlen);
-
-/**
-  Read data from an evbuffer into another evbuffer, draining
-  the bytes from the source buffer.  This function avoids copy
-  operations to the extent possible.
-
-  If more bytes are requested than are available in src, the src
-  buffer is drained completely.
-
-  @param src the evbuffer to be read from
-  @param dst the destination evbuffer to store the result into
-  @param datlen the maximum numbers of bytes to transfer
-  @return the number of bytes read
- */
-int evbuffer_remove_buffer(struct evbuffer *src, struct evbuffer *dst,
-    size_t datlen);
-
-/** Used to tell evbuffer_readln what kind of line-ending to look for.
- */
-enum evbuffer_eol_style {
-	/** Any sequence of CR and LF characters is acceptable as an
-	 * EOL.
-	 *
-	 * Note that this style can produce ambiguous results: the
-	 * sequence "CRLF" will be treated as a single EOL if it is
-	 * all in the buffer at once, but if you first read a CR from
-	 * the network and later read an LF from the network, it will
-	 * be treated as two EOLs.
-	 */
-	EVBUFFER_EOL_ANY,
-	/** An EOL is an LF, optionally preceded by a CR.  This style is
-	 * most useful for implementing text-based internet protocols. */
-	EVBUFFER_EOL_CRLF,
-	/** An EOL is a CR followed by an LF. */
-	EVBUFFER_EOL_CRLF_STRICT,
-	/** An EOL is a LF. */
-	EVBUFFER_EOL_LF
-};
-
-/**
- * Read a single line from an evbuffer.
- *
- * Reads a line terminated by an EOL as determined by the evbuffer_eol_style
- * argument.  Returns a newly allocated nul-terminated string; the caller must
- * free the returned value.  The EOL is not included in the returned string.
- *
- * @param buffer the evbuffer to read from
- * @param n_read_out if non-NULL, points to a size_t that is set to the
- *       number of characters in the returned string.  This is useful for
- *       strings that can contain NUL characters.
- * @param eol_style the style of line-ending to use.
- * @return pointer to a single line, or NULL if an error occurred
- */
-char *evbuffer_readln(struct evbuffer *buffer, size_t *n_read_out,
-    enum evbuffer_eol_style eol_style);
-
-/**
-  Move all data from one evbuffer into another evbuffer.
-
-  This is a destructive add.  The data from one buffer moves into
-  the other buffer.  However, no unnecessary memory copies occur.
-
-  @param outbuf the output buffer
-  @param inbuf the input buffer
-  @return 0 if successful, or -1 if an error occurred
-
-  @see evbuffer_remove_buffer()
- */
-int evbuffer_add_buffer(struct evbuffer *outbuf, struct evbuffer *inbuf);
-
-/**
-   A cleanup function for a piece of memory added to an evbuffer by
-   reference.
-
-   @see evbuffer_add_reference()
- */
-typedef void (*evbuffer_ref_cleanup_cb)(const void *data,
-    size_t datalen, void *extra);
-
-/**
-  Reference memory into an evbuffer without copying.
-
-  The memory needs to remain valid until all the added data has been
-  read.  This function keeps just a reference to the memory without
-  actually incurring the overhead of a copy.
-
-  @param outbuf the output buffer
-  @param data the memory to reference
-  @param datlen how memory to reference
-  @param cleanupfn callback to be invoked when the memory is no longer
-	referenced by this evbuffer.
-  @param cleanupfn_arg optional argument to the cleanup callback
-  @return 0 if successful, or -1 if an error occurred
- */
-int evbuffer_add_reference(struct evbuffer *outbuf,
-    const void *data, size_t datlen,
-    evbuffer_ref_cleanup_cb cleanupfn, void *cleanupfn_arg);
-
-/**
-  Copy data from a file into the evbuffer for writing to a socket.
-
-  This function avoids unnecessary data copies between userland and
-  kernel.  If sendfile is available and the EVBUFFER_FLAG_DRAINS_TO_FD
-  flag is set, it uses those functions.  Otherwise, it tries to use
-  mmap (or CreateFileMapping on Windows).
-
-  The function owns the resulting file descriptor and will close it
-  when finished transferring data.
-
-  The results of using evbuffer_remove() or evbuffer_pullup() on
-  evbuffers whose data was added using this function are undefined.
-
-  @param outbuf the output buffer
-  @param fd the file descriptor
-  @param offset the offset from which to read data
-  @param length how much data to read
-  @return 0 if successful, or -1 if an error occurred
-*/
-
-int evbuffer_add_file(struct evbuffer *outbuf, int fd, ev_off_t offset,
-    ev_off_t length);
-
-/**
-  Append a formatted string to the end of an evbuffer.
-
-  The string is formated as printf.
-
-  @param buf the evbuffer that will be appended to
-  @param fmt a format string
-  @param ... arguments that will be passed to printf(3)
-  @return The number of bytes added if successful, or -1 if an error occurred.
-
-  @see evutil_printf(), evbuffer_add_vprintf()
- */
-int evbuffer_add_printf(struct evbuffer *buf, const char *fmt, ...)
-#ifdef __GNUC__
-  __attribute__((format(printf, 2, 3)))
-#endif
-;
-
-/**
-  Append a va_list formatted string to the end of an evbuffer.
-
-  @param buf the evbuffer that will be appended to
-  @param fmt a format string
-  @param ap a varargs va_list argument array that will be passed to vprintf(3)
-  @return The number of bytes added if successful, or -1 if an error occurred.
- */
-int evbuffer_add_vprintf(struct evbuffer *buf, const char *fmt, va_list ap)
-#ifdef __GNUC__
-	__attribute__((format(printf, 2, 0)))
-#endif
-;
-
-
-/**
-  Remove a specified number of bytes data from the beginning of an evbuffer.
-
-  @param buf the evbuffer to be drained
-  @param len the number of bytes to drain from the beginning of the buffer
-  @return 0 on success, -1 on failure.
- */
-int evbuffer_drain(struct evbuffer *buf, size_t len);
-
-
-/**
-  Write the contents of an evbuffer to a file descriptor.
-
-  The evbuffer will be drained after the bytes have been successfully written.
-
-  @param buffer the evbuffer to be written and drained
-  @param fd the file descriptor to be written to
-  @return the number of bytes written, or -1 if an error occurred
-  @see evbuffer_read()
- */
-int evbuffer_write(struct evbuffer *buffer, evutil_socket_t fd);
-
-/**
-  Write some of the contents of an evbuffer to a file descriptor.
-
-  The evbuffer will be drained after the bytes have been successfully written.
-
-  @param buffer the evbuffer to be written and drained
-  @param fd the file descriptor to be written to
-  @param howmuch the largest allowable number of bytes to write, or -1
-	to write as many bytes as we can.
-  @return the number of bytes written, or -1 if an error occurred
-  @see evbuffer_read()
- */
-int evbuffer_write_atmost(struct evbuffer *buffer, evutil_socket_t fd,
-						  ev_ssize_t howmuch);
-
-/**
-  Read from a file descriptor and store the result in an evbuffer.
-
-  @param buffer the evbuffer to store the result
-  @param fd the file descriptor to read from
-  @param howmuch the number of bytes to be read
-  @return the number of bytes read, or -1 if an error occurred
-  @see evbuffer_write()
- */
-int evbuffer_read(struct evbuffer *buffer, evutil_socket_t fd, int howmuch);
-
-/**
-   Search for a string within an evbuffer.
-
-   @param buffer the evbuffer to be searched
-   @param what the string to be searched for
-   @param len the length of the search string
-   @param start NULL or a pointer to a valid struct evbuffer_ptr.
-   @return a struct evbuffer_ptr whose 'pos' field has the offset of the
-     first occurrence of the string in the buffer after 'start'.  The 'pos'
-     field of the result is -1 if the string was not found.
- */
-struct evbuffer_ptr evbuffer_search(struct evbuffer *buffer, const char *what, size_t len, const struct evbuffer_ptr *start);
-
-/**
-   Search for a string within part of an evbuffer.
-
-   @param buffer the evbuffer to be searched
-   @param what the string to be searched for
-   @param len the length of the search string
-   @param start NULL or a pointer to a valid struct evbuffer_ptr that
-     indicates where we should start searching.
-   @param end NULL or a pointer to a valid struct evbuffer_ptr that
-     indicates where we should stop searching.
-   @return a struct evbuffer_ptr whose 'pos' field has the offset of the
-     first occurrence of the string in the buffer after 'start'.  The 'pos'
-     field of the result is -1 if the string was not found.
- */
-struct evbuffer_ptr evbuffer_search_range(struct evbuffer *buffer, const char *what, size_t len, const struct evbuffer_ptr *start, const struct evbuffer_ptr *end);
-
-/**
-   Defines how to adjust an evbuffer_ptr by evbuffer_ptr_set()
-
-   @see evbuffer_ptr_set() */
-enum evbuffer_ptr_how {
-	/** Sets the pointer to the position; can be called on with an
-	    uninitialized evbuffer_ptr. */
-	EVBUFFER_PTR_SET,
-	/** Advances the pointer by adding to the current position. */
-	EVBUFFER_PTR_ADD
-};
-
-/**
-   Sets the search pointer in the buffer to position.
-
-   If evbuffer_ptr is not initialized.  This function can only be called
-   with EVBUFFER_PTR_SET.
-
-   @param buffer the evbuffer to be search
-   @param ptr a pointer to a struct evbuffer_ptr
-   @param position the position at which to start the next search
-   @param how determines how the pointer should be manipulated.
-   @returns 0 on success or -1 otherwise
-*/
-int
-evbuffer_ptr_set(struct evbuffer *buffer, struct evbuffer_ptr *ptr,
-    size_t position, enum evbuffer_ptr_how how);
-
-/**
-   Search for an end-of-line string within an evbuffer.
-
-   @param buffer the evbuffer to be searched
-   @param start NULL or a pointer to a valid struct evbuffer_ptr to start
-      searching at.
-   @param eol_len_out If non-NULL, the pointed-to value will be set to
-      the length of the end-of-line string.
-   @param eol_style The kind of EOL to look for; see evbuffer_readln() for
-      more information
-   @return a struct evbuffer_ptr whose 'pos' field has the offset of the
-     first occurrence EOL in the buffer after 'start'.  The 'pos'
-     field of the result is -1 if the string was not found.
- */
-struct evbuffer_ptr evbuffer_search_eol(struct evbuffer *buffer,
-    struct evbuffer_ptr *start, size_t *eol_len_out,
-    enum evbuffer_eol_style eol_style);
-
-/** Function to peek at data inside an evbuffer without removing it or
-    copying it out.
-
-    Pointers to the data are returned by filling the 'vec_out' array
-    with pointers to one or more extents of data inside the buffer.
-
-    The total data in the extents that you get back may be more than
-    you requested (if there is more data last extent than you asked
-    for), or less (if you do not provide enough evbuffer_iovecs, or if
-    the buffer does not have as much data as you asked to see).
-
-    @param buffer the evbuffer to peek into,
-    @param len the number of bytes to try to peek.  If len is negative, we
-       will try to fill as much of vec_out as we can.  If len is negative
-       and vec_out is not provided, we return the number of evbuffer_iovecs
-       that would be needed to get all the data in the buffer.
-    @param start_at an evbuffer_ptr indicating the point at which we
-       should start looking for data.  NULL means, "At the start of the
-       buffer."
-    @param vec_out an array of evbuffer_iovec
-    @param n_vec the length of vec_out.  If 0, we only count how many
-       extents would be necessary to point to the requested amount of
-       data.
-    @return The number of extents needed.  This may be less than n_vec
-       if we didn't need all the evbuffer_iovecs we were given, or more
-       than n_vec if we would need more to return all the data that was
-       requested.
- */
-int evbuffer_peek(struct evbuffer *buffer, ev_ssize_t len,
-    struct evbuffer_ptr *start_at,
-    struct evbuffer_iovec *vec_out, int n_vec);
-
-
-/** Structure passed to an evbuffer_cb_func evbuffer callback
-
-    @see evbuffer_cb_func, evbuffer_add_cb()
- */
-struct evbuffer_cb_info {
-	/** The number of bytes in this evbuffer when callbacks were last
-	 * invoked. */
-	size_t orig_size;
-	/** The number of bytes added since callbacks were last invoked. */
-	size_t n_added;
-	/** The number of bytes removed since callbacks were last invoked. */
-	size_t n_deleted;
-};
-
-/** Type definition for a callback that is invoked whenever data is added or
-    removed from an evbuffer.
-
-    An evbuffer may have one or more callbacks set at a time.  The order
-    in which they are executed is undefined.
-
-    A callback function may add more callbacks, or remove itself from the
-    list of callbacks, or add or remove data from the buffer.  It may not
-    remove another callback from the list.
-
-    If a callback adds or removes data from the buffer or from another
-    buffer, this can cause a recursive invocation of your callback or
-    other callbacks.  If you ask for an infinite loop, you might just get
-    one: watch out!
-
-    @param buffer the buffer whose size has changed
-    @param info a structure describing how the buffer changed.
-    @param arg a pointer to user data
-*/
-typedef void (*evbuffer_cb_func)(struct evbuffer *buffer, const struct evbuffer_cb_info *info, void *arg);
-
-struct evbuffer_cb_entry;
-/** Add a new callback to an evbuffer.
-
-  Subsequent calls to evbuffer_add_cb() add new callbacks.  To remove this
-  callback, call evbuffer_remove_cb or evbuffer_remove_cb_entry.
-
-  @param buffer the evbuffer to be monitored
-  @param cb the callback function to invoke when the evbuffer is modified,
-	or NULL to remove all callbacks.
-  @param cbarg an argument to be provided to the callback function
-  @return a handle to the callback on success, or NULL on failure.
- */
-struct evbuffer_cb_entry *evbuffer_add_cb(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg);
-
-/** Remove a callback from an evbuffer, given a handle returned from
-    evbuffer_add_cb.
-
-    Calling this function invalidates the handle.
-
-    @return 0 if a callback was removed, or -1 if no matching callback was
-    found.
- */
-int evbuffer_remove_cb_entry(struct evbuffer *buffer,
-			     struct evbuffer_cb_entry *ent);
-
-/** Remove a callback from an evbuffer, given the function and argument
-    used to add it.
-
-    @return 0 if a callback was removed, or -1 if no matching callback was
-    found.
- */
-int evbuffer_remove_cb(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg);
-
-/** If this flag is not set, then a callback is temporarily disabled, and
- * should not be invoked.
- *
- * @see evbuffer_cb_set_flags(), evbuffer_cb_clear_flags()
- */
-#define EVBUFFER_CB_ENABLED 1
-
-/** Change the flags that are set for a callback on a buffer by adding more.
-
-    @param buffer the evbuffer that the callback is watching.
-    @param cb the callback whose status we want to change.
-    @param flags EVBUFFER_CB_ENABLED to re-enable the callback.
-    @return 0 on success, -1 on failure.
- */
-int evbuffer_cb_set_flags(struct evbuffer *buffer,
-			  struct evbuffer_cb_entry *cb, ev_uint32_t flags);
-
-/** Change the flags that are set for a callback on a buffer by removing some
-
-    @param buffer the evbuffer that the callback is watching.
-    @param cb the callback whose status we want to change.
-    @param flags EVBUFFER_CB_ENABLED to disable the callback.
-    @return 0 on success, -1 on failure.
- */
-int evbuffer_cb_clear_flags(struct evbuffer *buffer,
-			  struct evbuffer_cb_entry *cb, ev_uint32_t flags);
-
-#if 0
-/** Postpone calling a given callback until unsuspend is called later.
-
-    This is different from disabling the callback, since the callback will get
-	invoked later if the buffer size changes between now and when we unsuspend
-	it.
-
-	@param the buffer that the callback is watching.
-	@param cb the callback we want to suspend.
- */
-void evbuffer_cb_suspend(struct evbuffer *buffer, struct evbuffer_cb_entry *cb);
-/** Stop postponing a callback that we postponed with evbuffer_cb_suspend.
-
-	If data was added to or removed from the buffer while the callback was
-	suspended, the callback will get called once now.
-
-	@param the buffer that the callback is watching.
-	@param cb the callback we want to stop suspending.
- */
-void evbuffer_cb_unsuspend(struct evbuffer *buffer, struct evbuffer_cb_entry *cb);
-#endif
-
-/**
-  Makes the data at the beginning of an evbuffer contiguous.
-
-  @param buf the evbuffer to make contiguous
-  @param size the number of bytes to make contiguous, or -1 to make the
-	entire buffer contiguous.
-  @return a pointer to the contiguous memory array
-*/
-
-unsigned char *evbuffer_pullup(struct evbuffer *buf, ev_ssize_t size);
-
-/**
-  Prepends data to the beginning of the evbuffer
-
-  @param buf the evbuffer to which to prepend data
-  @param data a pointer to the memory to prepend
-  @param size the number of bytes to prepend
-  @return 0 if successful, or -1 otherwise
-*/
-
-int evbuffer_prepend(struct evbuffer *buf, const void *data, size_t size);
-
-/**
-  Prepends all data from the src evbuffer to the beginning of the dst
-  evbuffer.
-
-  @param dst the evbuffer to which to prepend data
-  @param src the evbuffer to prepend; it will be emptied as a result
-  @return 0 if successful, or -1 otherwise
-*/
-int evbuffer_prepend_buffer(struct evbuffer *dst, struct evbuffer* src);
-
-/**
-   Prevent calls that modify an evbuffer from succeeding. A buffer may
-   frozen at the front, at the back, or at both the front and the back.
-
-   If the front of a buffer is frozen, operations that drain data from
-   the front of the buffer, or that prepend data to the buffer, will
-   fail until it is unfrozen.   If the back a buffer is frozen, operations
-   that append data from the buffer will fail until it is unfrozen.
-
-   @param buf The buffer to freeze
-   @param at_front If true, we freeze the front of the buffer.  If false,
-      we freeze the back.
-   @return 0 on success, -1 on failure.
-*/
-int evbuffer_freeze(struct evbuffer *buf, int at_front);
-/**
-   Re-enable calls that modify an evbuffer.
-
-   @param buf The buffer to un-freeze
-   @param at_front If true, we unfreeze the front of the buffer.  If false,
-      we unfreeze the back.
-   @return 0 on success, -1 on failure.
- */
-int evbuffer_unfreeze(struct evbuffer *buf, int at_front);
-
-struct event_base;
-/**
-   Force all the callbacks on an evbuffer to be run, not immediately after
-   the evbuffer is altered, but instead from inside the event loop.
-
-   This can be used to serialize all the callbacks to a single thread
-   of execution.
- */
-int evbuffer_defer_callbacks(struct evbuffer *buffer, struct event_base *base);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _EVENT2_BUFFER_H_ */
+/*
+ * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EVENT2_BUFFER_H_INCLUDED_
+#define EVENT2_BUFFER_H_INCLUDED_
+
+/** @file event2/buffer.h
+
+  Functions for buffering data for network sending or receiving.
+
+  An evbuffer can be used for preparing data before sending it to
+  the network or conversely for reading data from the network.
+  Evbuffers try to avoid memory copies as much as possible.  As a
+  result, evbuffers can be used to pass data around without actually
+  incurring the overhead of copying the data.
+
+  A new evbuffer can be allocated with evbuffer_new(), and can be
+  freed with evbuffer_free().  Most users will be using evbuffers via
+  the bufferevent interface.  To access a bufferevent's evbuffers, use
+  bufferevent_get_input() and bufferevent_get_output().
+
+  There are several guidelines for using evbuffers.
+
+  - if you already know how much data you are going to add as a result
+    of calling evbuffer_add() multiple times, it makes sense to use
+    evbuffer_expand() first to make sure that enough memory is allocated
+    before hand.
+
+  - evbuffer_add_buffer() adds the contents of one buffer to the other
+    without incurring any unnecessary memory copies.
+
+  - evbuffer_add() and evbuffer_add_buffer() do not mix very well:
+    if you use them, you will wind up with fragmented memory in your
+	buffer.
+
+  - For high-performance code, you may want to avoid copying data into and out
+    of buffers.  You can skip the copy step by using
+    evbuffer_reserve_space()/evbuffer_commit_space() when writing into a
+    buffer, and evbuffer_peek() when reading.
+
+  In Libevent 2.0 and later, evbuffers are represented using a linked
+  list of memory chunks, with pointers to the first and last chunk in
+  the chain.
+
+  As the contents of an evbuffer can be stored in multiple different
+  memory blocks, it cannot be accessed directly.  Instead, evbuffer_pullup()
+  can be used to force a specified number of bytes to be contiguous. This
+  will cause memory reallocation and memory copies if the data is split
+  across multiple blocks.  It is more efficient, however, to use
+  evbuffer_peek() if you don't require that the memory to be contiguous.
+ */
+
+#include <event2/visibility.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <event2/event-config.h>
+#include <stdarg.h>
+#ifdef EVENT__HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef EVENT__HAVE_SYS_UIO_H
+#include <sys/uio.h>
+#endif
+#include <event2/util.h>
+
+/**
+   An evbuffer is an opaque data type for efficiently buffering data to be
+   sent or received on the network.
+
+   @see event2/event.h for more information
+*/
+struct evbuffer
+#ifdef EVENT_IN_DOXYGEN_
+{}
+#endif
+;
+
+/**
+    Pointer to a position within an evbuffer.
+
+    Used when repeatedly searching through a buffer.  Calling any function
+    that modifies or re-packs the buffer contents may invalidate all
+    evbuffer_ptrs for that buffer.  Do not modify or contruct these values
+    except with evbuffer_ptr_set.
+
+    An evbuffer_ptr can represent any position from the start of a buffer up
+    to a position immediately after the end of a buffer.
+
+    @see evbuffer_ptr_set()
+ */
+struct evbuffer_ptr {
+	ev_ssize_t pos;
+
+	/* Do not alter or rely on the values of fields: they are for internal
+	 * use */
+	struct {
+		void *chain;
+		size_t pos_in_chain;
+	} internal_;
+};
+
+/** Describes a single extent of memory inside an evbuffer.  Used for
+    direct-access functions.
+
+    @see evbuffer_reserve_space, evbuffer_commit_space, evbuffer_peek
+ */
+#ifdef EVENT__HAVE_SYS_UIO_H
+#define evbuffer_iovec iovec
+/* Internal use -- defined only if we are using the native struct iovec */
+#define EVBUFFER_IOVEC_IS_NATIVE_
+#else
+struct evbuffer_iovec {
+	/** The start of the extent of memory. */
+	void *iov_base;
+	/** The length of the extent of memory. */
+	size_t iov_len;
+};
+#endif
+
+/**
+  Allocate storage for a new evbuffer.
+
+  @return a pointer to a newly allocated evbuffer struct, or NULL if an error
+	occurred
+ */
+EVENT2_EXPORT_SYMBOL
+struct evbuffer *evbuffer_new(void);
+/**
+  Deallocate storage for an evbuffer.
+
+  @param buf pointer to the evbuffer to be freed
+ */
+EVENT2_EXPORT_SYMBOL
+void evbuffer_free(struct evbuffer *buf);
+
+/**
+   Enable locking on an evbuffer so that it can safely be used by multiple
+   threads at the same time.
+
+   NOTE: when locking is enabled, the lock will be held when callbacks are
+   invoked.  This could result in deadlock if you aren't careful.  Plan
+   accordingly!
+
+   @param buf An evbuffer to make lockable.
+   @param lock A lock object, or NULL if we should allocate our own.
+   @return 0 on success, -1 on failure.
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_enable_locking(struct evbuffer *buf, void *lock);
+
+/**
+   Acquire the lock on an evbuffer.  Has no effect if locking was not enabled
+   with evbuffer_enable_locking.
+*/
+EVENT2_EXPORT_SYMBOL
+void evbuffer_lock(struct evbuffer *buf);
+
+/**
+   Release the lock on an evbuffer.  Has no effect if locking was not enabled
+   with evbuffer_enable_locking.
+*/
+EVENT2_EXPORT_SYMBOL
+void evbuffer_unlock(struct evbuffer *buf);
+
+
+/** If this flag is set, then we will not use evbuffer_peek(),
+ * evbuffer_remove(), evbuffer_remove_buffer(), and so on to read bytes
+ * from this buffer: we'll only take bytes out of this buffer by
+ * writing them to the network (as with evbuffer_write_atmost), by
+ * removing them without observing them (as with evbuffer_drain),
+ * or by copying them all out at once (as with evbuffer_add_buffer).
+ *
+ * Using this option allows the implementation to use sendfile-based
+ * operations for evbuffer_add_file(); see that function for more
+ * information.
+ *
+ * This flag is on by default for bufferevents that can take advantage
+ * of it; you should never actually need to set it on a bufferevent's
+ * output buffer.
+ */
+#define EVBUFFER_FLAG_DRAINS_TO_FD 1
+
+/** Change the flags that are set for an evbuffer by adding more.
+ *
+ * @param buffer the evbuffer that the callback is watching.
+ * @param cb the callback whose status we want to change.
+ * @param flags One or more EVBUFFER_FLAG_* options
+ * @return 0 on success, -1 on failure.
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_set_flags(struct evbuffer *buf, ev_uint64_t flags);
+/** Change the flags that are set for an evbuffer by removing some.
+ *
+ * @param buffer the evbuffer that the callback is watching.
+ * @param cb the callback whose status we want to change.
+ * @param flags One or more EVBUFFER_FLAG_* options
+ * @return 0 on success, -1 on failure.
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_clear_flags(struct evbuffer *buf, ev_uint64_t flags);
+
+/**
+  Returns the total number of bytes stored in the evbuffer
+
+  @param buf pointer to the evbuffer
+  @return the number of bytes stored in the evbuffer
+*/
+EVENT2_EXPORT_SYMBOL
+size_t evbuffer_get_length(const struct evbuffer *buf);
+
+/**
+   Returns the number of contiguous available bytes in the first buffer chain.
+
+   This is useful when processing data that might be split into multiple
+   chains, or that might all be in the first chain.  Calls to
+   evbuffer_pullup() that cause reallocation and copying of data can thus be
+   avoided.
+
+   @param buf pointer to the evbuffer
+   @return 0 if no data is available, otherwise the number of available bytes
+     in the first buffer chain.
+*/
+EVENT2_EXPORT_SYMBOL
+size_t evbuffer_get_contiguous_space(const struct evbuffer *buf);
+
+/**
+  Expands the available space in an evbuffer.
+
+  Expands the available space in the evbuffer to at least datlen, so that
+  appending datlen additional bytes will not require any new allocations.
+
+  @param buf the evbuffer to be expanded
+  @param datlen the new minimum length requirement
+  @return 0 if successful, or -1 if an error occurred
+*/
+EVENT2_EXPORT_SYMBOL
+int evbuffer_expand(struct evbuffer *buf, size_t datlen);
+
+/**
+   Reserves space in the last chain or chains of an evbuffer.
+
+   Makes space available in the last chain or chains of an evbuffer that can
+   be arbitrarily written to by a user.  The space does not become
+   available for reading until it has been committed with
+   evbuffer_commit_space().
+
+   The space is made available as one or more extents, represented by
+   an initial pointer and a length.  You can force the memory to be
+   available as only one extent.  Allowing more extents, however, makes the
+   function more efficient.
+
+   Multiple subsequent calls to this function will make the same space
+   available until evbuffer_commit_space() has been called.
+
+   It is an error to do anything that moves around the buffer's internal
+   memory structures before committing the space.
+
+   NOTE: The code currently does not ever use more than two extents.
+   This may change in future versions.
+
+   @param buf the evbuffer in which to reserve space.
+   @param size how much space to make available, at minimum.  The
+      total length of the extents may be greater than the requested
+      length.
+   @param vec an array of one or more evbuffer_iovec structures to
+      hold pointers to the reserved extents of memory.
+   @param n_vec The length of the vec array.  Must be at least 1;
+       2 is more efficient.
+   @return the number of provided extents, or -1 on error.
+   @see evbuffer_commit_space()
+*/
+EVENT2_EXPORT_SYMBOL
+int
+evbuffer_reserve_space(struct evbuffer *buf, ev_ssize_t size,
+    struct evbuffer_iovec *vec, int n_vec);
+
+/**
+   Commits previously reserved space.
+
+   Commits some of the space previously reserved with
+   evbuffer_reserve_space().  It then becomes available for reading.
+
+   This function may return an error if the pointer in the extents do
+   not match those returned from evbuffer_reserve_space, or if data
+   has been added to the buffer since the space was reserved.
+
+   If you want to commit less data than you got reserved space for,
+   modify the iov_len pointer of the appropriate extent to a smaller
+   value.  Note that you may have received more space than you
+   requested if it was available!
+
+   @param buf the evbuffer in which to reserve space.
+   @param vec one or two extents returned by evbuffer_reserve_space.
+   @param n_vecs the number of extents.
+   @return 0 on success, -1 on error
+   @see evbuffer_reserve_space()
+*/
+EVENT2_EXPORT_SYMBOL
+int evbuffer_commit_space(struct evbuffer *buf,
+    struct evbuffer_iovec *vec, int n_vecs);
+
+/**
+  Append data to the end of an evbuffer.
+
+  @param buf the evbuffer to be appended to
+  @param data pointer to the beginning of the data buffer
+  @param datlen the number of bytes to be copied from the data buffer
+  @return 0 on success, -1 on failure.
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_add(struct evbuffer *buf, const void *data, size_t datlen);
+
+
+/**
+  Read data from an evbuffer and drain the bytes read.
+
+  If more bytes are requested than are available in the evbuffer, we
+  only extract as many bytes as were available.
+
+  @param buf the evbuffer to be read from
+  @param data the destination buffer to store the result
+  @param datlen the maximum size of the destination buffer
+  @return the number of bytes read, or -1 if we can't drain the buffer.
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_remove(struct evbuffer *buf, void *data, size_t datlen);
+
+/**
+  Read data from an evbuffer, and leave the buffer unchanged.
+
+  If more bytes are requested than are available in the evbuffer, we
+  only extract as many bytes as were available.
+
+  @param buf the evbuffer to be read from
+  @param data_out the destination buffer to store the result
+  @param datlen the maximum size of the destination buffer
+  @return the number of bytes read, or -1 if we can't drain the buffer.
+ */
+EVENT2_EXPORT_SYMBOL
+ev_ssize_t evbuffer_copyout(struct evbuffer *buf, void *data_out, size_t datlen);
+
+/**
+  Read data from the middle of an evbuffer, and leave the buffer unchanged.
+
+  If more bytes are requested than are available in the evbuffer, we
+  only extract as many bytes as were available.
+
+  @param buf the evbuffer to be read from
+  @param pos the position to start reading from
+  @param data_out the destination buffer to store the result
+  @param datlen the maximum size of the destination buffer
+  @return the number of bytes read, or -1 if we can't drain the buffer.
+ */
+EVENT2_EXPORT_SYMBOL
+ev_ssize_t evbuffer_copyout_from(struct evbuffer *buf, const struct evbuffer_ptr *pos, void *data_out, size_t datlen);
+
+/**
+  Read data from an evbuffer into another evbuffer, draining
+  the bytes from the source buffer.  This function avoids copy
+  operations to the extent possible.
+
+  If more bytes are requested than are available in src, the src
+  buffer is drained completely.
+
+  @param src the evbuffer to be read from
+  @param dst the destination evbuffer to store the result into
+  @param datlen the maximum numbers of bytes to transfer
+  @return the number of bytes read
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_remove_buffer(struct evbuffer *src, struct evbuffer *dst,
+    size_t datlen);
+
+/** Used to tell evbuffer_readln what kind of line-ending to look for.
+ */
+enum evbuffer_eol_style {
+	/** Any sequence of CR and LF characters is acceptable as an
+	 * EOL.
+	 *
+	 * Note that this style can produce ambiguous results: the
+	 * sequence "CRLF" will be treated as a single EOL if it is
+	 * all in the buffer at once, but if you first read a CR from
+	 * the network and later read an LF from the network, it will
+	 * be treated as two EOLs.
+	 */
+	EVBUFFER_EOL_ANY,
+	/** An EOL is an LF, optionally preceded by a CR.  This style is
+	 * most useful for implementing text-based internet protocols. */
+	EVBUFFER_EOL_CRLF,
+	/** An EOL is a CR followed by an LF. */
+	EVBUFFER_EOL_CRLF_STRICT,
+	/** An EOL is a LF. */
+	EVBUFFER_EOL_LF,
+	/** An EOL is a NUL character (that is, a single byte with value 0) */
+	EVBUFFER_EOL_NUL
+};
+
+/**
+ * Read a single line from an evbuffer.
+ *
+ * Reads a line terminated by an EOL as determined by the evbuffer_eol_style
+ * argument.  Returns a newly allocated nul-terminated string; the caller must
+ * free the returned value.  The EOL is not included in the returned string.
+ *
+ * @param buffer the evbuffer to read from
+ * @param n_read_out if non-NULL, points to a size_t that is set to the
+ *       number of characters in the returned string.  This is useful for
+ *       strings that can contain NUL characters.
+ * @param eol_style the style of line-ending to use.
+ * @return pointer to a single line, or NULL if an error occurred
+ */
+EVENT2_EXPORT_SYMBOL
+char *evbuffer_readln(struct evbuffer *buffer, size_t *n_read_out,
+    enum evbuffer_eol_style eol_style);
+
+/**
+  Move all data from one evbuffer into another evbuffer.
+
+  This is a destructive add.  The data from one buffer moves into
+  the other buffer.  However, no unnecessary memory copies occur.
+
+  @param outbuf the output buffer
+  @param inbuf the input buffer
+  @return 0 if successful, or -1 if an error occurred
+
+  @see evbuffer_remove_buffer()
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_add_buffer(struct evbuffer *outbuf, struct evbuffer *inbuf);
+
+/**
+  Copy data from one evbuffer into another evbuffer.
+
+  This is a non-destructive add.  The data from one buffer is copied
+  into the other buffer.  However, no unnecessary memory copies occur.
+
+  Note that buffers already containing buffer references can't be added
+  to other buffers.
+
+  @param outbuf the output buffer
+  @param inbuf the input buffer
+  @return 0 if successful, or -1 if an error occurred
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_add_buffer_reference(struct evbuffer *outbuf,
+    struct evbuffer *inbuf);
+
+/**
+   A cleanup function for a piece of memory added to an evbuffer by
+   reference.
+
+   @see evbuffer_add_reference()
+ */
+typedef void (*evbuffer_ref_cleanup_cb)(const void *data,
+    size_t datalen, void *extra);
+
+/**
+  Reference memory into an evbuffer without copying.
+
+  The memory needs to remain valid until all the added data has been
+  read.  This function keeps just a reference to the memory without
+  actually incurring the overhead of a copy.
+
+  @param outbuf the output buffer
+  @param data the memory to reference
+  @param datlen how memory to reference
+  @param cleanupfn callback to be invoked when the memory is no longer
+	referenced by this evbuffer.
+  @param cleanupfn_arg optional argument to the cleanup callback
+  @return 0 if successful, or -1 if an error occurred
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_add_reference(struct evbuffer *outbuf,
+    const void *data, size_t datlen,
+    evbuffer_ref_cleanup_cb cleanupfn, void *cleanupfn_arg);
+
+/**
+  Copy data from a file into the evbuffer for writing to a socket.
+
+  This function avoids unnecessary data copies between userland and
+  kernel.  If sendfile is available and the EVBUFFER_FLAG_DRAINS_TO_FD
+  flag is set, it uses those functions.  Otherwise, it tries to use
+  mmap (or CreateFileMapping on Windows).
+
+  The function owns the resulting file descriptor and will close it
+  when finished transferring data.
+
+  The results of using evbuffer_remove() or evbuffer_pullup() on
+  evbuffers whose data was added using this function are undefined.
+
+  For more fine-grained control, use evbuffer_add_file_segment.
+
+  @param outbuf the output buffer
+  @param fd the file descriptor
+  @param offset the offset from which to read data
+  @param length how much data to read, or -1 to read as much as possible.
+    (-1 requires that 'fd' support fstat.)
+  @return 0 if successful, or -1 if an error occurred
+*/
+
+EVENT2_EXPORT_SYMBOL
+int evbuffer_add_file(struct evbuffer *outbuf, int fd, ev_off_t offset,
+    ev_off_t length);
+
+/**
+  An evbuffer_file_segment holds a reference to a range of a file --
+  possibly the whole file! -- for use in writing from an evbuffer to a
+  socket.  It could be implemented with mmap, sendfile, splice, or (if all
+  else fails) by just pulling all the data into RAM.  A single
+  evbuffer_file_segment can be added more than once, and to more than one
+  evbuffer.
+ */
+struct evbuffer_file_segment;
+
+/**
+    Flag for creating evbuffer_file_segment: If this flag is set, then when
+    the evbuffer_file_segment is freed and no longer in use by any
+    evbuffer, the underlying fd is closed.
+ */
+#define EVBUF_FS_CLOSE_ON_FREE    0x01
+/**
+   Flag for creating evbuffer_file_segment: Disable memory-map based
+   implementations.
+ */
+#define EVBUF_FS_DISABLE_MMAP     0x02
+/**
+   Flag for creating evbuffer_file_segment: Disable direct fd-to-fd
+   implementations (including sendfile and splice).
+
+   You might want to use this option if data needs to be taken from the
+   evbuffer by any means other than writing it to the network: the sendfile
+   backend is fast, but it only works for sending files directly to the
+   network.
+ */
+#define EVBUF_FS_DISABLE_SENDFILE 0x04
+/**
+   Flag for creating evbuffer_file_segment: Do not allocate a lock for this
+   segment.  If this option is set, then neither the segment nor any
+   evbuffer it is added to may ever be accessed from more than one thread
+   at a time.
+ */
+#define EVBUF_FS_DISABLE_LOCKING  0x08
+
+/**
+   A cleanup function for a evbuffer_file_segment added to an evbuffer
+   for reference.
+ */
+typedef void (*evbuffer_file_segment_cleanup_cb)(
+    struct evbuffer_file_segment const* seg, int flags, void* arg);
+
+/**
+   Create and return a new evbuffer_file_segment for reading data from a
+   file and sending it out via an evbuffer.
+
+   This function avoids unnecessary data copies between userland and
+   kernel.  Where available, it uses sendfile or splice.
+
+   The file descriptor must not be closed so long as any evbuffer is using
+   this segment.
+
+   The results of using evbuffer_remove() or evbuffer_pullup() or any other
+   function that reads bytes from an evbuffer on any evbuffer containing
+   the newly returned segment are undefined, unless you pass the
+   EVBUF_FS_DISABLE_SENDFILE flag to this function.
+
+   @param fd an open file to read from.
+   @param offset an index within the file at which to start reading
+   @param length how much data to read, or -1 to read as much as possible.
+      (-1 requires that 'fd' support fstat.)
+   @param flags any number of the EVBUF_FS_* flags
+   @return a new evbuffer_file_segment, or NULL on failure.
+ **/
+EVENT2_EXPORT_SYMBOL
+struct evbuffer_file_segment *evbuffer_file_segment_new(
+	int fd, ev_off_t offset, ev_off_t length, unsigned flags);
+
+/**
+   Free an evbuffer_file_segment
+
+   It is safe to call this function even if the segment has been added to
+   one or more evbuffers.  The evbuffer_file_segment will not be freed
+   until no more references to it exist.
+ */
+EVENT2_EXPORT_SYMBOL
+void evbuffer_file_segment_free(struct evbuffer_file_segment *seg);
+
+/**
+   Add cleanup callback and argument for the callback to an
+   evbuffer_file_segment.
+
+   The cleanup callback will be invoked when no more references to the
+   evbuffer_file_segment exist.
+ **/
+EVENT2_EXPORT_SYMBOL
+void evbuffer_file_segment_add_cleanup_cb(struct evbuffer_file_segment *seg,
+	evbuffer_file_segment_cleanup_cb cb, void* arg);
+
+/**
+   Insert some or all of an evbuffer_file_segment at the end of an evbuffer
+
+   Note that the offset and length parameters of this function have a
+   different meaning from those provided to evbuffer_file_segment_new: When
+   you create the segment, the offset is the offset _within the file_, and
+   the length is the length _of the segment_, whereas when you add a
+   segment to an evbuffer, the offset is _within the segment_ and the
+   length is the length of the _part of the segment you want to use.
+
+   In other words, if you have a 10 KiB file, and you create an
+   evbuffer_file_segment for it with offset 20 and length 1000, it will
+   refer to bytes 20..1019 inclusive.  If you then pass this segment to
+   evbuffer_add_file_segment and specify an offset of 20 and a length of
+   50, you will be adding bytes 40..99 inclusive.
+
+   @param buf the evbuffer to append to
+   @param seg the segment to add
+   @param offset the offset within the segment to start from
+   @param length the amount of data to add, or -1 to add it all.
+   @return 0 on success, -1 on failure.
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_add_file_segment(struct evbuffer *buf,
+    struct evbuffer_file_segment *seg, ev_off_t offset, ev_off_t length);
+
+/**
+  Append a formatted string to the end of an evbuffer.
+
+  The string is formated as printf.
+
+  @param buf the evbuffer that will be appended to
+  @param fmt a format string
+  @param ... arguments that will be passed to printf(3)
+  @return The number of bytes added if successful, or -1 if an error occurred.
+
+  @see evutil_printf(), evbuffer_add_vprintf()
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_add_printf(struct evbuffer *buf, const char *fmt, ...)
+#ifdef __GNUC__
+  __attribute__((format(printf, 2, 3)))
+#endif
+;
+
+/**
+  Append a va_list formatted string to the end of an evbuffer.
+
+  @param buf the evbuffer that will be appended to
+  @param fmt a format string
+  @param ap a varargs va_list argument array that will be passed to vprintf(3)
+  @return The number of bytes added if successful, or -1 if an error occurred.
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_add_vprintf(struct evbuffer *buf, const char *fmt, va_list ap)
+#ifdef __GNUC__
+	__attribute__((format(printf, 2, 0)))
+#endif
+;
+
+
+/**
+  Remove a specified number of bytes data from the beginning of an evbuffer.
+
+  @param buf the evbuffer to be drained
+  @param len the number of bytes to drain from the beginning of the buffer
+  @return 0 on success, -1 on failure.
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_drain(struct evbuffer *buf, size_t len);
+
+
+/**
+  Write the contents of an evbuffer to a file descriptor.
+
+  The evbuffer will be drained after the bytes have been successfully written.
+
+  @param buffer the evbuffer to be written and drained
+  @param fd the file descriptor to be written to
+  @return the number of bytes written, or -1 if an error occurred
+  @see evbuffer_read()
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_write(struct evbuffer *buffer, evutil_socket_t fd);
+
+/**
+  Write some of the contents of an evbuffer to a file descriptor.
+
+  The evbuffer will be drained after the bytes have been successfully written.
+
+  @param buffer the evbuffer to be written and drained
+  @param fd the file descriptor to be written to
+  @param howmuch the largest allowable number of bytes to write, or -1
+	to write as many bytes as we can.
+  @return the number of bytes written, or -1 if an error occurred
+  @see evbuffer_read()
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_write_atmost(struct evbuffer *buffer, evutil_socket_t fd,
+						  ev_ssize_t howmuch);
+
+/**
+  Read from a file descriptor and store the result in an evbuffer.
+
+  @param buffer the evbuffer to store the result
+  @param fd the file descriptor to read from
+  @param howmuch the number of bytes to be read
+  @return the number of bytes read, or -1 if an error occurred
+  @see evbuffer_write()
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_read(struct evbuffer *buffer, evutil_socket_t fd, int howmuch);
+
+/**
+   Search for a string within an evbuffer.
+
+   @param buffer the evbuffer to be searched
+   @param what the string to be searched for
+   @param len the length of the search string
+   @param start NULL or a pointer to a valid struct evbuffer_ptr.
+   @return a struct evbuffer_ptr whose 'pos' field has the offset of the
+     first occurrence of the string in the buffer after 'start'.  The 'pos'
+     field of the result is -1 if the string was not found.
+ */
+EVENT2_EXPORT_SYMBOL
+struct evbuffer_ptr evbuffer_search(struct evbuffer *buffer, const char *what, size_t len, const struct evbuffer_ptr *start);
+
+/**
+   Search for a string within part of an evbuffer.
+
+   @param buffer the evbuffer to be searched
+   @param what the string to be searched for
+   @param len the length of the search string
+   @param start NULL or a pointer to a valid struct evbuffer_ptr that
+     indicates where we should start searching.
+   @param end NULL or a pointer to a valid struct evbuffer_ptr that
+     indicates where we should stop searching.
+   @return a struct evbuffer_ptr whose 'pos' field has the offset of the
+     first occurrence of the string in the buffer after 'start'.  The 'pos'
+     field of the result is -1 if the string was not found.
+ */
+EVENT2_EXPORT_SYMBOL
+struct evbuffer_ptr evbuffer_search_range(struct evbuffer *buffer, const char *what, size_t len, const struct evbuffer_ptr *start, const struct evbuffer_ptr *end);
+
+/**
+   Defines how to adjust an evbuffer_ptr by evbuffer_ptr_set()
+
+   @see evbuffer_ptr_set() */
+enum evbuffer_ptr_how {
+	/** Sets the pointer to the position; can be called on with an
+	    uninitialized evbuffer_ptr. */
+	EVBUFFER_PTR_SET,
+	/** Advances the pointer by adding to the current position. */
+	EVBUFFER_PTR_ADD
+};
+
+/**
+   Sets the search pointer in the buffer to position.
+
+   There are two ways to use this function: you can call
+      evbuffer_ptr_set(buf, &pos, N, EVBUFFER_PTR_SET)
+   to move 'pos' to a position 'N' bytes after the start of the buffer, or
+      evbuffer_ptr_set(buf, &pos, N, EVBUFFER_PTR_ADD)
+   to move 'pos' forward by 'N' bytes.
+
+   If evbuffer_ptr is not initialized, this function can only be called
+   with EVBUFFER_PTR_SET.
+
+   An evbuffer_ptr can represent any position from the start of the buffer to
+   a position immediately after the end of the buffer.
+
+   @param buffer the evbuffer to be search
+   @param ptr a pointer to a struct evbuffer_ptr
+   @param position the position at which to start the next search
+   @param how determines how the pointer should be manipulated.
+   @returns 0 on success or -1 otherwise
+*/
+EVENT2_EXPORT_SYMBOL
+int
+evbuffer_ptr_set(struct evbuffer *buffer, struct evbuffer_ptr *ptr,
+    size_t position, enum evbuffer_ptr_how how);
+
+/**
+   Search for an end-of-line string within an evbuffer.
+
+   @param buffer the evbuffer to be searched
+   @param start NULL or a pointer to a valid struct evbuffer_ptr to start
+      searching at.
+   @param eol_len_out If non-NULL, the pointed-to value will be set to
+      the length of the end-of-line string.
+   @param eol_style The kind of EOL to look for; see evbuffer_readln() for
+      more information
+   @return a struct evbuffer_ptr whose 'pos' field has the offset of the
+     first occurrence EOL in the buffer after 'start'.  The 'pos'
+     field of the result is -1 if the string was not found.
+ */
+EVENT2_EXPORT_SYMBOL
+struct evbuffer_ptr evbuffer_search_eol(struct evbuffer *buffer,
+    struct evbuffer_ptr *start, size_t *eol_len_out,
+    enum evbuffer_eol_style eol_style);
+
+/** Function to peek at data inside an evbuffer without removing it or
+    copying it out.
+
+    Pointers to the data are returned by filling the 'vec_out' array
+    with pointers to one or more extents of data inside the buffer.
+
+    The total data in the extents that you get back may be more than
+    you requested (if there is more data last extent than you asked
+    for), or less (if you do not provide enough evbuffer_iovecs, or if
+    the buffer does not have as much data as you asked to see).
+
+    @param buffer the evbuffer to peek into,
+    @param len the number of bytes to try to peek.  If len is negative, we
+       will try to fill as much of vec_out as we can.  If len is negative
+       and vec_out is not provided, we return the number of evbuffer_iovecs
+       that would be needed to get all the data in the buffer.
+    @param start_at an evbuffer_ptr indicating the point at which we
+       should start looking for data.  NULL means, "At the start of the
+       buffer."
+    @param vec_out an array of evbuffer_iovec
+    @param n_vec the length of vec_out.  If 0, we only count how many
+       extents would be necessary to point to the requested amount of
+       data.
+    @return The number of extents needed.  This may be less than n_vec
+       if we didn't need all the evbuffer_iovecs we were given, or more
+       than n_vec if we would need more to return all the data that was
+       requested.
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_peek(struct evbuffer *buffer, ev_ssize_t len,
+    struct evbuffer_ptr *start_at,
+    struct evbuffer_iovec *vec_out, int n_vec);
+
+
+/** Structure passed to an evbuffer_cb_func evbuffer callback
+
+    @see evbuffer_cb_func, evbuffer_add_cb()
+ */
+struct evbuffer_cb_info {
+	/** The number of bytes in this evbuffer when callbacks were last
+	 * invoked. */
+	size_t orig_size;
+	/** The number of bytes added since callbacks were last invoked. */
+	size_t n_added;
+	/** The number of bytes removed since callbacks were last invoked. */
+	size_t n_deleted;
+};
+
+/** Type definition for a callback that is invoked whenever data is added or
+    removed from an evbuffer.
+
+    An evbuffer may have one or more callbacks set at a time.  The order
+    in which they are executed is undefined.
+
+    A callback function may add more callbacks, or remove itself from the
+    list of callbacks, or add or remove data from the buffer.  It may not
+    remove another callback from the list.
+
+    If a callback adds or removes data from the buffer or from another
+    buffer, this can cause a recursive invocation of your callback or
+    other callbacks.  If you ask for an infinite loop, you might just get
+    one: watch out!
+
+    @param buffer the buffer whose size has changed
+    @param info a structure describing how the buffer changed.
+    @param arg a pointer to user data
+*/
+typedef void (*evbuffer_cb_func)(struct evbuffer *buffer, const struct evbuffer_cb_info *info, void *arg);
+
+struct evbuffer_cb_entry;
+/** Add a new callback to an evbuffer.
+
+  Subsequent calls to evbuffer_add_cb() add new callbacks.  To remove this
+  callback, call evbuffer_remove_cb or evbuffer_remove_cb_entry.
+
+  @param buffer the evbuffer to be monitored
+  @param cb the callback function to invoke when the evbuffer is modified,
+	or NULL to remove all callbacks.
+  @param cbarg an argument to be provided to the callback function
+  @return a handle to the callback on success, or NULL on failure.
+ */
+EVENT2_EXPORT_SYMBOL
+struct evbuffer_cb_entry *evbuffer_add_cb(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg);
+
+/** Remove a callback from an evbuffer, given a handle returned from
+    evbuffer_add_cb.
+
+    Calling this function invalidates the handle.
+
+    @return 0 if a callback was removed, or -1 if no matching callback was
+    found.
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_remove_cb_entry(struct evbuffer *buffer,
+			     struct evbuffer_cb_entry *ent);
+
+/** Remove a callback from an evbuffer, given the function and argument
+    used to add it.
+
+    @return 0 if a callback was removed, or -1 if no matching callback was
+    found.
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_remove_cb(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg);
+
+/** If this flag is not set, then a callback is temporarily disabled, and
+ * should not be invoked.
+ *
+ * @see evbuffer_cb_set_flags(), evbuffer_cb_clear_flags()
+ */
+#define EVBUFFER_CB_ENABLED 1
+
+/** Change the flags that are set for a callback on a buffer by adding more.
+
+    @param buffer the evbuffer that the callback is watching.
+    @param cb the callback whose status we want to change.
+    @param flags EVBUFFER_CB_ENABLED to re-enable the callback.
+    @return 0 on success, -1 on failure.
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_cb_set_flags(struct evbuffer *buffer,
+			  struct evbuffer_cb_entry *cb, ev_uint32_t flags);
+
+/** Change the flags that are set for a callback on a buffer by removing some
+
+    @param buffer the evbuffer that the callback is watching.
+    @param cb the callback whose status we want to change.
+    @param flags EVBUFFER_CB_ENABLED to disable the callback.
+    @return 0 on success, -1 on failure.
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_cb_clear_flags(struct evbuffer *buffer,
+			  struct evbuffer_cb_entry *cb, ev_uint32_t flags);
+
+#if 0
+/** Postpone calling a given callback until unsuspend is called later.
+
+    This is different from disabling the callback, since the callback will get
+	invoked later if the buffer size changes between now and when we unsuspend
+	it.
+
+	@param the buffer that the callback is watching.
+	@param cb the callback we want to suspend.
+ */
+EVENT2_EXPORT_SYMBOL
+void evbuffer_cb_suspend(struct evbuffer *buffer, struct evbuffer_cb_entry *cb);
+/** Stop postponing a callback that we postponed with evbuffer_cb_suspend.
+
+	If data was added to or removed from the buffer while the callback was
+	suspended, the callback will get called once now.
+
+	@param the buffer that the callback is watching.
+	@param cb the callback we want to stop suspending.
+ */
+EVENT2_EXPORT_SYMBOL
+void evbuffer_cb_unsuspend(struct evbuffer *buffer, struct evbuffer_cb_entry *cb);
+#endif
+
+/**
+  Makes the data at the beginning of an evbuffer contiguous.
+
+  @param buf the evbuffer to make contiguous
+  @param size the number of bytes to make contiguous, or -1 to make the
+	entire buffer contiguous.
+  @return a pointer to the contiguous memory array, or NULL if param size
+	requested more data than is present in the buffer.
+*/
+
+EVENT2_EXPORT_SYMBOL
+unsigned char *evbuffer_pullup(struct evbuffer *buf, ev_ssize_t size);
+
+/**
+  Prepends data to the beginning of the evbuffer
+
+  @param buf the evbuffer to which to prepend data
+  @param data a pointer to the memory to prepend
+  @param size the number of bytes to prepend
+  @return 0 if successful, or -1 otherwise
+*/
+
+EVENT2_EXPORT_SYMBOL
+int evbuffer_prepend(struct evbuffer *buf, const void *data, size_t size);
+
+/**
+  Prepends all data from the src evbuffer to the beginning of the dst
+  evbuffer.
+
+  @param dst the evbuffer to which to prepend data
+  @param src the evbuffer to prepend; it will be emptied as a result
+  @return 0 if successful, or -1 otherwise
+*/
+EVENT2_EXPORT_SYMBOL
+int evbuffer_prepend_buffer(struct evbuffer *dst, struct evbuffer* src);
+
+/**
+   Prevent calls that modify an evbuffer from succeeding. A buffer may
+   frozen at the front, at the back, or at both the front and the back.
+
+   If the front of a buffer is frozen, operations that drain data from
+   the front of the buffer, or that prepend data to the buffer, will
+   fail until it is unfrozen.   If the back a buffer is frozen, operations
+   that append data from the buffer will fail until it is unfrozen.
+
+   @param buf The buffer to freeze
+   @param at_front If true, we freeze the front of the buffer.  If false,
+      we freeze the back.
+   @return 0 on success, -1 on failure.
+*/
+EVENT2_EXPORT_SYMBOL
+int evbuffer_freeze(struct evbuffer *buf, int at_front);
+/**
+   Re-enable calls that modify an evbuffer.
+
+   @param buf The buffer to un-freeze
+   @param at_front If true, we unfreeze the front of the buffer.  If false,
+      we unfreeze the back.
+   @return 0 on success, -1 on failure.
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_unfreeze(struct evbuffer *buf, int at_front);
+
+struct event_base;
+/**
+   Force all the callbacks on an evbuffer to be run, not immediately after
+   the evbuffer is altered, but instead from inside the event loop.
+
+   This can be used to serialize all the callbacks to a single thread
+   of execution.
+ */
+EVENT2_EXPORT_SYMBOL
+int evbuffer_defer_callbacks(struct evbuffer *buffer, struct event_base *base);
+
+/**
+  Append data from 1 or more iovec's to an evbuffer
+
+  Calculates the number of bytes needed for an iovec structure and guarantees
+  all data will fit into a single chain. Can be used in lieu of functionality
+  which calls evbuffer_add() constantly before being used to increase
+  performance.
+
+  @param buffer the destination buffer
+  @param vec the source iovec
+  @param n_vec the number of iovec structures.
+  @return the number of bytes successfully written to the output buffer.
+*/
+EVENT2_EXPORT_SYMBOL
+size_t evbuffer_add_iovec(struct evbuffer * buffer, struct evbuffer_iovec * vec, int n_vec);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EVENT2_BUFFER_H_INCLUDED_ */
Index: dep/libevent/inc/event2/buffer_compat.h
===================================================================
--- dep/libevent/inc/event2/buffer_compat.h	(revision 49)
+++ dep/libevent/inc/event2/buffer_compat.h	(working copy)
@@ -1,110 +1,115 @@
-/*
- * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _EVENT2_BUFFER_COMPAT_H_
-#define _EVENT2_BUFFER_COMPAT_H_
-
-/** @file event2/buffer_compat.h
-
-	Obsolete and deprecated versions of the functions in buffer.h: provided
-	only for backward compatibility.
- */
-
-
-/**
-   Obsolete alias for evbuffer_readln(buffer, NULL, EOL_STYLE_ANY).
-
-   @deprecated This function is deprecated because its behavior is not correct
-      for almost any protocol, and also because it's wholly subsumed by
-      evbuffer_readln().
-
-   @param buffer the evbuffer to read from
-   @return pointer to a single line, or NULL if an error occurred
-
-*/
-char *evbuffer_readline(struct evbuffer *buffer);
-
-/** Type definition for a callback that is invoked whenever data is added or
-    removed from an evbuffer.
-
-    An evbuffer may have one or more callbacks set at a time.  The order
-    in which they are executed is undefined.
-
-    A callback function may add more callbacks, or remove itself from the
-    list of callbacks, or add or remove data from the buffer.  It may not
-    remove another callback from the list.
-
-    If a callback adds or removes data from the buffer or from another
-    buffer, this can cause a recursive invocation of your callback or
-    other callbacks.  If you ask for an infinite loop, you might just get
-    one: watch out!
-
-    @param buffer the buffer whose size has changed
-    @param old_len the previous length of the buffer
-    @param new_len the current length of the buffer
-    @param arg a pointer to user data
-*/
-typedef void (*evbuffer_cb)(struct evbuffer *buffer, size_t old_len, size_t new_len, void *arg);
-
-/**
-  Replace all callbacks on an evbuffer with a single new callback, or
-  remove them.
-
-  Subsequent calls to evbuffer_setcb() replace callbacks set by previous
-  calls.  Setting the callback to NULL removes any previously set callback.
-
-  @deprecated This function is deprecated because it clears all previous
-     callbacks set on the evbuffer, which can cause confusing behavior if
-     multiple parts of the code all want to add their own callbacks on a
-     buffer.  Instead, use evbuffer_add(), evbuffer_del(), and
-     evbuffer_setflags() to manage your own evbuffer callbacks without
-     interfering with callbacks set by others.
-
-  @param buffer the evbuffer to be monitored
-  @param cb the callback function to invoke when the evbuffer is modified,
-	 or NULL to remove all callbacks.
-  @param cbarg an argument to be provided to the callback function
- */
-void evbuffer_setcb(struct evbuffer *buffer, evbuffer_cb cb, void *cbarg);
-
-
-/**
-  Find a string within an evbuffer.
-
-  @param buffer the evbuffer to be searched
-  @param what the string to be searched for
-  @param len the length of the search string
-  @return a pointer to the beginning of the search string, or NULL if the search failed.
- */
-unsigned char *evbuffer_find(struct evbuffer *buffer, const unsigned char *what, size_t len);
-
-/** deprecated in favor of calling the functions directly */
-#define EVBUFFER_LENGTH(x)	evbuffer_get_length(x)
-/** deprecated in favor of calling the functions directly */
-#define EVBUFFER_DATA(x)	evbuffer_pullup((x), -1)
-
-#endif
-
+/*
+ * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef EVENT2_BUFFER_COMPAT_H_INCLUDED_
+#define EVENT2_BUFFER_COMPAT_H_INCLUDED_
+
+#include <event2/visibility.h>
+
+/** @file event2/buffer_compat.h
+
+	Obsolete and deprecated versions of the functions in buffer.h: provided
+	only for backward compatibility.
+ */
+
+
+/**
+   Obsolete alias for evbuffer_readln(buffer, NULL, EVBUFFER_EOL_ANY).
+
+   @deprecated This function is deprecated because its behavior is not correct
+      for almost any protocol, and also because it's wholly subsumed by
+      evbuffer_readln().
+
+   @param buffer the evbuffer to read from
+   @return pointer to a single line, or NULL if an error occurred
+
+*/
+EVENT2_EXPORT_SYMBOL
+char *evbuffer_readline(struct evbuffer *buffer);
+
+/** Type definition for a callback that is invoked whenever data is added or
+    removed from an evbuffer.
+
+    An evbuffer may have one or more callbacks set at a time.  The order
+    in which they are executed is undefined.
+
+    A callback function may add more callbacks, or remove itself from the
+    list of callbacks, or add or remove data from the buffer.  It may not
+    remove another callback from the list.
+
+    If a callback adds or removes data from the buffer or from another
+    buffer, this can cause a recursive invocation of your callback or
+    other callbacks.  If you ask for an infinite loop, you might just get
+    one: watch out!
+
+    @param buffer the buffer whose size has changed
+    @param old_len the previous length of the buffer
+    @param new_len the current length of the buffer
+    @param arg a pointer to user data
+*/
+typedef void (*evbuffer_cb)(struct evbuffer *buffer, size_t old_len, size_t new_len, void *arg);
+
+/**
+  Replace all callbacks on an evbuffer with a single new callback, or
+  remove them.
+
+  Subsequent calls to evbuffer_setcb() replace callbacks set by previous
+  calls.  Setting the callback to NULL removes any previously set callback.
+
+  @deprecated This function is deprecated because it clears all previous
+     callbacks set on the evbuffer, which can cause confusing behavior if
+     multiple parts of the code all want to add their own callbacks on a
+     buffer.  Instead, use evbuffer_add(), evbuffer_del(), and
+     evbuffer_setflags() to manage your own evbuffer callbacks without
+     interfering with callbacks set by others.
+
+  @param buffer the evbuffer to be monitored
+  @param cb the callback function to invoke when the evbuffer is modified,
+	 or NULL to remove all callbacks.
+  @param cbarg an argument to be provided to the callback function
+ */
+EVENT2_EXPORT_SYMBOL
+void evbuffer_setcb(struct evbuffer *buffer, evbuffer_cb cb, void *cbarg);
+
+
+/**
+  Find a string within an evbuffer.
+
+  @param buffer the evbuffer to be searched
+  @param what the string to be searched for
+  @param len the length of the search string
+  @return a pointer to the beginning of the search string, or NULL if the search failed.
+ */
+EVENT2_EXPORT_SYMBOL
+unsigned char *evbuffer_find(struct evbuffer *buffer, const unsigned char *what, size_t len);
+
+/** deprecated in favor of calling the functions directly */
+#define EVBUFFER_LENGTH(x)	evbuffer_get_length(x)
+/** deprecated in favor of calling the functions directly */
+#define EVBUFFER_DATA(x)	evbuffer_pullup((x), -1)
+
+#endif
+
Index: dep/libevent/inc/event2/bufferevent.h
===================================================================
--- dep/libevent/inc/event2/bufferevent.h	(revision 49)
+++ dep/libevent/inc/event2/bufferevent.h	(working copy)
@@ -1,821 +1,1021 @@
-/*
- * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
- * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _EVENT2_BUFFEREVENT_H_
-#define _EVENT2_BUFFEREVENT_H_
-
-/**
-   @file event2/bufferevent.h
-
-  Functions for buffering data for network sending or receiving.  Bufferevents
-  are higher level than evbuffers: each has an underlying evbuffer for reading
-  and one for writing, and callbacks that are invoked under certain
-  circumstances.
-
-  A bufferevent provides input and output buffers that get filled and
-  drained automatically.  The user of a bufferevent no longer deals
-  directly with the I/O, but instead is reading from input and writing
-  to output buffers.
-
-  Once initialized, the bufferevent structure can be used repeatedly
-  with bufferevent_enable() and bufferevent_disable().
-
-  When reading is enabled, the bufferevent will try to read from the
-  file descriptor onto its input buffer, and call the read callback.
-  When writing is enabled, the bufferevent will try to write data onto its
-  file descriptor when the output buffer has enough data, and call the write
-  callback when the output buffer is sufficiently drained.
-
-  Bufferevents come in several flavors, including:
-
-  <dl>
-    <dt>Socket-based bufferevents</dt>
-      <dd>A bufferevent that reads and writes data onto a network
-          socket. Created with bufferevent_socket_new().</dd>
-
-    <dt>Paired bufferevents</dt>
-      <dd>A pair of bufferevents that send and receive data to one
-          another without touching the network.  Created with
-          bufferevent_pair_new().</dd>
-
-    <dt>Filtering bufferevents</dt>
-       <dd>A bufferevent that transforms data, and sends or receives it
-          over another underlying bufferevent.  Created with
-          bufferevent_filter_new().</dd>
-
-    <dt>SSL-backed bufferevents</dt>
-      <dd>A bufferevent that uses the openssl library to send and
-          receive data over an encrypted connection. Created with
-	  bufferevent_openssl_socket_new() or
-	  bufferevent_openssl_filter_new().</dd>
-  </dl>
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <event2/event-config.h>
-#ifdef _EVENT_HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-#ifdef _EVENT_HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif
-
-/* For int types. */
-#include <event2/util.h>
-
-/** @name Bufferevent event codes
-
-    These flags are passed as arguments to a bufferevent's event callback.
-
-    @{
-*/
-#define BEV_EVENT_READING	0x01	/**< error encountered while reading */
-#define BEV_EVENT_WRITING	0x02	/**< error encountered while writing */
-#define BEV_EVENT_EOF		0x10	/**< eof file reached */
-#define BEV_EVENT_ERROR		0x20	/**< unrecoverable error encountered */
-#define BEV_EVENT_TIMEOUT	0x40	/**< user-specified timeout reached */
-#define BEV_EVENT_CONNECTED	0x80	/**< connect operation finished. */
-/**@}*/
-
-/**
-   An opaque type for handling buffered IO
-
-   @see event2/bufferevent.h
- */
-struct bufferevent
-#ifdef _EVENT_IN_DOXYGEN
-{}
-#endif
-;
-struct event_base;
-struct evbuffer;
-struct sockaddr;
-
-/**
-   A read or write callback for a bufferevent.
-
-   The read callback is triggered when new data arrives in the input
-   buffer and the amount of readable data exceed the low watermark
-   which is 0 by default.
-
-   The write callback is triggered if the write buffer has been
-   exhausted or fell below its low watermark.
-
-   @param bev the bufferevent that triggered the callback
-   @param ctx the user-specified context for this bufferevent
- */
-typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void *ctx);
-
-/**
-   An event/error callback for a bufferevent.
-
-   The event callback is triggered if either an EOF condition or another
-   unrecoverable error was encountered.
-
-   @param bev the bufferevent for which the error condition was reached
-   @param what a conjunction of flags: BEV_EVENT_READING or BEV_EVENT_WRITING
-	  to indicate if the error was encountered on the read or write path,
-	  and one of the following flags: BEV_EVENT_EOF, BEV_EVENT_ERROR,
-	  BEV_EVENT_TIMEOUT, BEV_EVENT_CONNECTED.
-
-   @param ctx the user-specified context for this bufferevent
-*/
-typedef void (*bufferevent_event_cb)(struct bufferevent *bev, short what, void *ctx);
-
-/** Options that can be specified when creating a bufferevent */
-enum bufferevent_options {
-	/** If set, we close the underlying file
-	 * descriptor/bufferevent/whatever when this bufferevent is freed. */
-	BEV_OPT_CLOSE_ON_FREE = (1<<0),
-
-	/** If set, and threading is enabled, operations on this bufferevent
-	 * are protected by a lock */
-	BEV_OPT_THREADSAFE = (1<<1),
-
-	/** If set, callbacks are run deferred in the event loop. */
-	BEV_OPT_DEFER_CALLBACKS = (1<<2),
-
-	/** If set, callbacks are executed without locks being held on the
-	* bufferevent.  This option currently requires that
-	* BEV_OPT_DEFER_CALLBACKS also be set; a future version of Libevent
-	* might remove the requirement.*/
-	BEV_OPT_UNLOCK_CALLBACKS = (1<<3)
-};
-
-/**
-  Create a new socket bufferevent over an existing socket.
-
-  @param base the event base to associate with the new bufferevent.
-  @param fd the file descriptor from which data is read and written to.
-	    This file descriptor is not allowed to be a pipe(2).
-	    It is safe to set the fd to -1, so long as you later
-	    set it with bufferevent_setfd or bufferevent_socket_connect().
-  @param options Zero or more BEV_OPT_* flags
-  @return a pointer to a newly allocated bufferevent struct, or NULL if an
-	  error occurred
-  @see bufferevent_free()
-  */
-struct bufferevent *bufferevent_socket_new(struct event_base *base, evutil_socket_t fd, int options);
-
-/**
-   Launch a connect() attempt with a socket-based bufferevent.
-
-   When the connect succeeds, the eventcb will be invoked with
-   BEV_EVENT_CONNECTED set.
-
-   If the bufferevent does not already have a socket set, we allocate a new
-   socket here and make it nonblocking before we begin.
-
-   If no address is provided, we assume that the socket is already connecting,
-   and configure the bufferevent so that a BEV_EVENT_CONNECTED event will be
-   yielded when it is done connecting.
-
-   @param bufev an existing bufferevent allocated with
-       bufferevent_socket_new().
-   @param addr the address we should connect to
-   @param socklen The length of the address
-   @return 0 on success, -1 on failure.
- */
-int bufferevent_socket_connect(struct bufferevent *, struct sockaddr *, int);
-
-struct evdns_base;
-/**
-   Resolve the hostname 'hostname' and connect to it as with
-   bufferevent_socket_connect().
-
-   @param bufev An existing bufferevent allocated with bufferevent_socket_new()
-   @param evdns_base Optionally, an evdns_base to use for resolving hostnames
-      asynchronously. May be set to NULL for a blocking resolve.
-   @param family A preferred address family to resolve addresses to, or
-      AF_UNSPEC for no preference.  Only AF_INET, AF_INET6, and AF_UNSPEC are
-      supported.
-   @param hostname The hostname to resolve; see below for notes on recognized
-      formats
-   @param port The port to connect to on the resolved address.
-   @return 0 if successful, -1 on failure.
-
-   Recognized hostname formats are:
-
-       www.example.com	(hostname)
-       1.2.3.4		(ipv4address)
-       ::1		(ipv6address)
-       [::1]		([ipv6address])
-
-   Performance note: If you do not provide an evdns_base, this function
-   may block while it waits for a DNS response.	 This is probably not
-   what you want.
- */
-int bufferevent_socket_connect_hostname(struct bufferevent *,
-    struct evdns_base *, int, const char *, int);
-
-/**
-   Return the error code for the last failed DNS lookup attempt made by
-   bufferevent_socket_connect_hostname().
-
-   @param bev The bufferevent object.
-   @return DNS error code.
-   @see evutil_gai_strerror()
-*/
-int bufferevent_socket_get_dns_error(struct bufferevent *bev);
-
-/**
-  Assign a bufferevent to a specific event_base.
-
-  NOTE that only socket bufferevents support this function.
-
-  @param base an event_base returned by event_init()
-  @param bufev a bufferevent struct returned by bufferevent_new()
-     or bufferevent_socket_new()
-  @return 0 if successful, or -1 if an error occurred
-  @see bufferevent_new()
- */
-int bufferevent_base_set(struct event_base *base, struct bufferevent *bufev);
-
-/**
-   Return the event_base used by a bufferevent
-*/
-struct event_base *bufferevent_get_base(struct bufferevent *bev);
-
-/**
-  Assign a priority to a bufferevent.
-
-  Only supported for socket bufferevents.
-
-  @param bufev a bufferevent struct
-  @param pri the priority to be assigned
-  @return 0 if successful, or -1 if an error occurred
-  */
-int bufferevent_priority_set(struct bufferevent *bufev, int pri);
-
-
-/**
-  Deallocate the storage associated with a bufferevent structure.
-
-  @param bufev the bufferevent structure to be freed.
-  */
-void bufferevent_free(struct bufferevent *bufev);
-
-
-/**
-  Changes the callbacks for a bufferevent.
-
-  @param bufev the bufferevent object for which to change callbacks
-  @param readcb callback to invoke when there is data to be read, or NULL if
-	 no callback is desired
-  @param writecb callback to invoke when the file descriptor is ready for
-	 writing, or NULL if no callback is desired
-  @param eventcb callback to invoke when there is an event on the file
-	 descriptor
-  @param cbarg an argument that will be supplied to each of the callbacks
-	 (readcb, writecb, and errorcb)
-  @see bufferevent_new()
-  */
-void bufferevent_setcb(struct bufferevent *bufev,
-    bufferevent_data_cb readcb, bufferevent_data_cb writecb,
-    bufferevent_event_cb eventcb, void *cbarg);
-
-/**
-  Changes the file descriptor on which the bufferevent operates.
-  Not supported for all bufferevent types.
-
-  @param bufev the bufferevent object for which to change the file descriptor
-  @param fd the file descriptor to operate on
-*/
-int bufferevent_setfd(struct bufferevent *bufev, evutil_socket_t fd);
-
-/**
-   Returns the file descriptor associated with a bufferevent, or -1 if
-   no file descriptor is associated with the bufferevent.
- */
-evutil_socket_t bufferevent_getfd(struct bufferevent *bufev);
-
-/**
-   Returns the underlying bufferevent associated with a bufferevent (if
-   the bufferevent is a wrapper), or NULL if there is no underlying bufferevent.
- */
-struct bufferevent *bufferevent_get_underlying(struct bufferevent *bufev);
-
-/**
-  Write data to a bufferevent buffer.
-
-  The bufferevent_write() function can be used to write data to the file
-  descriptor.  The data is appended to the output buffer and written to the
-  descriptor automatically as it becomes available for writing.
-
-  @param bufev the bufferevent to be written to
-  @param data a pointer to the data to be written
-  @param size the length of the data, in bytes
-  @return 0 if successful, or -1 if an error occurred
-  @see bufferevent_write_buffer()
-  */
-int bufferevent_write(struct bufferevent *bufev,
-    const void *data, size_t size);
-
-
-/**
-  Write data from an evbuffer to a bufferevent buffer.	The evbuffer is
-  being drained as a result.
-
-  @param bufev the bufferevent to be written to
-  @param buf the evbuffer to be written
-  @return 0 if successful, or -1 if an error occurred
-  @see bufferevent_write()
- */
-int bufferevent_write_buffer(struct bufferevent *bufev, struct evbuffer *buf);
-
-
-/**
-  Read data from a bufferevent buffer.
-
-  The bufferevent_read() function is used to read data from the input buffer.
-
-  @param bufev the bufferevent to be read from
-  @param data pointer to a buffer that will store the data
-  @param size the size of the data buffer, in bytes
-  @return the amount of data read, in bytes.
- */
-size_t bufferevent_read(struct bufferevent *bufev, void *data, size_t size);
-
-/**
-  Read data from a bufferevent buffer into an evbuffer.	 This avoids
-  memory copies.
-
-  @param bufev the bufferevent to be read from
-  @param buf the evbuffer to which to add data
-  @return 0 if successful, or -1 if an error occurred.
- */
-int bufferevent_read_buffer(struct bufferevent *bufev, struct evbuffer *buf);
-
-/**
-   Returns the input buffer.
-
-   The user MUST NOT set the callback on this buffer.
-
-   @param bufev the bufferevent from which to get the evbuffer
-   @return the evbuffer object for the input buffer
- */
-
-struct evbuffer *bufferevent_get_input(struct bufferevent *bufev);
-
-/**
-   Returns the output buffer.
-
-   The user MUST NOT set the callback on this buffer.
-
-   When filters are being used, the filters need to be manually
-   triggered if the output buffer was manipulated.
-
-   @param bufev the bufferevent from which to get the evbuffer
-   @return the evbuffer object for the output buffer
- */
-
-struct evbuffer *bufferevent_get_output(struct bufferevent *bufev);
-
-/**
-  Enable a bufferevent.
-
-  @param bufev the bufferevent to be enabled
-  @param event any combination of EV_READ | EV_WRITE.
-  @return 0 if successful, or -1 if an error occurred
-  @see bufferevent_disable()
- */
-int bufferevent_enable(struct bufferevent *bufev, short event);
-
-/**
-  Disable a bufferevent.
-
-  @param bufev the bufferevent to be disabled
-  @param event any combination of EV_READ | EV_WRITE.
-  @return 0 if successful, or -1 if an error occurred
-  @see bufferevent_enable()
- */
-int bufferevent_disable(struct bufferevent *bufev, short event);
-
-/**
-   Return the events that are enabled on a given bufferevent.
-
-   @param bufev the bufferevent to inspect
-   @return A combination of EV_READ | EV_WRITE
- */
-short bufferevent_get_enabled(struct bufferevent *bufev);
-
-/**
-  Set the read and write timeout for a bufferevent.
-
-  A bufferevent's timeout will fire the first time that the indicated
-  amount of time has elapsed since a successful read or write operation,
-  during which the bufferevent was trying to read or write.
-
-  (In other words, if reading or writing is disabled, or if the
-  bufferevent's read or write operation has been suspended because
-  there's no data to write, or not enough banwidth, or so on, the
-  timeout isn't active.  The timeout only becomes active when we we're
-  willing to actually read or write.)
-
-  Calling bufferevent_enable or setting a timeout for a bufferevent
-  whose timeout is already pending resets its timeout.
-
-  If the timeout elapses, the corresponding operation (EV_READ or
-  EV_WRITE) becomes disabled until you re-enable it again.  The
-  bufferevent's event callback is called with the
-  BEV_EVENT_TIMEOUT|BEV_EVENT_READING or
-  BEV_EVENT_TIMEOUT|BEV_EVENT_WRITING.
-
-  @param bufev the bufferevent to be modified
-  @param timeout_read the read timeout, or NULL
-  @param timeout_write the write timeout, or NULL
- */
-int bufferevent_set_timeouts(struct bufferevent *bufev,
-    const struct timeval *timeout_read, const struct timeval *timeout_write);
-
-/**
-  Sets the watermarks for read and write events.
-
-  On input, a bufferevent does not invoke the user read callback unless
-  there is at least low watermark data in the buffer.	If the read buffer
-  is beyond the high watermark, the bufferevent stops reading from the network.
-
-  On output, the user write callback is invoked whenever the buffered data
-  falls below the low watermark.  Filters that write to this bufev will try
-  not to write more bytes to this buffer than the high watermark would allow,
-  except when flushing.
-
-  @param bufev the bufferevent to be modified
-  @param events EV_READ, EV_WRITE or both
-  @param lowmark the lower watermark to set
-  @param highmark the high watermark to set
-*/
-
-void bufferevent_setwatermark(struct bufferevent *bufev, short events,
-    size_t lowmark, size_t highmark);
-
-/**
-   Acquire the lock on a bufferevent.  Has no effect if locking was not
-   enabled with BEV_OPT_THREADSAFE.
- */
-void bufferevent_lock(struct bufferevent *bufev);
-
-/**
-   Release the lock on a bufferevent.  Has no effect if locking was not
-   enabled with BEV_OPT_THREADSAFE.
- */
-void bufferevent_unlock(struct bufferevent *bufev);
-
-/**
-   Flags that can be passed into filters to let them know how to
-   deal with the incoming data.
-*/
-enum bufferevent_flush_mode {
-	/** usually set when processing data */
-	BEV_NORMAL = 0,
-
-	/** want to checkpoint all data sent. */
-	BEV_FLUSH = 1,
-
-	/** encountered EOF on read or done sending data */
-	BEV_FINISHED = 2
-};
-
-/**
-   Triggers the bufferevent to produce more data if possible.
-
-   @param bufev the bufferevent object
-   @param iotype either EV_READ or EV_WRITE or both.
-   @param mode either BEV_NORMAL or BEV_FLUSH or BEV_FINISHED
-   @return -1 on failure, 0 if no data was produces, 1 if data was produced
- */
-int bufferevent_flush(struct bufferevent *bufev,
-    short iotype,
-    enum bufferevent_flush_mode mode);
-
-/**
-   @name Filtering support
-
-   @{
-*/
-/**
-   Values that filters can return.
- */
-enum bufferevent_filter_result {
-	/** everything is okay */
-	BEV_OK = 0,
-
-	/** the filter needs to read more data before output */
-	BEV_NEED_MORE = 1,
-
-	/** the filter encountered a critical error, no further data
-	    can be processed. */
-	BEV_ERROR = 2
-};
-
-/** A callback function to implement a filter for a bufferevent.
-
-    @param src An evbuffer to drain data from.
-    @param dst An evbuffer to add data to.
-    @param limit A suggested upper bound of bytes to write to dst.
-       The filter may ignore this value, but doing so means that
-       it will overflow the high-water mark associated with dst.
-       -1 means "no limit".
-    @param mode Whether we should write data as may be convenient
-       (BEV_NORMAL), or flush as much data as we can (BEV_FLUSH),
-       or flush as much as we can, possibly including an end-of-stream
-       marker (BEV_FINISH).
-    @param ctx A user-supplied pointer.
-
-    @return BEV_OK if we wrote some data; BEV_NEED_MORE if we can't
-       produce any more output until we get some input; and BEV_ERROR
-       on an error.
- */
-typedef enum bufferevent_filter_result (*bufferevent_filter_cb)(
-    struct evbuffer *src, struct evbuffer *dst, ev_ssize_t dst_limit,
-    enum bufferevent_flush_mode mode, void *ctx);
-
-/**
-   Allocate a new filtering bufferevent on top of an existing bufferevent.
-
-   @param underlying the underlying bufferevent.
-   @param input_filter The filter to apply to data we read from the underlying
-     bufferevent
-   @param output_filter The filer to apply to data we write to the underlying
-     bufferevent
-   @param options A bitfield of bufferevent options.
-   @param free_context A function to use to free the filter context when
-     this bufferevent is freed.
-   @param ctx A context pointer to pass to the filter functions.
- */
-struct bufferevent *
-bufferevent_filter_new(struct bufferevent *underlying,
-		       bufferevent_filter_cb input_filter,
-		       bufferevent_filter_cb output_filter,
-		       int options,
-		       void (*free_context)(void *),
-		       void *ctx);
-/**@}*/
-
-/**
-   Allocate a pair of linked bufferevents.  The bufferevents behave as would
-   two bufferevent_sock instances connected to opposite ends of a
-   socketpair(), except that no internal socketpair is allocated.
-
-   @param base The event base to associate with the socketpair.
-   @param options A set of options for this bufferevent
-   @param pair A pointer to an array to hold the two new bufferevent objects.
-   @return 0 on success, -1 on failure.
- */
-int bufferevent_pair_new(struct event_base *base, int options,
-    struct bufferevent *pair[2]);
-
-/**
-   Given one bufferevent returned by bufferevent_pair_new(), returns the
-   other one if it still exists.  Otherwise returns NULL.
- */
-struct bufferevent *bufferevent_pair_get_partner(struct bufferevent *bev);
-
-/**
-   Abstract type used to configure rate-limiting on a bufferevent or a group
-   of bufferevents.
- */
-struct ev_token_bucket_cfg;
-
-/**
-   A group of bufferevents which are configured to respect the same rate
-   limit.
-*/
-struct bufferevent_rate_limit_group;
-
-/** Maximum configurable rate- or burst-limit. */
-#define EV_RATE_LIMIT_MAX EV_SSIZE_MAX
-
-/**
-   Initialize and return a new object to configure the rate-limiting behavior
-   of bufferevents.
-
-   @param read_rate The maximum number of bytes to read per tick on
-     average.
-   @param read_burst The maximum number of bytes to read in any single tick.
-   @param write_rate The maximum number of bytes to write per tick on
-     average.
-   @param write_burst The maximum number of bytes to write in any single tick.
-   @param tick_len The length of a single tick.	 Defaults to one second.
-     Any fractions of a millisecond are ignored.
-
-   Note that all rate-limits hare are currently best-effort: future versions
-   of Libevent may implement them more tightly.
- */
-struct ev_token_bucket_cfg *ev_token_bucket_cfg_new(
-	size_t read_rate, size_t read_burst,
-	size_t write_rate, size_t write_burst,
-	const struct timeval *tick_len);
-
-/** Free all storage held in 'cfg'.
-
-    Note: 'cfg' is not currently reference-counted; it is not safe to free it
-    until no bufferevent is using it.
- */
-void ev_token_bucket_cfg_free(struct ev_token_bucket_cfg *cfg);
-
-/**
-   Set the rate-limit of a the bufferevent 'bev' to the one specified in
-   'cfg'.  If 'cfg' is NULL, disable any per-bufferevent rate-limiting on
-   'bev'.
-
-   Note that only some bufferevent types currently respect rate-limiting.
-   They are: socket-based bufferevents (normal and IOCP-based), and SSL-based
-   bufferevents.
-
-   Return 0 on sucess, -1 on failure.
- */
-int bufferevent_set_rate_limit(struct bufferevent *bev,
-    struct ev_token_bucket_cfg *cfg);
-
-/**
-   Create a new rate-limit group for bufferevents.  A rate-limit group
-   constrains the maximum number of bytes sent and received, in toto,
-   by all of its bufferevents.
-
-   @param base An event_base to run any necessary timeouts for the group.
-      Note that all bufferevents in the group do not necessarily need to share
-      this event_base.
-   @param cfg The rate-limit for this group.
-
-   Note that all rate-limits hare are currently best-effort: future versions
-   of Libevent may implement them more tightly.
-
-   Note also that only some bufferevent types currently respect rate-limiting.
-   They are: socket-based bufferevents (normal and IOCP-based), and SSL-based
-   bufferevents.
- */
-struct bufferevent_rate_limit_group *bufferevent_rate_limit_group_new(
-	struct event_base *base,
-	const struct ev_token_bucket_cfg *cfg);
-/**
-   Change the rate-limiting settings for a given rate-limiting group.
-
-   Return 0 on success, -1 on failure.
-*/
-int bufferevent_rate_limit_group_set_cfg(
-	struct bufferevent_rate_limit_group *,
-	const struct ev_token_bucket_cfg *);
-
-/**
-   Change the smallest quantum we're willing to allocate to any single
-   bufferevent in a group for reading or writing at a time.
-
-   The rationale is that, because of TCP/IP protocol overheads and kernel
-   behavior, if a rate-limiting group is so tight on bandwidth that you're
-   only willing to send 1 byte per tick per bufferevent, you might instead
-   want to batch up the reads and writes so that you send N bytes per
-   1/N of the bufferevents (chosen at random) each tick, so you still wind
-   up send 1 byte per tick per bufferevent on average, but you don't send
-   so many tiny packets.
-
-   The default min-share is currently 64 bytes.
-
-   Returns 0 on success, -1 on faulre.
- */
-int bufferevent_rate_limit_group_set_min_share(
-	struct bufferevent_rate_limit_group *, size_t);
-
-/**
-   Free a rate-limiting group.  The group must have no members when
-   this function is called.
-*/
-void bufferevent_rate_limit_group_free(struct bufferevent_rate_limit_group *);
-
-/**
-   Add 'bev' to the list of bufferevents whose aggregate reading and writing
-   is restricted by 'g'.  If 'g' is NULL, remove 'bev' from its current group.
-
-   A bufferevent may belong to no more than one rate-limit group at a time.
-   If 'bev' is already a member of a group, it will be removed from its old
-   group before being added to 'g'.
-
-   Return 0 on success and -1 on failure.
- */
-int bufferevent_add_to_rate_limit_group(struct bufferevent *bev,
-    struct bufferevent_rate_limit_group *g);
-
-/** Remove 'bev' from its current rate-limit group (if any). */
-int bufferevent_remove_from_rate_limit_group(struct bufferevent *bev);
-
-/**
-   @name Rate limit inspection
-
-   Return the current read or write bucket size for a bufferevent.
-   If it is not configured with a per-bufferevent ratelimit, return
-   EV_SSIZE_MAX.  This function does not inspect the group limit, if any.
-   Note that it can return a negative value if the bufferevent has been
-   made to read or write more than its limit.
-
-   @{
- */
-ev_ssize_t bufferevent_get_read_limit(struct bufferevent *bev);
-ev_ssize_t bufferevent_get_write_limit(struct bufferevent *bev);
-/*@}*/
-
-ev_ssize_t bufferevent_get_max_to_read(struct bufferevent *bev);
-ev_ssize_t bufferevent_get_max_to_write(struct bufferevent *bev);
-
-/**
-   @name Group Rate limit inspection
-
-   Return the read or write bucket size for a bufferevent rate limit
-   group.  Note that it can return a negative value if bufferevents in
-   the group have been made to read or write more than their limits.
-
-   @{
- */
-ev_ssize_t bufferevent_rate_limit_group_get_read_limit(
-	struct bufferevent_rate_limit_group *);
-ev_ssize_t bufferevent_rate_limit_group_get_write_limit(
-	struct bufferevent_rate_limit_group *);
-/*@}*/
-
-/**
-   @name Rate limit manipulation
-
-   Subtract a number of bytes from a bufferevent's read or write bucket.
-   The decrement value can be negative, if you want to manually refill
-   the bucket.	If the change puts the bucket above or below zero, the
-   bufferevent will resume or suspend reading writing as appropriate.
-   These functions make no change in the buckets for the bufferevent's
-   group, if any.
-
-   Returns 0 on success, -1 on internal error.
-
-   @{
- */
-int bufferevent_decrement_read_limit(struct bufferevent *bev, ev_ssize_t decr);
-int bufferevent_decrement_write_limit(struct bufferevent *bev, ev_ssize_t decr);
-/*@}*/
-
-/**
-   @name Group rate limit manipulation
-
-   Subtract a number of bytes from a bufferevent rate-limiting group's
-   read or write bucket.  The decrement value can be negative, if you
-   want to manually refill the bucket.	If the change puts the bucket
-   above or below zero, the bufferevents in the group will resume or
-   suspend reading writing as appropriate.
-
-   Returns 0 on success, -1 on internal error.
-
-   @{
- */
-int bufferevent_rate_limit_group_decrement_read(
-	struct bufferevent_rate_limit_group *, ev_ssize_t);
-int bufferevent_rate_limit_group_decrement_write(
-	struct bufferevent_rate_limit_group *, ev_ssize_t);
-/*@}*/
-
-
-/**
- * Inspect the total bytes read/written on a group.
- *
- * Set the variable pointed to by total_read_out to the total number of bytes
- * ever read on grp, and the variable pointed to by total_written_out to the
- * total number of bytes ever written on grp. */
-void bufferevent_rate_limit_group_get_totals(
-    struct bufferevent_rate_limit_group *grp,
-    ev_uint64_t *total_read_out, ev_uint64_t *total_written_out);
-
-/**
- * Reset the total bytes read/written on a group.
- *
- * Reset the number of bytes read or written on grp as given by
- * bufferevent_rate_limit_group_reset_totals(). */
-void
-bufferevent_rate_limit_group_reset_totals(
-	struct bufferevent_rate_limit_group *grp);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _EVENT2_BUFFEREVENT_H_ */
+/*
+ * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
+ * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EVENT2_BUFFEREVENT_H_INCLUDED_
+#define EVENT2_BUFFEREVENT_H_INCLUDED_
+
+/**
+   @file event2/bufferevent.h
+
+  Functions for buffering data for network sending or receiving.  Bufferevents
+  are higher level than evbuffers: each has an underlying evbuffer for reading
+  and one for writing, and callbacks that are invoked under certain
+  circumstances.
+
+  A bufferevent provides input and output buffers that get filled and
+  drained automatically.  The user of a bufferevent no longer deals
+  directly with the I/O, but instead is reading from input and writing
+  to output buffers.
+
+  Once initialized, the bufferevent structure can be used repeatedly
+  with bufferevent_enable() and bufferevent_disable().
+
+  When reading is enabled, the bufferevent will try to read from the
+  file descriptor onto its input buffer, and call the read callback.
+  When writing is enabled, the bufferevent will try to write data onto its
+  file descriptor when the output buffer has enough data, and call the write
+  callback when the output buffer is sufficiently drained.
+
+  Bufferevents come in several flavors, including:
+
+  <dl>
+    <dt>Socket-based bufferevents</dt>
+      <dd>A bufferevent that reads and writes data onto a network
+          socket. Created with bufferevent_socket_new().</dd>
+
+    <dt>Paired bufferevents</dt>
+      <dd>A pair of bufferevents that send and receive data to one
+          another without touching the network.  Created with
+          bufferevent_pair_new().</dd>
+
+    <dt>Filtering bufferevents</dt>
+       <dd>A bufferevent that transforms data, and sends or receives it
+          over another underlying bufferevent.  Created with
+          bufferevent_filter_new().</dd>
+
+    <dt>SSL-backed bufferevents</dt>
+      <dd>A bufferevent that uses the openssl library to send and
+          receive data over an encrypted connection. Created with
+	  bufferevent_openssl_socket_new() or
+	  bufferevent_openssl_filter_new().</dd>
+  </dl>
+ */
+
+#include <event2/visibility.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <event2/event-config.h>
+#ifdef EVENT__HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef EVENT__HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+
+/* For int types. */
+#include <event2/util.h>
+
+/** @name Bufferevent event codes
+
+    These flags are passed as arguments to a bufferevent's event callback.
+
+    @{
+*/
+#define BEV_EVENT_READING	0x01	/**< error encountered while reading */
+#define BEV_EVENT_WRITING	0x02	/**< error encountered while writing */
+#define BEV_EVENT_EOF		0x10	/**< eof file reached */
+#define BEV_EVENT_ERROR		0x20	/**< unrecoverable error encountered */
+#define BEV_EVENT_TIMEOUT	0x40	/**< user-specified timeout reached */
+#define BEV_EVENT_CONNECTED	0x80	/**< connect operation finished. */
+/**@}*/
+
+/**
+   An opaque type for handling buffered IO
+
+   @see event2/bufferevent.h
+ */
+struct bufferevent
+#ifdef EVENT_IN_DOXYGEN_
+{}
+#endif
+;
+struct event_base;
+struct evbuffer;
+struct sockaddr;
+
+/**
+   A read or write callback for a bufferevent.
+
+   The read callback is triggered when new data arrives in the input
+   buffer and the amount of readable data exceed the low watermark
+   which is 0 by default.
+
+   The write callback is triggered if the write buffer has been
+   exhausted or fell below its low watermark.
+
+   @param bev the bufferevent that triggered the callback
+   @param ctx the user-specified context for this bufferevent
+ */
+typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void *ctx);
+
+/**
+   An event/error callback for a bufferevent.
+
+   The event callback is triggered if either an EOF condition or another
+   unrecoverable error was encountered.
+
+   For bufferevents with deferred callbacks, this is a bitwise OR of all errors
+   that have happened on the bufferevent since the last callback invocation.
+
+   @param bev the bufferevent for which the error condition was reached
+   @param what a conjunction of flags: BEV_EVENT_READING or BEV_EVENT_WRITING
+	  to indicate if the error was encountered on the read or write path,
+	  and one of the following flags: BEV_EVENT_EOF, BEV_EVENT_ERROR,
+	  BEV_EVENT_TIMEOUT, BEV_EVENT_CONNECTED.
+
+   @param ctx the user-specified context for this bufferevent
+*/
+typedef void (*bufferevent_event_cb)(struct bufferevent *bev, short what, void *ctx);
+
+/** Options that can be specified when creating a bufferevent */
+enum bufferevent_options {
+	/** If set, we close the underlying file
+	 * descriptor/bufferevent/whatever when this bufferevent is freed. */
+	BEV_OPT_CLOSE_ON_FREE = (1<<0),
+
+	/** If set, and threading is enabled, operations on this bufferevent
+	 * are protected by a lock */
+	BEV_OPT_THREADSAFE = (1<<1),
+
+	/** If set, callbacks are run deferred in the event loop. */
+	BEV_OPT_DEFER_CALLBACKS = (1<<2),
+
+	/** If set, callbacks are executed without locks being held on the
+	* bufferevent.  This option currently requires that
+	* BEV_OPT_DEFER_CALLBACKS also be set; a future version of Libevent
+	* might remove the requirement.*/
+	BEV_OPT_UNLOCK_CALLBACKS = (1<<3)
+};
+
+/**
+  Create a new socket bufferevent over an existing socket.
+
+  @param base the event base to associate with the new bufferevent.
+  @param fd the file descriptor from which data is read and written to.
+	    This file descriptor is not allowed to be a pipe(2).
+	    It is safe to set the fd to -1, so long as you later
+	    set it with bufferevent_setfd or bufferevent_socket_connect().
+  @param options Zero or more BEV_OPT_* flags
+  @return a pointer to a newly allocated bufferevent struct, or NULL if an
+	  error occurred
+  @see bufferevent_free()
+  */
+EVENT2_EXPORT_SYMBOL
+struct bufferevent *bufferevent_socket_new(struct event_base *base, evutil_socket_t fd, int options);
+
+/**
+   Launch a connect() attempt with a socket-based bufferevent.
+
+   When the connect succeeds, the eventcb will be invoked with
+   BEV_EVENT_CONNECTED set.
+
+   If the bufferevent does not already have a socket set, we allocate a new
+   socket here and make it nonblocking before we begin.
+
+   If no address is provided, we assume that the socket is already connecting,
+   and configure the bufferevent so that a BEV_EVENT_CONNECTED event will be
+   yielded when it is done connecting.
+
+   @param bufev an existing bufferevent allocated with
+       bufferevent_socket_new().
+   @param addr the address we should connect to
+   @param socklen The length of the address
+   @return 0 on success, -1 on failure.
+ */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_socket_connect(struct bufferevent *, const struct sockaddr *, int);
+
+struct evdns_base;
+/**
+   Resolve the hostname 'hostname' and connect to it as with
+   bufferevent_socket_connect().
+
+   @param bufev An existing bufferevent allocated with bufferevent_socket_new()
+   @param evdns_base Optionally, an evdns_base to use for resolving hostnames
+      asynchronously. May be set to NULL for a blocking resolve.
+   @param family A preferred address family to resolve addresses to, or
+      AF_UNSPEC for no preference.  Only AF_INET, AF_INET6, and AF_UNSPEC are
+      supported.
+   @param hostname The hostname to resolve; see below for notes on recognized
+      formats
+   @param port The port to connect to on the resolved address.
+   @return 0 if successful, -1 on failure.
+
+   Recognized hostname formats are:
+
+       www.example.com	(hostname)
+       1.2.3.4		(ipv4address)
+       ::1		(ipv6address)
+       [::1]		([ipv6address])
+
+   Performance note: If you do not provide an evdns_base, this function
+   may block while it waits for a DNS response.	 This is probably not
+   what you want.
+ */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_socket_connect_hostname(struct bufferevent *,
+    struct evdns_base *, int, const char *, int);
+
+/**
+   Return the error code for the last failed DNS lookup attempt made by
+   bufferevent_socket_connect_hostname().
+
+   @param bev The bufferevent object.
+   @return DNS error code.
+   @see evutil_gai_strerror()
+*/
+EVENT2_EXPORT_SYMBOL
+int bufferevent_socket_get_dns_error(struct bufferevent *bev);
+
+/**
+  Assign a bufferevent to a specific event_base.
+
+  NOTE that only socket bufferevents support this function.
+
+  @param base an event_base returned by event_init()
+  @param bufev a bufferevent struct returned by bufferevent_new()
+     or bufferevent_socket_new()
+  @return 0 if successful, or -1 if an error occurred
+  @see bufferevent_new()
+ */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_base_set(struct event_base *base, struct bufferevent *bufev);
+
+/**
+   Return the event_base used by a bufferevent
+*/
+EVENT2_EXPORT_SYMBOL
+struct event_base *bufferevent_get_base(struct bufferevent *bev);
+
+/**
+  Assign a priority to a bufferevent.
+
+  Only supported for socket bufferevents.
+
+  @param bufev a bufferevent struct
+  @param pri the priority to be assigned
+  @return 0 if successful, or -1 if an error occurred
+  */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_priority_set(struct bufferevent *bufev, int pri);
+
+/**
+   Return the priority of a bufferevent.
+
+   Only supported for socket bufferevents
+ */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_get_priority(const struct bufferevent *bufev);
+
+/**
+  Deallocate the storage associated with a bufferevent structure.
+
+  If there is pending data to write on the bufferevent, it probably won't be
+  flushed before the bufferevent is freed.
+
+  @param bufev the bufferevent structure to be freed.
+  */
+EVENT2_EXPORT_SYMBOL
+void bufferevent_free(struct bufferevent *bufev);
+
+
+/**
+  Changes the callbacks for a bufferevent.
+
+  @param bufev the bufferevent object for which to change callbacks
+  @param readcb callback to invoke when there is data to be read, or NULL if
+	 no callback is desired
+  @param writecb callback to invoke when the file descriptor is ready for
+	 writing, or NULL if no callback is desired
+  @param eventcb callback to invoke when there is an event on the file
+	 descriptor
+  @param cbarg an argument that will be supplied to each of the callbacks
+	 (readcb, writecb, and errorcb)
+  @see bufferevent_new()
+  */
+EVENT2_EXPORT_SYMBOL
+void bufferevent_setcb(struct bufferevent *bufev,
+    bufferevent_data_cb readcb, bufferevent_data_cb writecb,
+    bufferevent_event_cb eventcb, void *cbarg);
+
+/**
+ Retrieves the callbacks for a bufferevent.
+
+ @param bufev the bufferevent to examine.
+ @param readcb_ptr if readcb_ptr is nonnull, *readcb_ptr is set to the current
+    read callback for the bufferevent.
+ @param writecb_ptr if writecb_ptr is nonnull, *writecb_ptr is set to the
+    current write callback for the bufferevent.
+ @param eventcb_ptr if eventcb_ptr is nonnull, *eventcb_ptr is set to the
+    current event callback for the bufferevent.
+ @param cbarg_ptr if cbarg_ptr is nonnull, *cbarg_ptr is set to the current
+    callback argument for the bufferevent.
+ @see buffervent_setcb()
+*/
+EVENT2_EXPORT_SYMBOL
+void bufferevent_getcb(struct bufferevent *bufev,
+    bufferevent_data_cb *readcb_ptr,
+    bufferevent_data_cb *writecb_ptr,
+    bufferevent_event_cb *eventcb_ptr,
+    void **cbarg_ptr);
+
+/**
+  Changes the file descriptor on which the bufferevent operates.
+  Not supported for all bufferevent types.
+
+  @param bufev the bufferevent object for which to change the file descriptor
+  @param fd the file descriptor to operate on
+*/
+EVENT2_EXPORT_SYMBOL
+int bufferevent_setfd(struct bufferevent *bufev, evutil_socket_t fd);
+
+/**
+   Returns the file descriptor associated with a bufferevent, or -1 if
+   no file descriptor is associated with the bufferevent.
+ */
+EVENT2_EXPORT_SYMBOL
+evutil_socket_t bufferevent_getfd(struct bufferevent *bufev);
+
+/**
+   Returns the underlying bufferevent associated with a bufferevent (if
+   the bufferevent is a wrapper), or NULL if there is no underlying bufferevent.
+ */
+EVENT2_EXPORT_SYMBOL
+struct bufferevent *bufferevent_get_underlying(struct bufferevent *bufev);
+
+/**
+  Write data to a bufferevent buffer.
+
+  The bufferevent_write() function can be used to write data to the file
+  descriptor.  The data is appended to the output buffer and written to the
+  descriptor automatically as it becomes available for writing.
+
+  @param bufev the bufferevent to be written to
+  @param data a pointer to the data to be written
+  @param size the length of the data, in bytes
+  @return 0 if successful, or -1 if an error occurred
+  @see bufferevent_write_buffer()
+  */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_write(struct bufferevent *bufev,
+    const void *data, size_t size);
+
+
+/**
+  Write data from an evbuffer to a bufferevent buffer.	The evbuffer is
+  being drained as a result.
+
+  @param bufev the bufferevent to be written to
+  @param buf the evbuffer to be written
+  @return 0 if successful, or -1 if an error occurred
+  @see bufferevent_write()
+ */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_write_buffer(struct bufferevent *bufev, struct evbuffer *buf);
+
+
+/**
+  Read data from a bufferevent buffer.
+
+  The bufferevent_read() function is used to read data from the input buffer.
+
+  @param bufev the bufferevent to be read from
+  @param data pointer to a buffer that will store the data
+  @param size the size of the data buffer, in bytes
+  @return the amount of data read, in bytes.
+ */
+EVENT2_EXPORT_SYMBOL
+size_t bufferevent_read(struct bufferevent *bufev, void *data, size_t size);
+
+/**
+  Read data from a bufferevent buffer into an evbuffer.	 This avoids
+  memory copies.
+
+  @param bufev the bufferevent to be read from
+  @param buf the evbuffer to which to add data
+  @return 0 if successful, or -1 if an error occurred.
+ */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_read_buffer(struct bufferevent *bufev, struct evbuffer *buf);
+
+/**
+   Returns the input buffer.
+
+   The user MUST NOT set the callback on this buffer.
+
+   @param bufev the bufferevent from which to get the evbuffer
+   @return the evbuffer object for the input buffer
+ */
+
+EVENT2_EXPORT_SYMBOL
+struct evbuffer *bufferevent_get_input(struct bufferevent *bufev);
+
+/**
+   Returns the output buffer.
+
+   The user MUST NOT set the callback on this buffer.
+
+   When filters are being used, the filters need to be manually
+   triggered if the output buffer was manipulated.
+
+   @param bufev the bufferevent from which to get the evbuffer
+   @return the evbuffer object for the output buffer
+ */
+
+EVENT2_EXPORT_SYMBOL
+struct evbuffer *bufferevent_get_output(struct bufferevent *bufev);
+
+/**
+  Enable a bufferevent.
+
+  @param bufev the bufferevent to be enabled
+  @param event any combination of EV_READ | EV_WRITE.
+  @return 0 if successful, or -1 if an error occurred
+  @see bufferevent_disable()
+ */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_enable(struct bufferevent *bufev, short event);
+
+/**
+  Disable a bufferevent.
+
+  @param bufev the bufferevent to be disabled
+  @param event any combination of EV_READ | EV_WRITE.
+  @return 0 if successful, or -1 if an error occurred
+  @see bufferevent_enable()
+ */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_disable(struct bufferevent *bufev, short event);
+
+/**
+   Return the events that are enabled on a given bufferevent.
+
+   @param bufev the bufferevent to inspect
+   @return A combination of EV_READ | EV_WRITE
+ */
+EVENT2_EXPORT_SYMBOL
+short bufferevent_get_enabled(struct bufferevent *bufev);
+
+/**
+  Set the read and write timeout for a bufferevent.
+
+  A bufferevent's timeout will fire the first time that the indicated
+  amount of time has elapsed since a successful read or write operation,
+  during which the bufferevent was trying to read or write.
+
+  (In other words, if reading or writing is disabled, or if the
+  bufferevent's read or write operation has been suspended because
+  there's no data to write, or not enough banwidth, or so on, the
+  timeout isn't active.  The timeout only becomes active when we we're
+  willing to actually read or write.)
+
+  Calling bufferevent_enable or setting a timeout for a bufferevent
+  whose timeout is already pending resets its timeout.
+
+  If the timeout elapses, the corresponding operation (EV_READ or
+  EV_WRITE) becomes disabled until you re-enable it again.  The
+  bufferevent's event callback is called with the
+  BEV_EVENT_TIMEOUT|BEV_EVENT_READING or
+  BEV_EVENT_TIMEOUT|BEV_EVENT_WRITING.
+
+  @param bufev the bufferevent to be modified
+  @param timeout_read the read timeout, or NULL
+  @param timeout_write the write timeout, or NULL
+ */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_set_timeouts(struct bufferevent *bufev,
+    const struct timeval *timeout_read, const struct timeval *timeout_write);
+
+/**
+  Sets the watermarks for read and write events.
+
+  On input, a bufferevent does not invoke the user read callback unless
+  there is at least low watermark data in the buffer.	If the read buffer
+  is beyond the high watermark, the bufferevent stops reading from the network.
+
+  On output, the user write callback is invoked whenever the buffered data
+  falls below the low watermark.  Filters that write to this bufev will try
+  not to write more bytes to this buffer than the high watermark would allow,
+  except when flushing.
+
+  @param bufev the bufferevent to be modified
+  @param events EV_READ, EV_WRITE or both
+  @param lowmark the lower watermark to set
+  @param highmark the high watermark to set
+*/
+
+EVENT2_EXPORT_SYMBOL
+void bufferevent_setwatermark(struct bufferevent *bufev, short events,
+    size_t lowmark, size_t highmark);
+
+/**
+  Retrieves the watermarks for read or write events.
+  Returns non-zero if events contains not only EV_READ or EV_WRITE.
+  Returns zero if events equal EV_READ or EV_WRITE
+
+  @param bufev the bufferevent to be examined
+  @param events EV_READ or EV_WRITE
+  @param lowmark receives the lower watermark if not NULL
+  @param highmark receives the high watermark if not NULL
+*/
+EVENT2_EXPORT_SYMBOL
+int bufferevent_getwatermark(struct bufferevent *bufev, short events,
+    size_t *lowmark, size_t *highmark);
+
+/**
+   Acquire the lock on a bufferevent.  Has no effect if locking was not
+   enabled with BEV_OPT_THREADSAFE.
+ */
+EVENT2_EXPORT_SYMBOL
+void bufferevent_lock(struct bufferevent *bufev);
+
+/**
+   Release the lock on a bufferevent.  Has no effect if locking was not
+   enabled with BEV_OPT_THREADSAFE.
+ */
+EVENT2_EXPORT_SYMBOL
+void bufferevent_unlock(struct bufferevent *bufev);
+
+
+/**
+ * Public interface to manually increase the reference count of a bufferevent
+ * this is useful in situations where a user may reference the bufferevent
+ * somewhere eles (unknown to libevent)
+ *
+ * @param bufev the bufferevent to increase the refcount on
+ *
+ */
+EVENT2_EXPORT_SYMBOL
+void bufferevent_incref(struct bufferevent *bufev);
+
+/**
+ * Public interface to manually decrement the reference count of a bufferevent
+ *
+ * Warning: make sure you know what you're doing. This is mainly used in
+ * conjunction with bufferevent_incref(). This will free up all data associated
+ * with a bufferevent if the reference count hits 0.
+ *
+ * @param bufev the bufferevent to decrement the refcount on
+ *
+ * @return 1 if the bufferevent was freed, otherwise 0 (still referenced)
+ */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_decref(struct bufferevent *bufev);
+
+/**
+   Flags that can be passed into filters to let them know how to
+   deal with the incoming data.
+*/
+enum bufferevent_flush_mode {
+	/** usually set when processing data */
+	BEV_NORMAL = 0,
+
+	/** want to checkpoint all data sent. */
+	BEV_FLUSH = 1,
+
+	/** encountered EOF on read or done sending data */
+	BEV_FINISHED = 2
+};
+
+/**
+   Triggers the bufferevent to produce more data if possible.
+
+   @param bufev the bufferevent object
+   @param iotype either EV_READ or EV_WRITE or both.
+   @param mode either BEV_NORMAL or BEV_FLUSH or BEV_FINISHED
+   @return -1 on failure, 0 if no data was produces, 1 if data was produced
+ */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_flush(struct bufferevent *bufev,
+    short iotype,
+    enum bufferevent_flush_mode mode);
+
+/**
+   Flags for bufferevent_trigger(_event) that modify when and how to trigger
+   the callback.
+*/
+enum bufferevent_trigger_options {
+	/** trigger the callback regardless of the watermarks */
+	BEV_TRIG_IGNORE_WATERMARKS = (1<<16),
+
+	/** defer even if the callbacks are not */
+	BEV_TRIG_DEFER_CALLBACKS = BEV_OPT_DEFER_CALLBACKS
+
+	/* (Note: for internal reasons, these need to be disjoint from
+	 * bufferevent_options, except when they mean the same thing. */
+};
+
+/**
+   Triggers bufferevent data callbacks.
+
+   The function will honor watermarks unless options contain
+   BEV_TRIG_IGNORE_WATERMARKS. If the options contain BEV_OPT_DEFER_CALLBACKS,
+   the callbacks are deferred.
+
+   @param bufev the bufferevent object
+   @param iotype either EV_READ or EV_WRITE or both.
+   @param options
+ */
+EVENT2_EXPORT_SYMBOL
+void bufferevent_trigger(struct bufferevent *bufev, short iotype,
+    int options);
+
+/**
+   Triggers the bufferevent event callback.
+
+   If the options contain BEV_OPT_DEFER_CALLBACKS, the callbacks are deferred.
+
+   @param bufev the bufferevent object
+   @param what the flags to pass onto the event callback
+   @param options
+ */
+EVENT2_EXPORT_SYMBOL
+void bufferevent_trigger_event(struct bufferevent *bufev, short what,
+    int options);
+
+/**
+   @name Filtering support
+
+   @{
+*/
+/**
+   Values that filters can return.
+ */
+enum bufferevent_filter_result {
+	/** everything is okay */
+	BEV_OK = 0,
+
+	/** the filter needs to read more data before output */
+	BEV_NEED_MORE = 1,
+
+	/** the filter encountered a critical error, no further data
+	    can be processed. */
+	BEV_ERROR = 2
+};
+
+/** A callback function to implement a filter for a bufferevent.
+
+    @param src An evbuffer to drain data from.
+    @param dst An evbuffer to add data to.
+    @param limit A suggested upper bound of bytes to write to dst.
+       The filter may ignore this value, but doing so means that
+       it will overflow the high-water mark associated with dst.
+       -1 means "no limit".
+    @param mode Whether we should write data as may be convenient
+       (BEV_NORMAL), or flush as much data as we can (BEV_FLUSH),
+       or flush as much as we can, possibly including an end-of-stream
+       marker (BEV_FINISH).
+    @param ctx A user-supplied pointer.
+
+    @return BEV_OK if we wrote some data; BEV_NEED_MORE if we can't
+       produce any more output until we get some input; and BEV_ERROR
+       on an error.
+ */
+typedef enum bufferevent_filter_result (*bufferevent_filter_cb)(
+    struct evbuffer *src, struct evbuffer *dst, ev_ssize_t dst_limit,
+    enum bufferevent_flush_mode mode, void *ctx);
+
+/**
+   Allocate a new filtering bufferevent on top of an existing bufferevent.
+
+   @param underlying the underlying bufferevent.
+   @param input_filter The filter to apply to data we read from the underlying
+     bufferevent
+   @param output_filter The filer to apply to data we write to the underlying
+     bufferevent
+   @param options A bitfield of bufferevent options.
+   @param free_context A function to use to free the filter context when
+     this bufferevent is freed.
+   @param ctx A context pointer to pass to the filter functions.
+ */
+EVENT2_EXPORT_SYMBOL
+struct bufferevent *
+bufferevent_filter_new(struct bufferevent *underlying,
+		       bufferevent_filter_cb input_filter,
+		       bufferevent_filter_cb output_filter,
+		       int options,
+		       void (*free_context)(void *),
+		       void *ctx);
+/**@}*/
+
+/**
+   Allocate a pair of linked bufferevents.  The bufferevents behave as would
+   two bufferevent_sock instances connected to opposite ends of a
+   socketpair(), except that no internal socketpair is allocated.
+
+   @param base The event base to associate with the socketpair.
+   @param options A set of options for this bufferevent
+   @param pair A pointer to an array to hold the two new bufferevent objects.
+   @return 0 on success, -1 on failure.
+ */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_pair_new(struct event_base *base, int options,
+    struct bufferevent *pair[2]);
+
+/**
+   Given one bufferevent returned by bufferevent_pair_new(), returns the
+   other one if it still exists.  Otherwise returns NULL.
+ */
+EVENT2_EXPORT_SYMBOL
+struct bufferevent *bufferevent_pair_get_partner(struct bufferevent *bev);
+
+/**
+   Abstract type used to configure rate-limiting on a bufferevent or a group
+   of bufferevents.
+ */
+struct ev_token_bucket_cfg;
+
+/**
+   A group of bufferevents which are configured to respect the same rate
+   limit.
+*/
+struct bufferevent_rate_limit_group;
+
+/** Maximum configurable rate- or burst-limit. */
+#define EV_RATE_LIMIT_MAX EV_SSIZE_MAX
+
+/**
+   Initialize and return a new object to configure the rate-limiting behavior
+   of bufferevents.
+
+   @param read_rate The maximum number of bytes to read per tick on
+     average.
+   @param read_burst The maximum number of bytes to read in any single tick.
+   @param write_rate The maximum number of bytes to write per tick on
+     average.
+   @param write_burst The maximum number of bytes to write in any single tick.
+   @param tick_len The length of a single tick.	 Defaults to one second.
+     Any fractions of a millisecond are ignored.
+
+   Note that all rate-limits hare are currently best-effort: future versions
+   of Libevent may implement them more tightly.
+ */
+EVENT2_EXPORT_SYMBOL
+struct ev_token_bucket_cfg *ev_token_bucket_cfg_new(
+	size_t read_rate, size_t read_burst,
+	size_t write_rate, size_t write_burst,
+	const struct timeval *tick_len);
+
+/** Free all storage held in 'cfg'.
+
+    Note: 'cfg' is not currently reference-counted; it is not safe to free it
+    until no bufferevent is using it.
+ */
+EVENT2_EXPORT_SYMBOL
+void ev_token_bucket_cfg_free(struct ev_token_bucket_cfg *cfg);
+
+/**
+   Set the rate-limit of a the bufferevent 'bev' to the one specified in
+   'cfg'.  If 'cfg' is NULL, disable any per-bufferevent rate-limiting on
+   'bev'.
+
+   Note that only some bufferevent types currently respect rate-limiting.
+   They are: socket-based bufferevents (normal and IOCP-based), and SSL-based
+   bufferevents.
+
+   Return 0 on sucess, -1 on failure.
+ */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_set_rate_limit(struct bufferevent *bev,
+    struct ev_token_bucket_cfg *cfg);
+
+/**
+   Create a new rate-limit group for bufferevents.  A rate-limit group
+   constrains the maximum number of bytes sent and received, in toto,
+   by all of its bufferevents.
+
+   @param base An event_base to run any necessary timeouts for the group.
+      Note that all bufferevents in the group do not necessarily need to share
+      this event_base.
+   @param cfg The rate-limit for this group.
+
+   Note that all rate-limits hare are currently best-effort: future versions
+   of Libevent may implement them more tightly.
+
+   Note also that only some bufferevent types currently respect rate-limiting.
+   They are: socket-based bufferevents (normal and IOCP-based), and SSL-based
+   bufferevents.
+ */
+EVENT2_EXPORT_SYMBOL
+struct bufferevent_rate_limit_group *bufferevent_rate_limit_group_new(
+	struct event_base *base,
+	const struct ev_token_bucket_cfg *cfg);
+/**
+   Change the rate-limiting settings for a given rate-limiting group.
+
+   Return 0 on success, -1 on failure.
+*/
+EVENT2_EXPORT_SYMBOL
+int bufferevent_rate_limit_group_set_cfg(
+	struct bufferevent_rate_limit_group *,
+	const struct ev_token_bucket_cfg *);
+
+/**
+   Change the smallest quantum we're willing to allocate to any single
+   bufferevent in a group for reading or writing at a time.
+
+   The rationale is that, because of TCP/IP protocol overheads and kernel
+   behavior, if a rate-limiting group is so tight on bandwidth that you're
+   only willing to send 1 byte per tick per bufferevent, you might instead
+   want to batch up the reads and writes so that you send N bytes per
+   1/N of the bufferevents (chosen at random) each tick, so you still wind
+   up send 1 byte per tick per bufferevent on average, but you don't send
+   so many tiny packets.
+
+   The default min-share is currently 64 bytes.
+
+   Returns 0 on success, -1 on faulre.
+ */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_rate_limit_group_set_min_share(
+	struct bufferevent_rate_limit_group *, size_t);
+
+/**
+   Free a rate-limiting group.  The group must have no members when
+   this function is called.
+*/
+EVENT2_EXPORT_SYMBOL
+void bufferevent_rate_limit_group_free(struct bufferevent_rate_limit_group *);
+
+/**
+   Add 'bev' to the list of bufferevents whose aggregate reading and writing
+   is restricted by 'g'.  If 'g' is NULL, remove 'bev' from its current group.
+
+   A bufferevent may belong to no more than one rate-limit group at a time.
+   If 'bev' is already a member of a group, it will be removed from its old
+   group before being added to 'g'.
+
+   Return 0 on success and -1 on failure.
+ */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_add_to_rate_limit_group(struct bufferevent *bev,
+    struct bufferevent_rate_limit_group *g);
+
+/** Remove 'bev' from its current rate-limit group (if any). */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_remove_from_rate_limit_group(struct bufferevent *bev);
+
+/**
+   Set the size limit for single read operation.
+
+   Set to 0 for a reasonable default.
+
+   Return 0 on success and -1 on failure.
+ */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_set_max_single_read(struct bufferevent *bev, size_t size);
+
+/**
+   Set the size limit for single write operation.
+
+   Set to 0 for a reasonable default.
+
+   Return 0 on success and -1 on failure.
+ */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_set_max_single_write(struct bufferevent *bev, size_t size);
+
+/** Get the current size limit for single read operation. */
+EVENT2_EXPORT_SYMBOL
+ev_ssize_t bufferevent_get_max_single_read(struct bufferevent *bev);
+
+/** Get the current size limit for single write operation. */
+EVENT2_EXPORT_SYMBOL
+ev_ssize_t bufferevent_get_max_single_write(struct bufferevent *bev);
+
+/**
+   @name Rate limit inspection
+
+   Return the current read or write bucket size for a bufferevent.
+   If it is not configured with a per-bufferevent ratelimit, return
+   EV_SSIZE_MAX.  This function does not inspect the group limit, if any.
+   Note that it can return a negative value if the bufferevent has been
+   made to read or write more than its limit.
+
+   @{
+ */
+EVENT2_EXPORT_SYMBOL
+ev_ssize_t bufferevent_get_read_limit(struct bufferevent *bev);
+EVENT2_EXPORT_SYMBOL
+ev_ssize_t bufferevent_get_write_limit(struct bufferevent *bev);
+/*@}*/
+
+EVENT2_EXPORT_SYMBOL
+ev_ssize_t bufferevent_get_max_to_read(struct bufferevent *bev);
+EVENT2_EXPORT_SYMBOL
+ev_ssize_t bufferevent_get_max_to_write(struct bufferevent *bev);
+
+EVENT2_EXPORT_SYMBOL
+const struct ev_token_bucket_cfg *bufferevent_get_token_bucket_cfg(const struct bufferevent * bev);
+
+/**
+   @name Group Rate limit inspection
+
+   Return the read or write bucket size for a bufferevent rate limit
+   group.  Note that it can return a negative value if bufferevents in
+   the group have been made to read or write more than their limits.
+
+   @{
+ */
+EVENT2_EXPORT_SYMBOL
+ev_ssize_t bufferevent_rate_limit_group_get_read_limit(
+	struct bufferevent_rate_limit_group *);
+EVENT2_EXPORT_SYMBOL
+ev_ssize_t bufferevent_rate_limit_group_get_write_limit(
+	struct bufferevent_rate_limit_group *);
+/*@}*/
+
+/**
+   @name Rate limit manipulation
+
+   Subtract a number of bytes from a bufferevent's read or write bucket.
+   The decrement value can be negative, if you want to manually refill
+   the bucket.	If the change puts the bucket above or below zero, the
+   bufferevent will resume or suspend reading writing as appropriate.
+   These functions make no change in the buckets for the bufferevent's
+   group, if any.
+
+   Returns 0 on success, -1 on internal error.
+
+   @{
+ */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_decrement_read_limit(struct bufferevent *bev, ev_ssize_t decr);
+EVENT2_EXPORT_SYMBOL
+int bufferevent_decrement_write_limit(struct bufferevent *bev, ev_ssize_t decr);
+/*@}*/
+
+/**
+   @name Group rate limit manipulation
+
+   Subtract a number of bytes from a bufferevent rate-limiting group's
+   read or write bucket.  The decrement value can be negative, if you
+   want to manually refill the bucket.	If the change puts the bucket
+   above or below zero, the bufferevents in the group will resume or
+   suspend reading writing as appropriate.
+
+   Returns 0 on success, -1 on internal error.
+
+   @{
+ */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_rate_limit_group_decrement_read(
+	struct bufferevent_rate_limit_group *, ev_ssize_t);
+EVENT2_EXPORT_SYMBOL
+int bufferevent_rate_limit_group_decrement_write(
+	struct bufferevent_rate_limit_group *, ev_ssize_t);
+/*@}*/
+
+
+/**
+ * Inspect the total bytes read/written on a group.
+ *
+ * Set the variable pointed to by total_read_out to the total number of bytes
+ * ever read on grp, and the variable pointed to by total_written_out to the
+ * total number of bytes ever written on grp. */
+EVENT2_EXPORT_SYMBOL
+void bufferevent_rate_limit_group_get_totals(
+    struct bufferevent_rate_limit_group *grp,
+    ev_uint64_t *total_read_out, ev_uint64_t *total_written_out);
+
+/**
+ * Reset the total bytes read/written on a group.
+ *
+ * Reset the number of bytes read or written on grp as given by
+ * bufferevent_rate_limit_group_reset_totals(). */
+EVENT2_EXPORT_SYMBOL
+void
+bufferevent_rate_limit_group_reset_totals(
+	struct bufferevent_rate_limit_group *grp);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EVENT2_BUFFEREVENT_H_INCLUDED_ */
Index: dep/libevent/inc/event2/bufferevent_compat.h
===================================================================
--- dep/libevent/inc/event2/bufferevent_compat.h	(revision 49)
+++ dep/libevent/inc/event2/bufferevent_compat.h	(working copy)
@@ -1,100 +1,100 @@
-/*
- * Copyright (c) 2007-2012 Niels Provos, Nick Mathewson
- * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _EVENT2_BUFFEREVENT_COMPAT_H_
-#define _EVENT2_BUFFEREVENT_COMPAT_H_
-
-#define evbuffercb bufferevent_data_cb
-#define everrorcb bufferevent_event_cb
-
-/**
-  Create a new bufferevent for an fd.
-
-  This function is deprecated.  Use bufferevent_socket_new and
-  bufferevent_set_callbacks instead.
-
-  Libevent provides an abstraction on top of the regular event callbacks.
-  This abstraction is called a buffered event.  A buffered event provides
-  input and output buffers that get filled and drained automatically.  The
-  user of a buffered event no longer deals directly with the I/O, but
-  instead is reading from input and writing to output buffers.
-
-  Once initialized, the bufferevent structure can be used repeatedly with
-  bufferevent_enable() and bufferevent_disable().
-
-  When read enabled the bufferevent will try to read from the file descriptor
-  and call the read callback.  The write callback is executed whenever the
-  output buffer is drained below the write low watermark, which is 0 by
-  default.
-
-  If multiple bases are in use, bufferevent_base_set() must be called before
-  enabling the bufferevent for the first time.
-
-  @deprecated This function is deprecated because it uses the current
-    event base, and as such can be error prone for multithreaded programs.
-    Use bufferevent_socket_new() instead.
-
-  @param fd the file descriptor from which data is read and written to.
-	 This file descriptor is not allowed to be a pipe(2).
-  @param readcb callback to invoke when there is data to be read, or NULL if
-	 no callback is desired
-  @param writecb callback to invoke when the file descriptor is ready for
-	 writing, or NULL if no callback is desired
-  @param errorcb callback to invoke when there is an error on the file
-	 descriptor
-  @param cbarg an argument that will be supplied to each of the callbacks
-	 (readcb, writecb, and errorcb)
-  @return a pointer to a newly allocated bufferevent struct, or NULL if an
-	  error occurred
-  @see bufferevent_base_set(), bufferevent_free()
-  */
-struct bufferevent *bufferevent_new(evutil_socket_t fd,
-    evbuffercb readcb, evbuffercb writecb, everrorcb errorcb, void *cbarg);
-
-
-/**
-  Set the read and write timeout for a buffered event.
-
-  @param bufev the bufferevent to be modified
-  @param timeout_read the read timeout
-  @param timeout_write the write timeout
- */
-void bufferevent_settimeout(struct bufferevent *bufev,
-    int timeout_read, int timeout_write);
-
-#define EVBUFFER_READ		BEV_EVENT_READING
-#define EVBUFFER_WRITE		BEV_EVENT_WRITING
-#define EVBUFFER_EOF		BEV_EVENT_EOF
-#define EVBUFFER_ERROR		BEV_EVENT_ERROR
-#define EVBUFFER_TIMEOUT	BEV_EVENT_TIMEOUT
-
-/** macro for getting access to the input buffer of a bufferevent */
-#define EVBUFFER_INPUT(x)	bufferevent_get_input(x)
-/** macro for getting access to the output buffer of a bufferevent */
-#define EVBUFFER_OUTPUT(x)	bufferevent_get_output(x)
-
-#endif
+/*
+ * Copyright (c) 2007-2012 Niels Provos, Nick Mathewson
+ * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EVENT2_BUFFEREVENT_COMPAT_H_INCLUDED_
+#define EVENT2_BUFFEREVENT_COMPAT_H_INCLUDED_
+
+#define evbuffercb bufferevent_data_cb
+#define everrorcb bufferevent_event_cb
+
+/**
+  Create a new bufferevent for an fd.
+
+  This function is deprecated.  Use bufferevent_socket_new and
+  bufferevent_set_callbacks instead.
+
+  Libevent provides an abstraction on top of the regular event callbacks.
+  This abstraction is called a buffered event.  A buffered event provides
+  input and output buffers that get filled and drained automatically.  The
+  user of a buffered event no longer deals directly with the I/O, but
+  instead is reading from input and writing to output buffers.
+
+  Once initialized, the bufferevent structure can be used repeatedly with
+  bufferevent_enable() and bufferevent_disable().
+
+  When read enabled the bufferevent will try to read from the file descriptor
+  and call the read callback.  The write callback is executed whenever the
+  output buffer is drained below the write low watermark, which is 0 by
+  default.
+
+  If multiple bases are in use, bufferevent_base_set() must be called before
+  enabling the bufferevent for the first time.
+
+  @deprecated This function is deprecated because it uses the current
+    event base, and as such can be error prone for multithreaded programs.
+    Use bufferevent_socket_new() instead.
+
+  @param fd the file descriptor from which data is read and written to.
+	 This file descriptor is not allowed to be a pipe(2).
+  @param readcb callback to invoke when there is data to be read, or NULL if
+	 no callback is desired
+  @param writecb callback to invoke when the file descriptor is ready for
+	 writing, or NULL if no callback is desired
+  @param errorcb callback to invoke when there is an error on the file
+	 descriptor
+  @param cbarg an argument that will be supplied to each of the callbacks
+	 (readcb, writecb, and errorcb)
+  @return a pointer to a newly allocated bufferevent struct, or NULL if an
+	  error occurred
+  @see bufferevent_base_set(), bufferevent_free()
+  */
+struct bufferevent *bufferevent_new(evutil_socket_t fd,
+    evbuffercb readcb, evbuffercb writecb, everrorcb errorcb, void *cbarg);
+
+
+/**
+  Set the read and write timeout for a buffered event.
+
+  @param bufev the bufferevent to be modified
+  @param timeout_read the read timeout
+  @param timeout_write the write timeout
+ */
+void bufferevent_settimeout(struct bufferevent *bufev,
+    int timeout_read, int timeout_write);
+
+#define EVBUFFER_READ		BEV_EVENT_READING
+#define EVBUFFER_WRITE		BEV_EVENT_WRITING
+#define EVBUFFER_EOF		BEV_EVENT_EOF
+#define EVBUFFER_ERROR		BEV_EVENT_ERROR
+#define EVBUFFER_TIMEOUT	BEV_EVENT_TIMEOUT
+
+/** macro for getting access to the input buffer of a bufferevent */
+#define EVBUFFER_INPUT(x)	bufferevent_get_input(x)
+/** macro for getting access to the output buffer of a bufferevent */
+#define EVBUFFER_OUTPUT(x)	bufferevent_get_output(x)
+
+#endif
Index: dep/libevent/inc/event2/bufferevent_ssl.h
===================================================================
--- dep/libevent/inc/event2/bufferevent_ssl.h	(revision 49)
+++ dep/libevent/inc/event2/bufferevent_ssl.h	(working copy)
@@ -1,107 +1,134 @@
-/*
- * Copyright (c) 2009-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _EVENT2_BUFFEREVENT_SSL_H_
-#define _EVENT2_BUFFEREVENT_SSL_H_
-
-/** @file event2/bufferevent_ssl.h
-
-    OpenSSL support for bufferevents.
- */
-
-#include <event2/event-config.h>
-#include <event2/bufferevent.h>
-#include <event2/util.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* This is what openssl's SSL objects are underneath. */
-struct ssl_st;
-
-/**
-   The state of an SSL object to be used when creating a new
-   SSL bufferevent.
- */
-enum bufferevent_ssl_state {
-	BUFFEREVENT_SSL_OPEN = 0,
-	BUFFEREVENT_SSL_CONNECTING = 1,
-	BUFFEREVENT_SSL_ACCEPTING = 2
-};
-
-#if defined(_EVENT_HAVE_OPENSSL) || defined(_EVENT_IN_DOXYGEN)
-/**
-   Create a new SSL bufferevent to send its data over another bufferevent.
-
-   @param base An event_base to use to detect reading and writing.  It
-      must also be the base for the underlying bufferevent.
-   @param underlying A socket to use for this SSL
-   @param ssl A SSL* object from openssl.
-   @param state The current state of the SSL connection
-   @param options One or more bufferevent_options
-   @return A new bufferevent on success, or NULL on failure
-*/
-struct bufferevent *
-bufferevent_openssl_filter_new(struct event_base *base,
-    struct bufferevent *underlying,
-    struct ssl_st *ssl,
-    enum bufferevent_ssl_state state,
-    int options);
-
-/**
-   Create a new SSL bufferevent to send its data over an SSL * on a socket.
-
-   @param base An event_base to use to detect reading and writing
-   @param fd A socket to use for this SSL
-   @param ssl A SSL* object from openssl.
-   @param state The current state of the SSL connection
-   @param options One or more bufferevent_options
-   @return A new bufferevent on success, or NULL on failure.
-*/
-struct bufferevent *
-bufferevent_openssl_socket_new(struct event_base *base,
-    evutil_socket_t fd,
-    struct ssl_st *ssl,
-    enum bufferevent_ssl_state state,
-    int options);
-
-/** Return the underlying openssl SSL * object for an SSL bufferevent. */
-struct ssl_st *
-bufferevent_openssl_get_ssl(struct bufferevent *bufev);
-
-/** Tells a bufferevent to begin SSL renegotiation. */
-int bufferevent_ssl_renegotiate(struct bufferevent *bev);
-
-/** Return the most recent OpenSSL error reported on an SSL bufferevent. */
-unsigned long bufferevent_get_openssl_error(struct bufferevent *bev);
-
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _EVENT2_BUFFEREVENT_SSL_H_ */
+/*
+ * Copyright (c) 2009-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EVENT2_BUFFEREVENT_SSL_H_INCLUDED_
+#define EVENT2_BUFFEREVENT_SSL_H_INCLUDED_
+
+/** @file event2/bufferevent_ssl.h
+
+    OpenSSL support for bufferevents.
+ */
+#include <event2/visibility.h>
+#include <event2/event-config.h>
+#include <event2/bufferevent.h>
+#include <event2/util.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* This is what openssl's SSL objects are underneath. */
+struct ssl_st;
+
+/**
+   The state of an SSL object to be used when creating a new
+   SSL bufferevent.
+ */
+enum bufferevent_ssl_state {
+	BUFFEREVENT_SSL_OPEN = 0,
+	BUFFEREVENT_SSL_CONNECTING = 1,
+	BUFFEREVENT_SSL_ACCEPTING = 2
+};
+
+#if defined(EVENT__HAVE_OPENSSL) || defined(EVENT_IN_DOXYGEN_)
+/**
+   Create a new SSL bufferevent to send its data over another bufferevent.
+
+   @param base An event_base to use to detect reading and writing.  It
+      must also be the base for the underlying bufferevent.
+   @param underlying A socket to use for this SSL
+   @param ssl A SSL* object from openssl.
+   @param state The current state of the SSL connection
+   @param options One or more bufferevent_options
+   @return A new bufferevent on success, or NULL on failure
+*/
+EVENT2_EXPORT_SYMBOL
+struct bufferevent *
+bufferevent_openssl_filter_new(struct event_base *base,
+    struct bufferevent *underlying,
+    struct ssl_st *ssl,
+    enum bufferevent_ssl_state state,
+    int options);
+
+/**
+   Create a new SSL bufferevent to send its data over an SSL * on a socket.
+
+   @param base An event_base to use to detect reading and writing
+   @param fd A socket to use for this SSL
+   @param ssl A SSL* object from openssl.
+   @param state The current state of the SSL connection
+   @param options One or more bufferevent_options
+   @return A new bufferevent on success, or NULL on failure.
+*/
+EVENT2_EXPORT_SYMBOL
+struct bufferevent *
+bufferevent_openssl_socket_new(struct event_base *base,
+    evutil_socket_t fd,
+    struct ssl_st *ssl,
+    enum bufferevent_ssl_state state,
+    int options);
+
+/** Control how to report dirty SSL shutdowns.
+
+    If the peer (or the network, or an attacker) closes the TCP
+    connection before closing the SSL channel, and the protocol is SSL >= v3,
+    this is a "dirty" shutdown.  If allow_dirty_shutdown is 0 (default),
+    this is reported as BEV_EVENT_ERROR.
+
+    If instead allow_dirty_shutdown=1, a dirty shutdown is reported as
+    BEV_EVENT_EOF.
+
+    (Note that if the protocol is < SSLv3, you will always receive
+    BEV_EVENT_EOF, since SSL 2 and earlier cannot distinguish a secure
+    connection close from a dirty one.  This is one reason (among many)
+    not to use SSL 2.)
+*/
+
+EVENT2_EXPORT_SYMBOL
+int bufferevent_openssl_get_allow_dirty_shutdown(struct bufferevent *bev);
+EVENT2_EXPORT_SYMBOL
+void bufferevent_openssl_set_allow_dirty_shutdown(struct bufferevent *bev,
+    int allow_dirty_shutdown);
+
+/** Return the underlying openssl SSL * object for an SSL bufferevent. */
+EVENT2_EXPORT_SYMBOL
+struct ssl_st *
+bufferevent_openssl_get_ssl(struct bufferevent *bufev);
+
+/** Tells a bufferevent to begin SSL renegotiation. */
+EVENT2_EXPORT_SYMBOL
+int bufferevent_ssl_renegotiate(struct bufferevent *bev);
+
+/** Return the most recent OpenSSL error reported on an SSL bufferevent. */
+EVENT2_EXPORT_SYMBOL
+unsigned long bufferevent_get_openssl_error(struct bufferevent *bev);
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EVENT2_BUFFEREVENT_SSL_H_INCLUDED_ */
Index: dep/libevent/inc/event2/bufferevent_struct.h
===================================================================
--- dep/libevent/inc/event2/bufferevent_struct.h	(revision 49)
+++ dep/libevent/inc/event2/bufferevent_struct.h	(working copy)
@@ -1,116 +1,116 @@
-/*
- * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
- * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _EVENT2_BUFFEREVENT_STRUCT_H_
-#define _EVENT2_BUFFEREVENT_STRUCT_H_
-
-/** @file event2/bufferevent_struct.h
-
-  Data structures for bufferevents.  Using these structures may hurt forward
-  compatibility with later versions of Libevent: be careful!
-
-  @deprecated Use of bufferevent_struct.h is completely deprecated; these
-    structures are only exposed for backward compatibility with programs
-    written before Libevent 2.0 that used them.
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <event2/event-config.h>
-#ifdef _EVENT_HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-#ifdef _EVENT_HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif
-
-/* For int types. */
-#include <event2/util.h>
-/* For struct event */
-#include <event2/event_struct.h>
-
-struct event_watermark {
-	size_t low;
-	size_t high;
-};
-
-/**
-  Shared implementation of a bufferevent.
-
-  This type is exposed only because it was exposed in previous versions,
-  and some people's code may rely on manipulating it.  Otherwise, you
-  should really not rely on the layout, size, or contents of this structure:
-  it is fairly volatile, and WILL change in future versions of the code.
-**/
-struct bufferevent {
-	/** Event base for which this bufferevent was created. */
-	struct event_base *ev_base;
-	/** Pointer to a table of function pointers to set up how this
-	    bufferevent behaves. */
-	const struct bufferevent_ops *be_ops;
-
-	/** A read event that triggers when a timeout has happened or a socket
-	    is ready to read data.  Only used by some subtypes of
-	    bufferevent. */
-	struct event ev_read;
-	/** A write event that triggers when a timeout has happened or a socket
-	    is ready to write data.  Only used by some subtypes of
-	    bufferevent. */
-	struct event ev_write;
-
-	/** An input buffer. Only the bufferevent is allowed to add data to
-	    this buffer, though the user is allowed to drain it. */
-	struct evbuffer *input;
-
-	/** An input buffer. Only the bufferevent is allowed to drain data
-	    from this buffer, though the user is allowed to add it. */
-	struct evbuffer *output;
-
-	struct event_watermark wm_read;
-	struct event_watermark wm_write;
-
-	bufferevent_data_cb readcb;
-	bufferevent_data_cb writecb;
-	/* This should be called 'eventcb', but renaming it would break
-	 * backward compatibility */
-	bufferevent_event_cb errorcb;
-	void *cbarg;
-
-	struct timeval timeout_read;
-	struct timeval timeout_write;
-
-	/** Events that are currently enabled: currently EV_READ and EV_WRITE
-	    are supported. */
-	short enabled;
-};
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _EVENT2_BUFFEREVENT_STRUCT_H_ */
+/*
+ * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
+ * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EVENT2_BUFFEREVENT_STRUCT_H_INCLUDED_
+#define EVENT2_BUFFEREVENT_STRUCT_H_INCLUDED_
+
+/** @file event2/bufferevent_struct.h
+
+  Data structures for bufferevents.  Using these structures may hurt forward
+  compatibility with later versions of Libevent: be careful!
+
+  @deprecated Use of bufferevent_struct.h is completely deprecated; these
+    structures are only exposed for backward compatibility with programs
+    written before Libevent 2.0 that used them.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <event2/event-config.h>
+#ifdef EVENT__HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef EVENT__HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+
+/* For int types. */
+#include <event2/util.h>
+/* For struct event */
+#include <event2/event_struct.h>
+
+struct event_watermark {
+	size_t low;
+	size_t high;
+};
+
+/**
+  Shared implementation of a bufferevent.
+
+  This type is exposed only because it was exposed in previous versions,
+  and some people's code may rely on manipulating it.  Otherwise, you
+  should really not rely on the layout, size, or contents of this structure:
+  it is fairly volatile, and WILL change in future versions of the code.
+**/
+struct bufferevent {
+	/** Event base for which this bufferevent was created. */
+	struct event_base *ev_base;
+	/** Pointer to a table of function pointers to set up how this
+	    bufferevent behaves. */
+	const struct bufferevent_ops *be_ops;
+
+	/** A read event that triggers when a timeout has happened or a socket
+	    is ready to read data.  Only used by some subtypes of
+	    bufferevent. */
+	struct event ev_read;
+	/** A write event that triggers when a timeout has happened or a socket
+	    is ready to write data.  Only used by some subtypes of
+	    bufferevent. */
+	struct event ev_write;
+
+	/** An input buffer. Only the bufferevent is allowed to add data to
+	    this buffer, though the user is allowed to drain it. */
+	struct evbuffer *input;
+
+	/** An input buffer. Only the bufferevent is allowed to drain data
+	    from this buffer, though the user is allowed to add it. */
+	struct evbuffer *output;
+
+	struct event_watermark wm_read;
+	struct event_watermark wm_write;
+
+	bufferevent_data_cb readcb;
+	bufferevent_data_cb writecb;
+	/* This should be called 'eventcb', but renaming it would break
+	 * backward compatibility */
+	bufferevent_event_cb errorcb;
+	void *cbarg;
+
+	struct timeval timeout_read;
+	struct timeval timeout_write;
+
+	/** Events that are currently enabled: currently EV_READ and EV_WRITE
+	    are supported. */
+	short enabled;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EVENT2_BUFFEREVENT_STRUCT_H_INCLUDED_ */
Index: dep/libevent/inc/event2/dns.h
===================================================================
--- dep/libevent/inc/event2/dns.h	(revision 49)
+++ dep/libevent/inc/event2/dns.h	(working copy)
@@ -1,643 +1,717 @@
-/*
- * Copyright (c) 2006-2007 Niels Provos <provos@citi.umich.edu>
- * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * The original DNS code is due to Adam Langley with heavy
- * modifications by Nick Mathewson.  Adam put his DNS software in the
- * public domain.  You can find his original copyright below.  Please,
- * aware that the code as part of Libevent is governed by the 3-clause
- * BSD license above.
- *
- * This software is Public Domain. To view a copy of the public domain dedication,
- * visit http://creativecommons.org/licenses/publicdomain/ or send a letter to
- * Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.
- *
- * I ask and expect, but do not require, that all derivative works contain an
- * attribution similar to:
- *     Parts developed by Adam Langley <agl@imperialviolet.org>
- *
- * You may wish to replace the word "Parts" with something else depending on
- * the amount of original code.
- *
- * (Derivative works does not include programs which link against, run or include
- * the source verbatim in their source distributions)
- */
-
-/** @file event2/dns.h
- *
- * Welcome, gentle reader
- *
- * Async DNS lookups are really a whole lot harder than they should be,
- * mostly stemming from the fact that the libc resolver has never been
- * very good at them. Before you use this library you should see if libc
- * can do the job for you with the modern async call getaddrinfo_a
- * (see http://www.imperialviolet.org/page25.html#e498). Otherwise,
- * please continue.
- *
- * The library keeps track of the state of nameservers and will avoid
- * them when they go down. Otherwise it will round robin between them.
- *
- * Quick start guide:
- *   #include "evdns.h"
- *   void callback(int result, char type, int count, int ttl,
- *		 void *addresses, void *arg);
- *   evdns_resolv_conf_parse(DNS_OPTIONS_ALL, "/etc/resolv.conf");
- *   evdns_resolve("www.hostname.com", 0, callback, NULL);
- *
- * When the lookup is complete the callback function is called. The
- * first argument will be one of the DNS_ERR_* defines in evdns.h.
- * Hopefully it will be DNS_ERR_NONE, in which case type will be
- * DNS_IPv4_A, count will be the number of IP addresses, ttl is the time
- * which the data can be cached for (in seconds), addresses will point
- * to an array of uint32_t's and arg will be whatever you passed to
- * evdns_resolve.
- *
- * Searching:
- *
- * In order for this library to be a good replacement for glibc's resolver it
- * supports searching. This involves setting a list of default domains, in
- * which names will be queried for. The number of dots in the query name
- * determines the order in which this list is used.
- *
- * Searching appears to be a single lookup from the point of view of the API,
- * although many DNS queries may be generated from a single call to
- * evdns_resolve. Searching can also drastically slow down the resolution
- * of names.
- *
- * To disable searching:
- *   1. Never set it up. If you never call evdns_resolv_conf_parse or
- *   evdns_search_add then no searching will occur.
- *
- *   2. If you do call evdns_resolv_conf_parse then don't pass
- *   DNS_OPTION_SEARCH (or DNS_OPTIONS_ALL, which implies it).
- *
- *   3. When calling evdns_resolve, pass the DNS_QUERY_NO_SEARCH flag.
- *
- * The order of searches depends on the number of dots in the name. If the
- * number is greater than the ndots setting then the names is first tried
- * globally. Otherwise each search domain is appended in turn.
- *
- * The ndots setting can either be set from a resolv.conf, or by calling
- * evdns_search_ndots_set.
- *
- * For example, with ndots set to 1 (the default) and a search domain list of
- * ["myhome.net"]:
- *  Query: www
- *  Order: www.myhome.net, www.
- *
- *  Query: www.abc
- *  Order: www.abc., www.abc.myhome.net
- *
- * Internals:
- *
- * Requests are kept in two queues. The first is the inflight queue. In
- * this queue requests have an allocated transaction id and nameserver.
- * They will soon be transmitted if they haven't already been.
- *
- * The second is the waiting queue. The size of the inflight ring is
- * limited and all other requests wait in waiting queue for space. This
- * bounds the number of concurrent requests so that we don't flood the
- * nameserver. Several algorithms require a full walk of the inflight
- * queue and so bounding its size keeps thing going nicely under huge
- * (many thousands of requests) loads.
- *
- * If a nameserver loses too many requests it is considered down and we
- * try not to use it. After a while we send a probe to that nameserver
- * (a lookup for google.com) and, if it replies, we consider it working
- * again. If the nameserver fails a probe we wait longer to try again
- * with the next probe.
- */
-
-#ifndef _EVENT2_DNS_H_
-#define _EVENT2_DNS_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* For integer types. */
-#include <event2/util.h>
-
-/** Error codes 0-5 are as described in RFC 1035. */
-#define DNS_ERR_NONE 0
-/** The name server was unable to interpret the query */
-#define DNS_ERR_FORMAT 1
-/** The name server was unable to process this query due to a problem with the
- * name server */
-#define DNS_ERR_SERVERFAILED 2
-/** The domain name does not exist */
-#define DNS_ERR_NOTEXIST 3
-/** The name server does not support the requested kind of query */
-#define DNS_ERR_NOTIMPL 4
-/** The name server refuses to reform the specified operation for policy
- * reasons */
-#define DNS_ERR_REFUSED 5
-/** The reply was truncated or ill-formatted */
-#define DNS_ERR_TRUNCATED 65
-/** An unknown error occurred */
-#define DNS_ERR_UNKNOWN 66
-/** Communication with the server timed out */
-#define DNS_ERR_TIMEOUT 67
-/** The request was canceled because the DNS subsystem was shut down. */
-#define DNS_ERR_SHUTDOWN 68
-/** The request was canceled via a call to evdns_cancel_request */
-#define DNS_ERR_CANCEL 69
-/** There were no answers and no error condition in the DNS packet.
- * This can happen when you ask for an address that exists, but a record
- * type that doesn't. */
-#define DNS_ERR_NODATA 70
-
-#define DNS_IPv4_A 1
-#define DNS_PTR 2
-#define DNS_IPv6_AAAA 3
-
-#define DNS_QUERY_NO_SEARCH 1
-
-#define DNS_OPTION_SEARCH 1
-#define DNS_OPTION_NAMESERVERS 2
-#define DNS_OPTION_MISC 4
-#define DNS_OPTION_HOSTSFILE 8
-#define DNS_OPTIONS_ALL 15
-
-/* Obsolete name for DNS_QUERY_NO_SEARCH */
-#define DNS_NO_SEARCH DNS_QUERY_NO_SEARCH
-
-/**
- * The callback that contains the results from a lookup.
- * - result is one of the DNS_ERR_* values (DNS_ERR_NONE for success)
- * - type is either DNS_IPv4_A or DNS_PTR or DNS_IPv6_AAAA
- * - count contains the number of addresses of form type
- * - ttl is the number of seconds the resolution may be cached for.
- * - addresses needs to be cast according to type.  It will be an array of
- *   4-byte sequences for ipv4, or an array of 16-byte sequences for ipv6,
- *   or a nul-terminated string for PTR.
- */
-typedef void (*evdns_callback_type) (int result, char type, int count, int ttl, void *addresses, void *arg);
-
-struct evdns_base;
-struct event_base;
-
-/**
-  Initialize the asynchronous DNS library.
-
-  This function initializes support for non-blocking name resolution by
-  calling evdns_resolv_conf_parse() on UNIX and
-  evdns_config_windows_nameservers() on Windows.
-
-  @param event_base the event base to associate the dns client with
-  @param initialize_nameservers 1 if resolve.conf processing should occur
-  @return evdns_base object if successful, or NULL if an error occurred.
-  @see evdns_base_free()
- */
-struct evdns_base * evdns_base_new(struct event_base *event_base, int initialize_nameservers);
-
-
-/**
-  Shut down the asynchronous DNS resolver and terminate all active requests.
-
-  If the 'fail_requests' option is enabled, all active requests will return
-  an empty result with the error flag set to DNS_ERR_SHUTDOWN. Otherwise,
-  the requests will be silently discarded.
-
-  @param evdns_base the evdns base to free
-  @param fail_requests if zero, active requests will be aborted; if non-zero,
-		active requests will return DNS_ERR_SHUTDOWN.
-  @see evdns_base_new()
- */
-void evdns_base_free(struct evdns_base *base, int fail_requests);
-
-/**
-  Convert a DNS error code to a string.
-
-  @param err the DNS error code
-  @return a string containing an explanation of the error code
-*/
-const char *evdns_err_to_string(int err);
-
-
-/**
-  Add a nameserver.
-
-  The address should be an IPv4 address in network byte order.
-  The type of address is chosen so that it matches in_addr.s_addr.
-
-  @param base the evdns_base to which to add the name server
-  @param address an IP address in network byte order
-  @return 0 if successful, or -1 if an error occurred
-  @see evdns_base_nameserver_ip_add()
- */
-int evdns_base_nameserver_add(struct evdns_base *base,
-    unsigned long int address);
-
-/**
-  Get the number of configured nameservers.
-
-  This returns the number of configured nameservers (not necessarily the
-  number of running nameservers).  This is useful for double-checking
-  whether our calls to the various nameserver configuration functions
-  have been successful.
-
-  @param base the evdns_base to which to apply this operation
-  @return the number of configured nameservers
-  @see evdns_base_nameserver_add()
- */
-int evdns_base_count_nameservers(struct evdns_base *base);
-
-/**
-  Remove all configured nameservers, and suspend all pending resolves.
-
-  Resolves will not necessarily be re-attempted until evdns_base_resume() is called.
-
-  @param base the evdns_base to which to apply this operation
-  @return 0 if successful, or -1 if an error occurred
-  @see evdns_base_resume()
- */
-int evdns_base_clear_nameservers_and_suspend(struct evdns_base *base);
-
-
-/**
-  Resume normal operation and continue any suspended resolve requests.
-
-  Re-attempt resolves left in limbo after an earlier call to
-  evdns_base_clear_nameservers_and_suspend().
-
-  @param base the evdns_base to which to apply this operation
-  @return 0 if successful, or -1 if an error occurred
-  @see evdns_base_clear_nameservers_and_suspend()
- */
-int evdns_base_resume(struct evdns_base *base);
-
-/**
-  Add a nameserver by string address.
-
-  This function parses a n IPv4 or IPv6 address from a string and adds it as a
-  nameserver.  It supports the following formats:
-  - [IPv6Address]:port
-  - [IPv6Address]
-  - IPv6Address
-  - IPv4Address:port
-  - IPv4Address
-
-  If no port is specified, it defaults to 53.
-
-  @param base the evdns_base to which to apply this operation
-  @return 0 if successful, or -1 if an error occurred
-  @see evdns_base_nameserver_add()
- */
-int evdns_base_nameserver_ip_add(struct evdns_base *base,
-    const char *ip_as_string);
-
-/**
-   Add a nameserver by sockaddr.
- **/
-int
-evdns_base_nameserver_sockaddr_add(struct evdns_base *base,
-    const struct sockaddr *sa, ev_socklen_t len, unsigned flags);
-
-struct evdns_request;
-
-/**
-  Lookup an A record for a given name.
-
-  @param base the evdns_base to which to apply this operation
-  @param name a DNS hostname
-  @param flags either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query.
-  @param callback a callback function to invoke when the request is completed
-  @param ptr an argument to pass to the callback function
-  @return an evdns_request object if successful, or NULL if an error occurred.
-  @see evdns_resolve_ipv6(), evdns_resolve_reverse(), evdns_resolve_reverse_ipv6(), evdns_cancel_request()
- */
-struct evdns_request *evdns_base_resolve_ipv4(struct evdns_base *base, const char *name, int flags, evdns_callback_type callback, void *ptr);
-
-/**
-  Lookup an AAAA record for a given name.
-
-  @param base the evdns_base to which to apply this operation
-  @param name a DNS hostname
-  @param flags either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query.
-  @param callback a callback function to invoke when the request is completed
-  @param ptr an argument to pass to the callback function
-  @return an evdns_request object if successful, or NULL if an error occurred.
-  @see evdns_resolve_ipv4(), evdns_resolve_reverse(), evdns_resolve_reverse_ipv6(), evdns_cancel_request()
- */
-struct evdns_request *evdns_base_resolve_ipv6(struct evdns_base *base, const char *name, int flags, evdns_callback_type callback, void *ptr);
-
-struct in_addr;
-struct in6_addr;
-
-/**
-  Lookup a PTR record for a given IP address.
-
-  @param base the evdns_base to which to apply this operation
-  @param in an IPv4 address
-  @param flags either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query.
-  @param callback a callback function to invoke when the request is completed
-  @param ptr an argument to pass to the callback function
-  @return an evdns_request object if successful, or NULL if an error occurred.
-  @see evdns_resolve_reverse_ipv6(), evdns_cancel_request()
- */
-struct evdns_request *evdns_base_resolve_reverse(struct evdns_base *base, const struct in_addr *in, int flags, evdns_callback_type callback, void *ptr);
-
-
-/**
-  Lookup a PTR record for a given IPv6 address.
-
-  @param base the evdns_base to which to apply this operation
-  @param in an IPv6 address
-  @param flags either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query.
-  @param callback a callback function to invoke when the request is completed
-  @param ptr an argument to pass to the callback function
-  @return an evdns_request object if successful, or NULL if an error occurred.
-  @see evdns_resolve_reverse_ipv6(), evdns_cancel_request()
- */
-struct evdns_request *evdns_base_resolve_reverse_ipv6(struct evdns_base *base, const struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr);
-
-/**
-  Cancels a pending DNS resolution request.
-
-  @param base the evdns_base that was used to make the request
-  @param req the evdns_request that was returned by calling a resolve function
-  @see evdns_base_resolve_ipv4(), evdns_base_resolve_ipv6, evdns_base_resolve_reverse
-*/
-void evdns_cancel_request(struct evdns_base *base, struct evdns_request *req);
-
-/**
-  Set the value of a configuration option.
-
-  The currently available configuration options are:
-
-    ndots, timeout, max-timeouts, max-inflight, attempts, randomize-case,
-    bind-to, initial-probe-timeout, getaddrinfo-allow-skew.
-
-  In versions before Libevent 2.0.3-alpha, the option name needed to end with
-  a colon.
-
-  @param base the evdns_base to which to apply this operation
-  @param option the name of the configuration option to be modified
-  @param val the value to be set
-  @return 0 if successful, or -1 if an error occurred
- */
-int evdns_base_set_option(struct evdns_base *base, const char *option, const char *val);
-
-
-/**
-  Parse a resolv.conf file.
-
-  The 'flags' parameter determines what information is parsed from the
-  resolv.conf file. See the man page for resolv.conf for the format of this
-  file.
-
-  The following directives are not parsed from the file: sortlist, rotate,
-  no-check-names, inet6, debug.
-
-  If this function encounters an error, the possible return values are: 1 =
-  failed to open file, 2 = failed to stat file, 3 = file too large, 4 = out of
-  memory, 5 = short read from file, 6 = no nameservers listed in the file
-
-  @param base the evdns_base to which to apply this operation
-  @param flags any of DNS_OPTION_NAMESERVERS|DNS_OPTION_SEARCH|DNS_OPTION_MISC|
-    DNS_OPTION_HOSTSFILE|DNS_OPTIONS_ALL
-  @param filename the path to the resolv.conf file
-  @return 0 if successful, or various positive error codes if an error
-    occurred (see above)
-  @see resolv.conf(3), evdns_config_windows_nameservers()
- */
-int evdns_base_resolv_conf_parse(struct evdns_base *base, int flags, const char *const filename);
-
-/**
-   Load an /etc/hosts-style file from 'hosts_fname' into 'base'.
-
-   If hosts_fname is NULL, add minimal entries for localhost, and nothing
-   else.
-
-   Note that only evdns_getaddrinfo uses the /etc/hosts entries.
-
-   Return 0 on success, negative on failure.
-*/
-int evdns_base_load_hosts(struct evdns_base *base, const char *hosts_fname);
-
-/**
-  Obtain nameserver information using the Windows API.
-
-  Attempt to configure a set of nameservers based on platform settings on
-  a win32 host.  Preferentially tries to use GetNetworkParams; if that fails,
-  looks in the registry.
-
-  @return 0 if successful, or -1 if an error occurred
-  @see evdns_resolv_conf_parse()
- */
-#ifdef WIN32
-int evdns_base_config_windows_nameservers(struct evdns_base *);
-#define EVDNS_BASE_CONFIG_WINDOWS_NAMESERVERS_IMPLEMENTED
-#endif
-
-
-/**
-  Clear the list of search domains.
- */
-void evdns_base_search_clear(struct evdns_base *base);
-
-
-/**
-  Add a domain to the list of search domains
-
-  @param domain the domain to be added to the search list
- */
-void evdns_base_search_add(struct evdns_base *base, const char *domain);
-
-
-/**
-  Set the 'ndots' parameter for searches.
-
-  Sets the number of dots which, when found in a name, causes
-  the first query to be without any search domain.
-
-  @param ndots the new ndots parameter
- */
-void evdns_base_search_ndots_set(struct evdns_base *base, const int ndots);
-
-/**
-  A callback that is invoked when a log message is generated
-
-  @param is_warning indicates if the log message is a 'warning'
-  @param msg the content of the log message
- */
-typedef void (*evdns_debug_log_fn_type)(int is_warning, const char *msg);
-
-
-/**
-  Set the callback function to handle DNS log messages.  If this
-  callback is not set, evdns log messages are handled with the regular
-  Libevent logging system.
-
-  @param fn the callback to be invoked when a log message is generated
- */
-void evdns_set_log_fn(evdns_debug_log_fn_type fn);
-
-/**
-   Set a callback that will be invoked to generate transaction IDs.  By
-   default, we pick transaction IDs based on the current clock time, which
-   is bad for security.
-
-   @param fn the new callback, or NULL to use the default.
-
-   NOTE: This function has no effect in Libevent 2.0.4-alpha and later,
-   since Libevent now provides its own secure RNG.
- */
-void evdns_set_transaction_id_fn(ev_uint16_t (*fn)(void));
-
-/**
-   Set a callback used to generate random bytes.  By default, we use
-   the same function as passed to evdns_set_transaction_id_fn to generate
-   bytes two at a time.  If a function is provided here, it's also used
-   to generate transaction IDs.
-
-   NOTE: This function has no effect in Libevent 2.0.4-alpha and later,
-   since Libevent now provides its own secure RNG.
-*/
-void evdns_set_random_bytes_fn(void (*fn)(char *, size_t));
-
-/*
- * Functions used to implement a DNS server.
- */
-
-struct evdns_server_request;
-struct evdns_server_question;
-
-/**
-   A callback to implement a DNS server.  The callback function receives a DNS
-   request.  It should then optionally add a number of answers to the reply
-   using the evdns_server_request_add_*_reply functions, before calling either
-   evdns_server_request_respond to send the reply back, or
-   evdns_server_request_drop to decline to answer the request.
-
-   @param req A newly received request
-   @param user_data A pointer that was passed to
-      evdns_add_server_port_with_base().
- */
-typedef void (*evdns_request_callback_fn_type)(struct evdns_server_request *, void *);
-#define EVDNS_ANSWER_SECTION 0
-#define EVDNS_AUTHORITY_SECTION 1
-#define EVDNS_ADDITIONAL_SECTION 2
-
-#define EVDNS_TYPE_A	   1
-#define EVDNS_TYPE_NS	   2
-#define EVDNS_TYPE_CNAME   5
-#define EVDNS_TYPE_SOA	   6
-#define EVDNS_TYPE_PTR	  12
-#define EVDNS_TYPE_MX	  15
-#define EVDNS_TYPE_TXT	  16
-#define EVDNS_TYPE_AAAA	  28
-
-#define EVDNS_QTYPE_AXFR 252
-#define EVDNS_QTYPE_ALL	 255
-
-#define EVDNS_CLASS_INET   1
-
-/* flags that can be set in answers; as part of the err parameter */
-#define EVDNS_FLAGS_AA	0x400
-#define EVDNS_FLAGS_RD	0x080
-
-/** Create a new DNS server port.
-
-    @param base The event base to handle events for the server port.
-    @param socket A UDP socket to accept DNS requests.
-    @param flags Always 0 for now.
-    @param callback A function to invoke whenever we get a DNS request
-      on the socket.
-    @param user_data Data to pass to the callback.
-    @return an evdns_server_port structure for this server port.
- */
-struct evdns_server_port *evdns_add_server_port_with_base(struct event_base *base, evutil_socket_t socket, int flags, evdns_request_callback_fn_type callback, void *user_data);
-/** Close down a DNS server port, and free associated structures. */
-void evdns_close_server_port(struct evdns_server_port *port);
-
-/** Sets some flags in a reply we're building.
-    Allows setting of the AA or RD flags
- */
-void evdns_server_request_set_flags(struct evdns_server_request *req, int flags);
-
-/* Functions to add an answer to an in-progress DNS reply.
- */
-int evdns_server_request_add_reply(struct evdns_server_request *req, int section, const char *name, int type, int dns_class, int ttl, int datalen, int is_name, const char *data);
-int evdns_server_request_add_a_reply(struct evdns_server_request *req, const char *name, int n, const void *addrs, int ttl);
-int evdns_server_request_add_aaaa_reply(struct evdns_server_request *req, const char *name, int n, const void *addrs, int ttl);
-int evdns_server_request_add_ptr_reply(struct evdns_server_request *req, struct in_addr *in, const char *inaddr_name, const char *hostname, int ttl);
-int evdns_server_request_add_cname_reply(struct evdns_server_request *req, const char *name, const char *cname, int ttl);
-
-/**
-   Send back a response to a DNS request, and free the request structure.
-*/
-int evdns_server_request_respond(struct evdns_server_request *req, int err);
-/**
-   Free a DNS request without sending back a reply.
-*/
-int evdns_server_request_drop(struct evdns_server_request *req);
-struct sockaddr;
-/**
-    Get the address that made a DNS request.
- */
-int evdns_server_request_get_requesting_addr(struct evdns_server_request *_req, struct sockaddr *sa, int addr_len);
-
-/** Callback for evdns_getaddrinfo. */
-typedef void (*evdns_getaddrinfo_cb)(int result, struct evutil_addrinfo *res, void *arg);
-
-struct evdns_base;
-struct evdns_getaddrinfo_request;
-/** Make a non-blocking getaddrinfo request using the dns_base in 'dns_base'.
- *
- * If we can answer the request immediately (with an error or not!), then we
- * invoke cb immediately and return NULL.  Otherwise we return
- * an evdns_getaddrinfo_request and invoke cb later.
- *
- * When the callback is invoked, we pass as its first argument the error code
- * that getaddrinfo would return (or 0 for no error).  As its second argument,
- * we pass the evutil_addrinfo structures we found (or NULL on error).  We
- * pass 'arg' as the third argument.
- *
- * Limitations:
- *
- * - The AI_V4MAPPED and AI_ALL flags are not currently implemented.
- * - For ai_socktype, we only handle SOCKTYPE_STREAM, SOCKTYPE_UDP, and 0.
- * - For ai_protocol, we only handle IPPROTO_TCP, IPPROTO_UDP, and 0.
- */
-struct evdns_getaddrinfo_request *evdns_getaddrinfo(
-    struct evdns_base *dns_base,
-    const char *nodename, const char *servname,
-    const struct evutil_addrinfo *hints_in,
-    evdns_getaddrinfo_cb cb, void *arg);
-
-/* Cancel an in-progress evdns_getaddrinfo.  This MUST NOT be called after the
- * getaddrinfo's callback has been invoked.  The resolves will be canceled,
- * and the callback will be invoked with the error EVUTIL_EAI_CANCEL. */
-void evdns_getaddrinfo_cancel(struct evdns_getaddrinfo_request *req);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif  /* !_EVENT2_DNS_H_ */
+/*
+ * Copyright (c) 2006-2007 Niels Provos <provos@citi.umich.edu>
+ * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * The original DNS code is due to Adam Langley with heavy
+ * modifications by Nick Mathewson.  Adam put his DNS software in the
+ * public domain.  You can find his original copyright below.  Please,
+ * aware that the code as part of Libevent is governed by the 3-clause
+ * BSD license above.
+ *
+ * This software is Public Domain. To view a copy of the public domain dedication,
+ * visit http://creativecommons.org/licenses/publicdomain/ or send a letter to
+ * Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.
+ *
+ * I ask and expect, but do not require, that all derivative works contain an
+ * attribution similar to:
+ *     Parts developed by Adam Langley <agl@imperialviolet.org>
+ *
+ * You may wish to replace the word "Parts" with something else depending on
+ * the amount of original code.
+ *
+ * (Derivative works does not include programs which link against, run or include
+ * the source verbatim in their source distributions)
+ */
+
+/** @file event2/dns.h
+ *
+ * Welcome, gentle reader
+ *
+ * Async DNS lookups are really a whole lot harder than they should be,
+ * mostly stemming from the fact that the libc resolver has never been
+ * very good at them. Before you use this library you should see if libc
+ * can do the job for you with the modern async call getaddrinfo_a
+ * (see http://www.imperialviolet.org/page25.html#e498). Otherwise,
+ * please continue.
+ *
+ * The library keeps track of the state of nameservers and will avoid
+ * them when they go down. Otherwise it will round robin between them.
+ *
+ * Quick start guide:
+ *   #include "evdns.h"
+ *   void callback(int result, char type, int count, int ttl,
+ *		 void *addresses, void *arg);
+ *   evdns_resolv_conf_parse(DNS_OPTIONS_ALL, "/etc/resolv.conf");
+ *   evdns_resolve("www.hostname.com", 0, callback, NULL);
+ *
+ * When the lookup is complete the callback function is called. The
+ * first argument will be one of the DNS_ERR_* defines in evdns.h.
+ * Hopefully it will be DNS_ERR_NONE, in which case type will be
+ * DNS_IPv4_A, count will be the number of IP addresses, ttl is the time
+ * which the data can be cached for (in seconds), addresses will point
+ * to an array of uint32_t's and arg will be whatever you passed to
+ * evdns_resolve.
+ *
+ * Searching:
+ *
+ * In order for this library to be a good replacement for glibc's resolver it
+ * supports searching. This involves setting a list of default domains, in
+ * which names will be queried for. The number of dots in the query name
+ * determines the order in which this list is used.
+ *
+ * Searching appears to be a single lookup from the point of view of the API,
+ * although many DNS queries may be generated from a single call to
+ * evdns_resolve. Searching can also drastically slow down the resolution
+ * of names.
+ *
+ * To disable searching:
+ *   1. Never set it up. If you never call evdns_resolv_conf_parse or
+ *   evdns_search_add then no searching will occur.
+ *
+ *   2. If you do call evdns_resolv_conf_parse then don't pass
+ *   DNS_OPTION_SEARCH (or DNS_OPTIONS_ALL, which implies it).
+ *
+ *   3. When calling evdns_resolve, pass the DNS_QUERY_NO_SEARCH flag.
+ *
+ * The order of searches depends on the number of dots in the name. If the
+ * number is greater than the ndots setting then the names is first tried
+ * globally. Otherwise each search domain is appended in turn.
+ *
+ * The ndots setting can either be set from a resolv.conf, or by calling
+ * evdns_search_ndots_set.
+ *
+ * For example, with ndots set to 1 (the default) and a search domain list of
+ * ["myhome.net"]:
+ *  Query: www
+ *  Order: www.myhome.net, www.
+ *
+ *  Query: www.abc
+ *  Order: www.abc., www.abc.myhome.net
+ *
+ * Internals:
+ *
+ * Requests are kept in two queues. The first is the inflight queue. In
+ * this queue requests have an allocated transaction id and nameserver.
+ * They will soon be transmitted if they haven't already been.
+ *
+ * The second is the waiting queue. The size of the inflight ring is
+ * limited and all other requests wait in waiting queue for space. This
+ * bounds the number of concurrent requests so that we don't flood the
+ * nameserver. Several algorithms require a full walk of the inflight
+ * queue and so bounding its size keeps thing going nicely under huge
+ * (many thousands of requests) loads.
+ *
+ * If a nameserver loses too many requests it is considered down and we
+ * try not to use it. After a while we send a probe to that nameserver
+ * (a lookup for google.com) and, if it replies, we consider it working
+ * again. If the nameserver fails a probe we wait longer to try again
+ * with the next probe.
+ */
+
+#ifndef EVENT2_DNS_H_INCLUDED_
+#define EVENT2_DNS_H_INCLUDED_
+
+#include <event2/visibility.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* For integer types. */
+#include <event2/util.h>
+
+/** Error codes 0-5 are as described in RFC 1035. */
+#define DNS_ERR_NONE 0
+/** The name server was unable to interpret the query */
+#define DNS_ERR_FORMAT 1
+/** The name server was unable to process this query due to a problem with the
+ * name server */
+#define DNS_ERR_SERVERFAILED 2
+/** The domain name does not exist */
+#define DNS_ERR_NOTEXIST 3
+/** The name server does not support the requested kind of query */
+#define DNS_ERR_NOTIMPL 4
+/** The name server refuses to reform the specified operation for policy
+ * reasons */
+#define DNS_ERR_REFUSED 5
+/** The reply was truncated or ill-formatted */
+#define DNS_ERR_TRUNCATED 65
+/** An unknown error occurred */
+#define DNS_ERR_UNKNOWN 66
+/** Communication with the server timed out */
+#define DNS_ERR_TIMEOUT 67
+/** The request was canceled because the DNS subsystem was shut down. */
+#define DNS_ERR_SHUTDOWN 68
+/** The request was canceled via a call to evdns_cancel_request */
+#define DNS_ERR_CANCEL 69
+/** There were no answers and no error condition in the DNS packet.
+ * This can happen when you ask for an address that exists, but a record
+ * type that doesn't. */
+#define DNS_ERR_NODATA 70
+
+#define DNS_IPv4_A 1
+#define DNS_PTR 2
+#define DNS_IPv6_AAAA 3
+
+#define DNS_QUERY_NO_SEARCH 1
+
+#define DNS_OPTION_SEARCH 1
+#define DNS_OPTION_NAMESERVERS 2
+#define DNS_OPTION_MISC 4
+#define DNS_OPTION_HOSTSFILE 8
+#define DNS_OPTIONS_ALL 15
+
+/* Obsolete name for DNS_QUERY_NO_SEARCH */
+#define DNS_NO_SEARCH DNS_QUERY_NO_SEARCH
+
+/**
+ * The callback that contains the results from a lookup.
+ * - result is one of the DNS_ERR_* values (DNS_ERR_NONE for success)
+ * - type is either DNS_IPv4_A or DNS_PTR or DNS_IPv6_AAAA
+ * - count contains the number of addresses of form type
+ * - ttl is the number of seconds the resolution may be cached for.
+ * - addresses needs to be cast according to type.  It will be an array of
+ *   4-byte sequences for ipv4, or an array of 16-byte sequences for ipv6,
+ *   or a nul-terminated string for PTR.
+ */
+typedef void (*evdns_callback_type) (int result, char type, int count, int ttl, void *addresses, void *arg);
+
+struct evdns_base;
+struct event_base;
+
+/** Flag for evdns_base_new: process resolv.conf.  */
+#define EVDNS_BASE_INITIALIZE_NAMESERVERS 1
+/** Flag for evdns_base_new: Do not prevent the libevent event loop from
+ * exiting when we have no active dns requests. */
+#define EVDNS_BASE_DISABLE_WHEN_INACTIVE 0x8000
+
+/**
+  Initialize the asynchronous DNS library.
+
+  This function initializes support for non-blocking name resolution by
+  calling evdns_resolv_conf_parse() on UNIX and
+  evdns_config_windows_nameservers() on Windows.
+
+  @param event_base the event base to associate the dns client with
+  @param flags any of EVDNS_BASE_INITIALIZE_NAMESERVERS|
+    EVDNS_BASE_DISABLE_WHEN_INACTIVE
+  @return evdns_base object if successful, or NULL if an error occurred.
+  @see evdns_base_free()
+ */
+EVENT2_EXPORT_SYMBOL
+struct evdns_base * evdns_base_new(struct event_base *event_base, int initialize_nameservers);
+
+
+/**
+  Shut down the asynchronous DNS resolver and terminate all active requests.
+
+  If the 'fail_requests' option is enabled, all active requests will return
+  an empty result with the error flag set to DNS_ERR_SHUTDOWN. Otherwise,
+  the requests will be silently discarded.
+
+  @param evdns_base the evdns base to free
+  @param fail_requests if zero, active requests will be aborted; if non-zero,
+		active requests will return DNS_ERR_SHUTDOWN.
+  @see evdns_base_new()
+ */
+EVENT2_EXPORT_SYMBOL
+void evdns_base_free(struct evdns_base *base, int fail_requests);
+
+/**
+   Remove all hosts entries that have been loaded into the event_base via
+   evdns_base_load_hosts or via event_base_resolv_conf_parse.
+
+   @param evdns_base the evdns base to remove outdated host addresses from
+ */
+EVENT2_EXPORT_SYMBOL
+void evdns_base_clear_host_addresses(struct evdns_base *base);
+
+/**
+  Convert a DNS error code to a string.
+
+  @param err the DNS error code
+  @return a string containing an explanation of the error code
+*/
+EVENT2_EXPORT_SYMBOL
+const char *evdns_err_to_string(int err);
+
+
+/**
+  Add a nameserver.
+
+  The address should be an IPv4 address in network byte order.
+  The type of address is chosen so that it matches in_addr.s_addr.
+
+  @param base the evdns_base to which to add the name server
+  @param address an IP address in network byte order
+  @return 0 if successful, or -1 if an error occurred
+  @see evdns_base_nameserver_ip_add()
+ */
+EVENT2_EXPORT_SYMBOL
+int evdns_base_nameserver_add(struct evdns_base *base,
+    unsigned long int address);
+
+/**
+  Get the number of configured nameservers.
+
+  This returns the number of configured nameservers (not necessarily the
+  number of running nameservers).  This is useful for double-checking
+  whether our calls to the various nameserver configuration functions
+  have been successful.
+
+  @param base the evdns_base to which to apply this operation
+  @return the number of configured nameservers
+  @see evdns_base_nameserver_add()
+ */
+EVENT2_EXPORT_SYMBOL
+int evdns_base_count_nameservers(struct evdns_base *base);
+
+/**
+  Remove all configured nameservers, and suspend all pending resolves.
+
+  Resolves will not necessarily be re-attempted until evdns_base_resume() is called.
+
+  @param base the evdns_base to which to apply this operation
+  @return 0 if successful, or -1 if an error occurred
+  @see evdns_base_resume()
+ */
+EVENT2_EXPORT_SYMBOL
+int evdns_base_clear_nameservers_and_suspend(struct evdns_base *base);
+
+
+/**
+  Resume normal operation and continue any suspended resolve requests.
+
+  Re-attempt resolves left in limbo after an earlier call to
+  evdns_base_clear_nameservers_and_suspend().
+
+  @param base the evdns_base to which to apply this operation
+  @return 0 if successful, or -1 if an error occurred
+  @see evdns_base_clear_nameservers_and_suspend()
+ */
+EVENT2_EXPORT_SYMBOL
+int evdns_base_resume(struct evdns_base *base);
+
+/**
+  Add a nameserver by string address.
+
+  This function parses a n IPv4 or IPv6 address from a string and adds it as a
+  nameserver.  It supports the following formats:
+  - [IPv6Address]:port
+  - [IPv6Address]
+  - IPv6Address
+  - IPv4Address:port
+  - IPv4Address
+
+  If no port is specified, it defaults to 53.
+
+  @param base the evdns_base to which to apply this operation
+  @return 0 if successful, or -1 if an error occurred
+  @see evdns_base_nameserver_add()
+ */
+EVENT2_EXPORT_SYMBOL
+int evdns_base_nameserver_ip_add(struct evdns_base *base,
+    const char *ip_as_string);
+
+/**
+   Add a nameserver by sockaddr.
+ **/
+EVENT2_EXPORT_SYMBOL
+int
+evdns_base_nameserver_sockaddr_add(struct evdns_base *base,
+    const struct sockaddr *sa, ev_socklen_t len, unsigned flags);
+
+struct evdns_request;
+
+/**
+  Lookup an A record for a given name.
+
+  @param base the evdns_base to which to apply this operation
+  @param name a DNS hostname
+  @param flags either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query.
+  @param callback a callback function to invoke when the request is completed
+  @param ptr an argument to pass to the callback function
+  @return an evdns_request object if successful, or NULL if an error occurred.
+  @see evdns_resolve_ipv6(), evdns_resolve_reverse(), evdns_resolve_reverse_ipv6(), evdns_cancel_request()
+ */
+EVENT2_EXPORT_SYMBOL
+struct evdns_request *evdns_base_resolve_ipv4(struct evdns_base *base, const char *name, int flags, evdns_callback_type callback, void *ptr);
+
+/**
+  Lookup an AAAA record for a given name.
+
+  @param base the evdns_base to which to apply this operation
+  @param name a DNS hostname
+  @param flags either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query.
+  @param callback a callback function to invoke when the request is completed
+  @param ptr an argument to pass to the callback function
+  @return an evdns_request object if successful, or NULL if an error occurred.
+  @see evdns_resolve_ipv4(), evdns_resolve_reverse(), evdns_resolve_reverse_ipv6(), evdns_cancel_request()
+ */
+EVENT2_EXPORT_SYMBOL
+struct evdns_request *evdns_base_resolve_ipv6(struct evdns_base *base, const char *name, int flags, evdns_callback_type callback, void *ptr);
+
+struct in_addr;
+struct in6_addr;
+
+/**
+  Lookup a PTR record for a given IP address.
+
+  @param base the evdns_base to which to apply this operation
+  @param in an IPv4 address
+  @param flags either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query.
+  @param callback a callback function to invoke when the request is completed
+  @param ptr an argument to pass to the callback function
+  @return an evdns_request object if successful, or NULL if an error occurred.
+  @see evdns_resolve_reverse_ipv6(), evdns_cancel_request()
+ */
+EVENT2_EXPORT_SYMBOL
+struct evdns_request *evdns_base_resolve_reverse(struct evdns_base *base, const struct in_addr *in, int flags, evdns_callback_type callback, void *ptr);
+
+
+/**
+  Lookup a PTR record for a given IPv6 address.
+
+  @param base the evdns_base to which to apply this operation
+  @param in an IPv6 address
+  @param flags either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query.
+  @param callback a callback function to invoke when the request is completed
+  @param ptr an argument to pass to the callback function
+  @return an evdns_request object if successful, or NULL if an error occurred.
+  @see evdns_resolve_reverse_ipv6(), evdns_cancel_request()
+ */
+EVENT2_EXPORT_SYMBOL
+struct evdns_request *evdns_base_resolve_reverse_ipv6(struct evdns_base *base, const struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr);
+
+/**
+  Cancels a pending DNS resolution request.
+
+  @param base the evdns_base that was used to make the request
+  @param req the evdns_request that was returned by calling a resolve function
+  @see evdns_base_resolve_ipv4(), evdns_base_resolve_ipv6, evdns_base_resolve_reverse
+*/
+EVENT2_EXPORT_SYMBOL
+void evdns_cancel_request(struct evdns_base *base, struct evdns_request *req);
+
+/**
+  Set the value of a configuration option.
+
+  The currently available configuration options are:
+
+    ndots, timeout, max-timeouts, max-inflight, attempts, randomize-case,
+    bind-to, initial-probe-timeout, getaddrinfo-allow-skew.
+
+  In versions before Libevent 2.0.3-alpha, the option name needed to end with
+  a colon.
+
+  @param base the evdns_base to which to apply this operation
+  @param option the name of the configuration option to be modified
+  @param val the value to be set
+  @return 0 if successful, or -1 if an error occurred
+ */
+EVENT2_EXPORT_SYMBOL
+int evdns_base_set_option(struct evdns_base *base, const char *option, const char *val);
+
+
+/**
+  Parse a resolv.conf file.
+
+  The 'flags' parameter determines what information is parsed from the
+  resolv.conf file. See the man page for resolv.conf for the format of this
+  file.
+
+  The following directives are not parsed from the file: sortlist, rotate,
+  no-check-names, inet6, debug.
+
+  If this function encounters an error, the possible return values are: 1 =
+  failed to open file, 2 = failed to stat file, 3 = file too large, 4 = out of
+  memory, 5 = short read from file, 6 = no nameservers listed in the file
+
+  @param base the evdns_base to which to apply this operation
+  @param flags any of DNS_OPTION_NAMESERVERS|DNS_OPTION_SEARCH|DNS_OPTION_MISC|
+    DNS_OPTION_HOSTSFILE|DNS_OPTIONS_ALL
+  @param filename the path to the resolv.conf file
+  @return 0 if successful, or various positive error codes if an error
+    occurred (see above)
+  @see resolv.conf(3), evdns_config_windows_nameservers()
+ */
+EVENT2_EXPORT_SYMBOL
+int evdns_base_resolv_conf_parse(struct evdns_base *base, int flags, const char *const filename);
+
+/**
+   Load an /etc/hosts-style file from 'hosts_fname' into 'base'.
+
+   If hosts_fname is NULL, add minimal entries for localhost, and nothing
+   else.
+
+   Note that only evdns_getaddrinfo uses the /etc/hosts entries.
+
+   This function does not replace previously loaded hosts entries; to do that,
+   call evdns_base_clear_host_addresses first.
+
+   Return 0 on success, negative on failure.
+*/
+EVENT2_EXPORT_SYMBOL
+int evdns_base_load_hosts(struct evdns_base *base, const char *hosts_fname);
+
+/**
+  Obtain nameserver information using the Windows API.
+
+  Attempt to configure a set of nameservers based on platform settings on
+  a win32 host.  Preferentially tries to use GetNetworkParams; if that fails,
+  looks in the registry.
+
+  @return 0 if successful, or -1 if an error occurred
+  @see evdns_resolv_conf_parse()
+ */
+#ifdef _WIN32
+EVENT2_EXPORT_SYMBOL
+int evdns_base_config_windows_nameservers(struct evdns_base *);
+#define EVDNS_BASE_CONFIG_WINDOWS_NAMESERVERS_IMPLEMENTED
+#endif
+
+
+/**
+  Clear the list of search domains.
+ */
+EVENT2_EXPORT_SYMBOL
+void evdns_base_search_clear(struct evdns_base *base);
+
+
+/**
+  Add a domain to the list of search domains
+
+  @param domain the domain to be added to the search list
+ */
+EVENT2_EXPORT_SYMBOL
+void evdns_base_search_add(struct evdns_base *base, const char *domain);
+
+
+/**
+  Set the 'ndots' parameter for searches.
+
+  Sets the number of dots which, when found in a name, causes
+  the first query to be without any search domain.
+
+  @param ndots the new ndots parameter
+ */
+EVENT2_EXPORT_SYMBOL
+void evdns_base_search_ndots_set(struct evdns_base *base, const int ndots);
+
+/**
+  A callback that is invoked when a log message is generated
+
+  @param is_warning indicates if the log message is a 'warning'
+  @param msg the content of the log message
+ */
+typedef void (*evdns_debug_log_fn_type)(int is_warning, const char *msg);
+
+
+/**
+  Set the callback function to handle DNS log messages.  If this
+  callback is not set, evdns log messages are handled with the regular
+  Libevent logging system.
+
+  @param fn the callback to be invoked when a log message is generated
+ */
+EVENT2_EXPORT_SYMBOL
+void evdns_set_log_fn(evdns_debug_log_fn_type fn);
+
+/**
+   Set a callback that will be invoked to generate transaction IDs.  By
+   default, we pick transaction IDs based on the current clock time, which
+   is bad for security.
+
+   @param fn the new callback, or NULL to use the default.
+
+   NOTE: This function has no effect in Libevent 2.0.4-alpha and later,
+   since Libevent now provides its own secure RNG.
+ */
+EVENT2_EXPORT_SYMBOL
+void evdns_set_transaction_id_fn(ev_uint16_t (*fn)(void));
+
+/**
+   Set a callback used to generate random bytes.  By default, we use
+   the same function as passed to evdns_set_transaction_id_fn to generate
+   bytes two at a time.  If a function is provided here, it's also used
+   to generate transaction IDs.
+
+   NOTE: This function has no effect in Libevent 2.0.4-alpha and later,
+   since Libevent now provides its own secure RNG.
+*/
+EVENT2_EXPORT_SYMBOL
+void evdns_set_random_bytes_fn(void (*fn)(char *, size_t));
+
+/*
+ * Functions used to implement a DNS server.
+ */
+
+struct evdns_server_request;
+struct evdns_server_question;
+
+/**
+   A callback to implement a DNS server.  The callback function receives a DNS
+   request.  It should then optionally add a number of answers to the reply
+   using the evdns_server_request_add_*_reply functions, before calling either
+   evdns_server_request_respond to send the reply back, or
+   evdns_server_request_drop to decline to answer the request.
+
+   @param req A newly received request
+   @param user_data A pointer that was passed to
+      evdns_add_server_port_with_base().
+ */
+typedef void (*evdns_request_callback_fn_type)(struct evdns_server_request *, void *);
+#define EVDNS_ANSWER_SECTION 0
+#define EVDNS_AUTHORITY_SECTION 1
+#define EVDNS_ADDITIONAL_SECTION 2
+
+#define EVDNS_TYPE_A	   1
+#define EVDNS_TYPE_NS	   2
+#define EVDNS_TYPE_CNAME   5
+#define EVDNS_TYPE_SOA	   6
+#define EVDNS_TYPE_PTR	  12
+#define EVDNS_TYPE_MX	  15
+#define EVDNS_TYPE_TXT	  16
+#define EVDNS_TYPE_AAAA	  28
+
+#define EVDNS_QTYPE_AXFR 252
+#define EVDNS_QTYPE_ALL	 255
+
+#define EVDNS_CLASS_INET   1
+
+/* flags that can be set in answers; as part of the err parameter */
+#define EVDNS_FLAGS_AA	0x400
+#define EVDNS_FLAGS_RD	0x080
+
+/** Create a new DNS server port.
+
+    @param base The event base to handle events for the server port.
+    @param socket A UDP socket to accept DNS requests.
+    @param flags Always 0 for now.
+    @param callback A function to invoke whenever we get a DNS request
+      on the socket.
+    @param user_data Data to pass to the callback.
+    @return an evdns_server_port structure for this server port.
+ */
+EVENT2_EXPORT_SYMBOL
+struct evdns_server_port *evdns_add_server_port_with_base(struct event_base *base, evutil_socket_t socket, int flags, evdns_request_callback_fn_type callback, void *user_data);
+/** Close down a DNS server port, and free associated structures. */
+EVENT2_EXPORT_SYMBOL
+void evdns_close_server_port(struct evdns_server_port *port);
+
+/** Sets some flags in a reply we're building.
+    Allows setting of the AA or RD flags
+ */
+EVENT2_EXPORT_SYMBOL
+void evdns_server_request_set_flags(struct evdns_server_request *req, int flags);
+
+/* Functions to add an answer to an in-progress DNS reply.
+ */
+EVENT2_EXPORT_SYMBOL
+int evdns_server_request_add_reply(struct evdns_server_request *req, int section, const char *name, int type, int dns_class, int ttl, int datalen, int is_name, const char *data);
+EVENT2_EXPORT_SYMBOL
+int evdns_server_request_add_a_reply(struct evdns_server_request *req, const char *name, int n, const void *addrs, int ttl);
+EVENT2_EXPORT_SYMBOL
+int evdns_server_request_add_aaaa_reply(struct evdns_server_request *req, const char *name, int n, const void *addrs, int ttl);
+EVENT2_EXPORT_SYMBOL
+int evdns_server_request_add_ptr_reply(struct evdns_server_request *req, struct in_addr *in, const char *inaddr_name, const char *hostname, int ttl);
+EVENT2_EXPORT_SYMBOL
+int evdns_server_request_add_cname_reply(struct evdns_server_request *req, const char *name, const char *cname, int ttl);
+
+/**
+   Send back a response to a DNS request, and free the request structure.
+*/
+EVENT2_EXPORT_SYMBOL
+int evdns_server_request_respond(struct evdns_server_request *req, int err);
+/**
+   Free a DNS request without sending back a reply.
+*/
+EVENT2_EXPORT_SYMBOL
+int evdns_server_request_drop(struct evdns_server_request *req);
+struct sockaddr;
+/**
+    Get the address that made a DNS request.
+ */
+EVENT2_EXPORT_SYMBOL
+int evdns_server_request_get_requesting_addr(struct evdns_server_request *req, struct sockaddr *sa, int addr_len);
+
+/** Callback for evdns_getaddrinfo. */
+typedef void (*evdns_getaddrinfo_cb)(int result, struct evutil_addrinfo *res, void *arg);
+
+struct evdns_base;
+struct evdns_getaddrinfo_request;
+/** Make a non-blocking getaddrinfo request using the dns_base in 'dns_base'.
+ *
+ * If we can answer the request immediately (with an error or not!), then we
+ * invoke cb immediately and return NULL.  Otherwise we return
+ * an evdns_getaddrinfo_request and invoke cb later.
+ *
+ * When the callback is invoked, we pass as its first argument the error code
+ * that getaddrinfo would return (or 0 for no error).  As its second argument,
+ * we pass the evutil_addrinfo structures we found (or NULL on error).  We
+ * pass 'arg' as the third argument.
+ *
+ * Limitations:
+ *
+ * - The AI_V4MAPPED and AI_ALL flags are not currently implemented.
+ * - For ai_socktype, we only handle SOCKTYPE_STREAM, SOCKTYPE_UDP, and 0.
+ * - For ai_protocol, we only handle IPPROTO_TCP, IPPROTO_UDP, and 0.
+ */
+EVENT2_EXPORT_SYMBOL
+struct evdns_getaddrinfo_request *evdns_getaddrinfo(
+    struct evdns_base *dns_base,
+    const char *nodename, const char *servname,
+    const struct evutil_addrinfo *hints_in,
+    evdns_getaddrinfo_cb cb, void *arg);
+
+/* Cancel an in-progress evdns_getaddrinfo.  This MUST NOT be called after the
+ * getaddrinfo's callback has been invoked.  The resolves will be canceled,
+ * and the callback will be invoked with the error EVUTIL_EAI_CANCEL. */
+EVENT2_EXPORT_SYMBOL
+void evdns_getaddrinfo_cancel(struct evdns_getaddrinfo_request *req);
+
+/**
+   Retrieve the address of the 'idx'th configured nameserver.
+
+   @param base The evdns_base to examine.
+   @param idx The index of the nameserver to get the address of.
+   @param sa A location to receive the server's address.
+   @param len The number of bytes available at sa.
+
+   @return the number of bytes written into sa on success.  On failure, returns
+     -1 if idx is greater than the number of configured nameservers, or a
+     value greater than 'len' if len was not high enough.
+ */
+EVENT2_EXPORT_SYMBOL
+int evdns_base_get_nameserver_addr(struct evdns_base *base, int idx,
+    struct sockaddr *sa, ev_socklen_t len);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* !EVENT2_DNS_H_INCLUDED_ */
Index: dep/libevent/inc/event2/dns_compat.h
===================================================================
--- dep/libevent/inc/event2/dns_compat.h	(revision 49)
+++ dep/libevent/inc/event2/dns_compat.h	(working copy)
@@ -1,336 +1,336 @@
-/*
- * Copyright (c) 2006-2007 Niels Provos <provos@citi.umich.edu>
- * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _EVENT2_DNS_COMPAT_H_
-#define _EVENT2_DNS_COMPAT_H_
-
-/** @file event2/dns_compat.h
-
-  Potentially non-threadsafe versions of the functions in dns.h: provided
-  only for backwards compatibility.
-
-
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <event2/event-config.h>
-#ifdef _EVENT_HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-#ifdef _EVENT_HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif
-
-/* For int types. */
-#include <event2/util.h>
-
-/**
-  Initialize the asynchronous DNS library.
-
-  This function initializes support for non-blocking name resolution by
-  calling evdns_resolv_conf_parse() on UNIX and
-  evdns_config_windows_nameservers() on Windows.
-
-  @deprecated This function is deprecated because it always uses the current
-    event base, and is easily confused by multiple calls to event_init(), and
-    so is not safe for multithreaded use.  Additionally, it allocates a global
-    structure that only one thread can use. The replacement is
-    evdns_base_new().
-
-  @return 0 if successful, or -1 if an error occurred
-  @see evdns_shutdown()
- */
-int evdns_init(void);
-
-struct evdns_base;
-/**
-   Return the global evdns_base created by event_init() and used by the other
-   deprecated functions.
-
-   @deprecated This function is deprecated because use of the global
-     evdns_base is error-prone.
- */
-struct evdns_base *evdns_get_global_base(void);
-
-/**
-  Shut down the asynchronous DNS resolver and terminate all active requests.
-
-  If the 'fail_requests' option is enabled, all active requests will return
-  an empty result with the error flag set to DNS_ERR_SHUTDOWN. Otherwise,
-  the requests will be silently discarded.
-
-  @deprecated This function is deprecated because it does not allow the
-    caller to specify which evdns_base it applies to.  The recommended
-    function is evdns_base_shutdown().
-
-  @param fail_requests if zero, active requests will be aborted; if non-zero,
-		active requests will return DNS_ERR_SHUTDOWN.
-  @see evdns_init()
- */
-void evdns_shutdown(int fail_requests);
-
-/**
-  Add a nameserver.
-
-  The address should be an IPv4 address in network byte order.
-  The type of address is chosen so that it matches in_addr.s_addr.
-
-  @deprecated This function is deprecated because it does not allow the
-    caller to specify which evdns_base it applies to.  The recommended
-    function is evdns_base_nameserver_add().
-
-  @param address an IP address in network byte order
-  @return 0 if successful, or -1 if an error occurred
-  @see evdns_nameserver_ip_add()
- */
-int evdns_nameserver_add(unsigned long int address);
-
-/**
-  Get the number of configured nameservers.
-
-  This returns the number of configured nameservers (not necessarily the
-  number of running nameservers).  This is useful for double-checking
-  whether our calls to the various nameserver configuration functions
-  have been successful.
-
-  @deprecated This function is deprecated because it does not allow the
-    caller to specify which evdns_base it applies to.  The recommended
-    function is evdns_base_count_nameservers().
-
-  @return the number of configured nameservers
-  @see evdns_nameserver_add()
- */
-int evdns_count_nameservers(void);
-
-/**
-  Remove all configured nameservers, and suspend all pending resolves.
-
-  Resolves will not necessarily be re-attempted until evdns_resume() is called.
-
-  @deprecated This function is deprecated because it does not allow the
-    caller to specify which evdns_base it applies to.  The recommended
-    function is evdns_base_clear_nameservers_and_suspend().
-
-  @return 0 if successful, or -1 if an error occurred
-  @see evdns_resume()
- */
-int evdns_clear_nameservers_and_suspend(void);
-
-/**
-  Resume normal operation and continue any suspended resolve requests.
-
-  Re-attempt resolves left in limbo after an earlier call to
-  evdns_clear_nameservers_and_suspend().
-
-  @deprecated This function is deprecated because it does not allow the
-    caller to specify which evdns_base it applies to.  The recommended
-    function is evdns_base_resume().
-
-  @return 0 if successful, or -1 if an error occurred
-  @see evdns_clear_nameservers_and_suspend()
- */
-int evdns_resume(void);
-
-/**
-  Add a nameserver.
-
-  This wraps the evdns_nameserver_add() function by parsing a string as an IP
-  address and adds it as a nameserver.
-
-  @deprecated This function is deprecated because it does not allow the
-    caller to specify which evdns_base it applies to.  The recommended
-    function is evdns_base_nameserver_ip_add().
-
-  @return 0 if successful, or -1 if an error occurred
-  @see evdns_nameserver_add()
- */
-int evdns_nameserver_ip_add(const char *ip_as_string);
-
-/**
-  Lookup an A record for a given name.
-
-  @deprecated This function is deprecated because it does not allow the
-    caller to specify which evdns_base it applies to.  The recommended
-    function is evdns_base_resolve_ipv4().
-
-  @param name a DNS hostname
-  @param flags either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query.
-  @param callback a callback function to invoke when the request is completed
-  @param ptr an argument to pass to the callback function
-  @return 0 if successful, or -1 if an error occurred
-  @see evdns_resolve_ipv6(), evdns_resolve_reverse(), evdns_resolve_reverse_ipv6()
- */
-int evdns_resolve_ipv4(const char *name, int flags, evdns_callback_type callback, void *ptr);
-
-/**
-  Lookup an AAAA record for a given name.
-
-  @param name a DNS hostname
-  @param flags either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query.
-  @param callback a callback function to invoke when the request is completed
-  @param ptr an argument to pass to the callback function
-  @return 0 if successful, or -1 if an error occurred
-  @see evdns_resolve_ipv4(), evdns_resolve_reverse(), evdns_resolve_reverse_ipv6()
- */
-int evdns_resolve_ipv6(const char *name, int flags, evdns_callback_type callback, void *ptr);
-
-struct in_addr;
-struct in6_addr;
-
-/**
-  Lookup a PTR record for a given IP address.
-
-  @deprecated This function is deprecated because it does not allow the
-    caller to specify which evdns_base it applies to.  The recommended
-    function is evdns_base_resolve_reverse().
-
-  @param in an IPv4 address
-  @param flags either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query.
-  @param callback a callback function to invoke when the request is completed
-  @param ptr an argument to pass to the callback function
-  @return 0 if successful, or -1 if an error occurred
-  @see evdns_resolve_reverse_ipv6()
- */
-int evdns_resolve_reverse(const struct in_addr *in, int flags, evdns_callback_type callback, void *ptr);
-
-/**
-  Lookup a PTR record for a given IPv6 address.
-
-  @deprecated This function is deprecated because it does not allow the
-    caller to specify which evdns_base it applies to.  The recommended
-    function is evdns_base_resolve_reverse_ipv6().
-
-  @param in an IPv6 address
-  @param flags either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query.
-  @param callback a callback function to invoke when the request is completed
-  @param ptr an argument to pass to the callback function
-  @return 0 if successful, or -1 if an error occurred
-  @see evdns_resolve_reverse_ipv6()
- */
-int evdns_resolve_reverse_ipv6(const struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr);
-
-/**
-  Set the value of a configuration option.
-
-  The currently available configuration options are:
-
-    ndots, timeout, max-timeouts, max-inflight, and attempts
-
-  @deprecated This function is deprecated because it does not allow the
-    caller to specify which evdns_base it applies to.  The recommended
-    function is evdns_base_set_option().
-
-  @param option the name of the configuration option to be modified
-  @param val the value to be set
-  @param flags Ignored.
-  @return 0 if successful, or -1 if an error occurred
- */
-int evdns_set_option(const char *option, const char *val, int flags);
-
-/**
-  Parse a resolv.conf file.
-
-  The 'flags' parameter determines what information is parsed from the
-  resolv.conf file. See the man page for resolv.conf for the format of this
-  file.
-
-  The following directives are not parsed from the file: sortlist, rotate,
-  no-check-names, inet6, debug.
-
-  If this function encounters an error, the possible return values are: 1 =
-  failed to open file, 2 = failed to stat file, 3 = file too large, 4 = out of
-  memory, 5 = short read from file, 6 = no nameservers listed in the file
-
-  @deprecated This function is deprecated because it does not allow the
-    caller to specify which evdns_base it applies to.  The recommended
-    function is evdns_base_resolv_conf_parse().
-
-  @param flags any of DNS_OPTION_NAMESERVERS|DNS_OPTION_SEARCH|DNS_OPTION_MISC|
-    DNS_OPTIONS_ALL
-  @param filename the path to the resolv.conf file
-  @return 0 if successful, or various positive error codes if an error
-    occurred (see above)
-  @see resolv.conf(3), evdns_config_windows_nameservers()
- */
-int evdns_resolv_conf_parse(int flags, const char *const filename);
-
-/**
-  Clear the list of search domains.
-
-  @deprecated This function is deprecated because it does not allow the
-    caller to specify which evdns_base it applies to.  The recommended
-    function is evdns_base_search_clear().
- */
-void evdns_search_clear(void);
-
-/**
-  Add a domain to the list of search domains
-
-  @deprecated This function is deprecated because it does not allow the
-    caller to specify which evdns_base it applies to.  The recommended
-    function is evdns_base_search_add().
-
-  @param domain the domain to be added to the search list
- */
-void evdns_search_add(const char *domain);
-
-/**
-  Set the 'ndots' parameter for searches.
-
-  Sets the number of dots which, when found in a name, causes
-  the first query to be without any search domain.
-
-  @deprecated This function is deprecated because it does not allow the
-    caller to specify which evdns_base it applies to.  The recommended
-    function is evdns_base_search_ndots_set().
-
-  @param ndots the new ndots parameter
- */
-void evdns_search_ndots_set(const int ndots);
-
-/**
-   As evdns_server_new_with_base.
-
-  @deprecated This function is deprecated because it does not allow the
-    caller to specify which even_base it uses.  The recommended
-    function is evdns_add_server_port_with_base().
-
-*/
-struct evdns_server_port *evdns_add_server_port(evutil_socket_t socket, int flags, evdns_request_callback_fn_type callback, void *user_data);
-
-#ifdef WIN32
-int evdns_config_windows_nameservers(void);
-#define EVDNS_CONFIG_WINDOWS_NAMESERVERS_IMPLEMENTED
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _EVENT2_EVENT_COMPAT_H_ */
+/*
+ * Copyright (c) 2006-2007 Niels Provos <provos@citi.umich.edu>
+ * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EVENT2_DNS_COMPAT_H_INCLUDED_
+#define EVENT2_DNS_COMPAT_H_INCLUDED_
+
+/** @file event2/dns_compat.h
+
+  Potentially non-threadsafe versions of the functions in dns.h: provided
+  only for backwards compatibility.
+
+
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <event2/event-config.h>
+#ifdef EVENT__HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef EVENT__HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+
+/* For int types. */
+#include <event2/util.h>
+
+/**
+  Initialize the asynchronous DNS library.
+
+  This function initializes support for non-blocking name resolution by
+  calling evdns_resolv_conf_parse() on UNIX and
+  evdns_config_windows_nameservers() on Windows.
+
+  @deprecated This function is deprecated because it always uses the current
+    event base, and is easily confused by multiple calls to event_init(), and
+    so is not safe for multithreaded use.  Additionally, it allocates a global
+    structure that only one thread can use. The replacement is
+    evdns_base_new().
+
+  @return 0 if successful, or -1 if an error occurred
+  @see evdns_shutdown()
+ */
+int evdns_init(void);
+
+struct evdns_base;
+/**
+   Return the global evdns_base created by event_init() and used by the other
+   deprecated functions.
+
+   @deprecated This function is deprecated because use of the global
+     evdns_base is error-prone.
+ */
+struct evdns_base *evdns_get_global_base(void);
+
+/**
+  Shut down the asynchronous DNS resolver and terminate all active requests.
+
+  If the 'fail_requests' option is enabled, all active requests will return
+  an empty result with the error flag set to DNS_ERR_SHUTDOWN. Otherwise,
+  the requests will be silently discarded.
+
+  @deprecated This function is deprecated because it does not allow the
+    caller to specify which evdns_base it applies to.  The recommended
+    function is evdns_base_shutdown().
+
+  @param fail_requests if zero, active requests will be aborted; if non-zero,
+		active requests will return DNS_ERR_SHUTDOWN.
+  @see evdns_init()
+ */
+void evdns_shutdown(int fail_requests);
+
+/**
+  Add a nameserver.
+
+  The address should be an IPv4 address in network byte order.
+  The type of address is chosen so that it matches in_addr.s_addr.
+
+  @deprecated This function is deprecated because it does not allow the
+    caller to specify which evdns_base it applies to.  The recommended
+    function is evdns_base_nameserver_add().
+
+  @param address an IP address in network byte order
+  @return 0 if successful, or -1 if an error occurred
+  @see evdns_nameserver_ip_add()
+ */
+int evdns_nameserver_add(unsigned long int address);
+
+/**
+  Get the number of configured nameservers.
+
+  This returns the number of configured nameservers (not necessarily the
+  number of running nameservers).  This is useful for double-checking
+  whether our calls to the various nameserver configuration functions
+  have been successful.
+
+  @deprecated This function is deprecated because it does not allow the
+    caller to specify which evdns_base it applies to.  The recommended
+    function is evdns_base_count_nameservers().
+
+  @return the number of configured nameservers
+  @see evdns_nameserver_add()
+ */
+int evdns_count_nameservers(void);
+
+/**
+  Remove all configured nameservers, and suspend all pending resolves.
+
+  Resolves will not necessarily be re-attempted until evdns_resume() is called.
+
+  @deprecated This function is deprecated because it does not allow the
+    caller to specify which evdns_base it applies to.  The recommended
+    function is evdns_base_clear_nameservers_and_suspend().
+
+  @return 0 if successful, or -1 if an error occurred
+  @see evdns_resume()
+ */
+int evdns_clear_nameservers_and_suspend(void);
+
+/**
+  Resume normal operation and continue any suspended resolve requests.
+
+  Re-attempt resolves left in limbo after an earlier call to
+  evdns_clear_nameservers_and_suspend().
+
+  @deprecated This function is deprecated because it does not allow the
+    caller to specify which evdns_base it applies to.  The recommended
+    function is evdns_base_resume().
+
+  @return 0 if successful, or -1 if an error occurred
+  @see evdns_clear_nameservers_and_suspend()
+ */
+int evdns_resume(void);
+
+/**
+  Add a nameserver.
+
+  This wraps the evdns_nameserver_add() function by parsing a string as an IP
+  address and adds it as a nameserver.
+
+  @deprecated This function is deprecated because it does not allow the
+    caller to specify which evdns_base it applies to.  The recommended
+    function is evdns_base_nameserver_ip_add().
+
+  @return 0 if successful, or -1 if an error occurred
+  @see evdns_nameserver_add()
+ */
+int evdns_nameserver_ip_add(const char *ip_as_string);
+
+/**
+  Lookup an A record for a given name.
+
+  @deprecated This function is deprecated because it does not allow the
+    caller to specify which evdns_base it applies to.  The recommended
+    function is evdns_base_resolve_ipv4().
+
+  @param name a DNS hostname
+  @param flags either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query.
+  @param callback a callback function to invoke when the request is completed
+  @param ptr an argument to pass to the callback function
+  @return 0 if successful, or -1 if an error occurred
+  @see evdns_resolve_ipv6(), evdns_resolve_reverse(), evdns_resolve_reverse_ipv6()
+ */
+int evdns_resolve_ipv4(const char *name, int flags, evdns_callback_type callback, void *ptr);
+
+/**
+  Lookup an AAAA record for a given name.
+
+  @param name a DNS hostname
+  @param flags either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query.
+  @param callback a callback function to invoke when the request is completed
+  @param ptr an argument to pass to the callback function
+  @return 0 if successful, or -1 if an error occurred
+  @see evdns_resolve_ipv4(), evdns_resolve_reverse(), evdns_resolve_reverse_ipv6()
+ */
+int evdns_resolve_ipv6(const char *name, int flags, evdns_callback_type callback, void *ptr);
+
+struct in_addr;
+struct in6_addr;
+
+/**
+  Lookup a PTR record for a given IP address.
+
+  @deprecated This function is deprecated because it does not allow the
+    caller to specify which evdns_base it applies to.  The recommended
+    function is evdns_base_resolve_reverse().
+
+  @param in an IPv4 address
+  @param flags either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query.
+  @param callback a callback function to invoke when the request is completed
+  @param ptr an argument to pass to the callback function
+  @return 0 if successful, or -1 if an error occurred
+  @see evdns_resolve_reverse_ipv6()
+ */
+int evdns_resolve_reverse(const struct in_addr *in, int flags, evdns_callback_type callback, void *ptr);
+
+/**
+  Lookup a PTR record for a given IPv6 address.
+
+  @deprecated This function is deprecated because it does not allow the
+    caller to specify which evdns_base it applies to.  The recommended
+    function is evdns_base_resolve_reverse_ipv6().
+
+  @param in an IPv6 address
+  @param flags either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query.
+  @param callback a callback function to invoke when the request is completed
+  @param ptr an argument to pass to the callback function
+  @return 0 if successful, or -1 if an error occurred
+  @see evdns_resolve_reverse_ipv6()
+ */
+int evdns_resolve_reverse_ipv6(const struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr);
+
+/**
+  Set the value of a configuration option.
+
+  The currently available configuration options are:
+
+    ndots, timeout, max-timeouts, max-inflight, and attempts
+
+  @deprecated This function is deprecated because it does not allow the
+    caller to specify which evdns_base it applies to.  The recommended
+    function is evdns_base_set_option().
+
+  @param option the name of the configuration option to be modified
+  @param val the value to be set
+  @param flags Ignored.
+  @return 0 if successful, or -1 if an error occurred
+ */
+int evdns_set_option(const char *option, const char *val, int flags);
+
+/**
+  Parse a resolv.conf file.
+
+  The 'flags' parameter determines what information is parsed from the
+  resolv.conf file. See the man page for resolv.conf for the format of this
+  file.
+
+  The following directives are not parsed from the file: sortlist, rotate,
+  no-check-names, inet6, debug.
+
+  If this function encounters an error, the possible return values are: 1 =
+  failed to open file, 2 = failed to stat file, 3 = file too large, 4 = out of
+  memory, 5 = short read from file, 6 = no nameservers listed in the file
+
+  @deprecated This function is deprecated because it does not allow the
+    caller to specify which evdns_base it applies to.  The recommended
+    function is evdns_base_resolv_conf_parse().
+
+  @param flags any of DNS_OPTION_NAMESERVERS|DNS_OPTION_SEARCH|DNS_OPTION_MISC|
+    DNS_OPTIONS_ALL
+  @param filename the path to the resolv.conf file
+  @return 0 if successful, or various positive error codes if an error
+    occurred (see above)
+  @see resolv.conf(3), evdns_config_windows_nameservers()
+ */
+int evdns_resolv_conf_parse(int flags, const char *const filename);
+
+/**
+  Clear the list of search domains.
+
+  @deprecated This function is deprecated because it does not allow the
+    caller to specify which evdns_base it applies to.  The recommended
+    function is evdns_base_search_clear().
+ */
+void evdns_search_clear(void);
+
+/**
+  Add a domain to the list of search domains
+
+  @deprecated This function is deprecated because it does not allow the
+    caller to specify which evdns_base it applies to.  The recommended
+    function is evdns_base_search_add().
+
+  @param domain the domain to be added to the search list
+ */
+void evdns_search_add(const char *domain);
+
+/**
+  Set the 'ndots' parameter for searches.
+
+  Sets the number of dots which, when found in a name, causes
+  the first query to be without any search domain.
+
+  @deprecated This function is deprecated because it does not allow the
+    caller to specify which evdns_base it applies to.  The recommended
+    function is evdns_base_search_ndots_set().
+
+  @param ndots the new ndots parameter
+ */
+void evdns_search_ndots_set(const int ndots);
+
+/**
+   As evdns_server_new_with_base.
+
+  @deprecated This function is deprecated because it does not allow the
+    caller to specify which even_base it uses.  The recommended
+    function is evdns_add_server_port_with_base().
+
+*/
+struct evdns_server_port *evdns_add_server_port(evutil_socket_t socket, int flags, evdns_request_callback_fn_type callback, void *user_data);
+
+#ifdef _WIN32
+int evdns_config_windows_nameservers(void);
+#define EVDNS_CONFIG_WINDOWS_NAMESERVERS_IMPLEMENTED
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EVENT2_EVENT_COMPAT_H_INCLUDED_ */
Index: dep/libevent/inc/event2/dns_struct.h
===================================================================
--- dep/libevent/inc/event2/dns_struct.h	(revision 49)
+++ dep/libevent/inc/event2/dns_struct.h	(working copy)
@@ -1,80 +1,80 @@
-/*
- * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
- * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _EVENT2_DNS_STRUCT_H_
-#define _EVENT2_DNS_STRUCT_H_
-
-/** @file event2/dns_struct.h
-
-  Data structures for dns.  Using these structures may hurt forward
-  compatibility with later versions of Libevent: be careful!
-
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <event2/event-config.h>
-#ifdef _EVENT_HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-#ifdef _EVENT_HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif
-
-/* For int types. */
-#include <event2/util.h>
-
-/*
- * Structures used to implement a DNS server.
- */
-
-struct evdns_server_request {
-	int flags;
-	int nquestions;
-	struct evdns_server_question **questions;
-};
-struct evdns_server_question {
-	int type;
-#ifdef __cplusplus
-	int dns_question_class;
-#else
-	/* You should refer to this field as "dns_question_class".  The
-	 * name "class" works in C for backward compatibility, and will be
-	 * removed in a future version. (1.5 or later). */
-	int class;
-#define dns_question_class class
-#endif
-	char name[1];
-};
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _EVENT2_DNS_STRUCT_H_ */
-
+/*
+ * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
+ * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EVENT2_DNS_STRUCT_H_INCLUDED_
+#define EVENT2_DNS_STRUCT_H_INCLUDED_
+
+/** @file event2/dns_struct.h
+
+  Data structures for dns.  Using these structures may hurt forward
+  compatibility with later versions of Libevent: be careful!
+
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <event2/event-config.h>
+#ifdef EVENT__HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef EVENT__HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+
+/* For int types. */
+#include <event2/util.h>
+
+/*
+ * Structures used to implement a DNS server.
+ */
+
+struct evdns_server_request {
+	int flags;
+	int nquestions;
+	struct evdns_server_question **questions;
+};
+struct evdns_server_question {
+	int type;
+#ifdef __cplusplus
+	int dns_question_class;
+#else
+	/* You should refer to this field as "dns_question_class".  The
+	 * name "class" works in C for backward compatibility, and will be
+	 * removed in a future version. (1.5 or later). */
+	int class;
+#define dns_question_class class
+#endif
+	char name[1];
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EVENT2_DNS_STRUCT_H_INCLUDED_ */
+
Index: dep/libevent/inc/event2/event.h
===================================================================
--- dep/libevent/inc/event2/event.h	(revision 49)
+++ dep/libevent/inc/event2/event.h	(working copy)
@@ -1,1204 +1,1675 @@
-/*
- * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
- * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _EVENT2_EVENT_H_
-#define _EVENT2_EVENT_H_
-
-/**
-   @mainpage
-
-  @section intro Introduction
-
-  Libevent is an event notification library for developing scalable network
-  servers.  The Libevent API provides a mechanism to execute a callback
-  function when a specific event occurs on a file descriptor or after a
-  timeout has been reached. Furthermore, Libevent also support callbacks due
-  to signals or regular timeouts.
-
-  Libevent is meant to replace the event loop found in event driven network
-  servers. An application just needs to call event_dispatch() and then add or
-  remove events dynamically without having to change the event loop.
-
-
-  Currently, Libevent supports /dev/poll, kqueue(2), select(2), poll(2),
-  epoll(4), and evports. The internal event mechanism is completely
-  independent of the exposed event API, and a simple update of Libevent can
-  provide new functionality without having to redesign the applications. As a
-  result, Libevent allows for portable application development and provides
-  the most scalable event notification mechanism available on an operating
-  system.  Libevent can also be used for multithreaded programs.  Libevent
-  should compile on Linux, *BSD, Mac OS X, Solaris and, Windows.
-
-  @section usage Standard usage
-
-  Every program that uses Libevent must inclurde the <event2/event.h>
-  header, and pass the -levent flag to the linker.  (You can instead link
-  -levent_core if you only want the main event and buffered IO-based code,
-  and don't want to link any protocol code.)
-
-  @section setup Library setup
-
-  Before you call any other Libevent functions, you need to set up the
-  library.  If you're going to use Libevent from multiple threads in a
-  multithreaded application, you need to initialize thread support --
-  typically by using evthread_use_pthreads() or
-  evthread_use_windows_threads().  See <event2/thread.h> for more
-  information.
-
-  This is also the point where you can replace Libevent's memory
-  management functions with event_set_mem_functions, and enable debug mode
-  with event_enable_debug_mode().
-
-  @section base Creating an event base
-
-  Next, you need to create an event_base structure, using event_base_new()
-  or event_base_new_with_config().  The event_base is responsible for
-  keeping track of which events are "pending" (that is to say, being
-  watched to see if they become active) and which events are "active".
-  Every event is associated with a single event_base.
-
-  @section event Event notification
-
-  For each file descriptor that you wish to monitor, you must create an
-  event structure with event_new().  (You may also declare an event
-  structure and call event_assign() to initialize the members of the
-  structure.)  To enable notification, you add the structure to the list
-  of monitored events by calling event_add().  The event structure must
-  remain allocated as long as it is active, so it should generally be
-  allocated on the heap.
-
-  @section loop Dispaching evets.
-
-  Finally, you call event_base_dispatch() to loop and dispatch events.
-  You can also use event_base_loop() for more fine-grained control.
-
-  Currently, only one thread can be dispatching a given event_base at a
-  time.  If you want to run events in multiple threads at once, you can
-  either have a single event_base whose events add work to a work queue,
-  or you can create multiple event_base objects.
-
-  @section bufferevent I/O Buffers
-
-  Libevent provides a buffered I/O abstraction on top of the regular event
-  callbacks. This abstraction is called a bufferevent. A bufferevent
-  provides input and output buffers that get filled and drained
-  automatically. The user of a buffered event no longer deals directly
-  with the I/O, but instead is reading from input and writing to output
-  buffers.
-
-  Once initialized via bufferevent_socket_new(), the bufferevent structure
-  can be used repeatedly with bufferevent_enable() and
-  bufferevent_disable().  Instead of reading and writing directly to a
-  socket, you would call bufferevent_read() and bufferevent_write().
-
-  When read enabled the bufferevent will try to read from the file descriptor
-  and call the read callback. The write callback is executed whenever the
-  output buffer is drained below the write low watermark, which is 0 by
-  default.
-
-  See <event2/bufferevent*.h> for more information.
-
-  @section timers Timers
-
-  Libevent can also be used to create timers that invoke a callback after a
-  certain amount of time has expired. The evtimer_new() function returns
-  an event struct to use as a timer. To activate the timer, call
-  evtimer_add(). Timers can be deactivated by calling evtimer_del().
-
-  @section evdns Asynchronous DNS resolution
-
-  Libevent provides an asynchronous DNS resolver that should be used instead
-  of the standard DNS resolver functions.  See the <event2/dns.h>
-  functions for more detail.
-
-  @section evhttp Event-driven HTTP servers
-
-  Libevent provides a very simple event-driven HTTP server that can be
-  embedded in your program and used to service HTTP requests.
-
-  To use this capability, you need to include the <event2/http.h> header in your
-  program.  See that header for more information.
-
-  @section evrpc A framework for RPC servers and clients
-
-  Libevent provides a framework for creating RPC servers and clients.  It
-  takes care of marshaling and unmarshaling all data structures.
-
-  @section api API Reference
-
-  To browse the complete documentation of the libevent API, click on any of
-  the following links.
-
-  event2/event.h
-  The primary libevent header
-
-  event2/thread.h
-  Functions for use by multithreaded programs
-
-  event2/buffer.h and event2/bufferevent.h
-  Buffer management for network reading and writing
-
-  event2/util.h
-  Utility functions for portable nonblocking network code
-
-  event2/dns.h
-  Asynchronous DNS resolution
-
-  event2/http.h
-  An embedded libevent-based HTTP server
-
-  event2/rpc.h
-  A framework for creating RPC servers and clients
-
- */
-
-/** @file event2/event.h
-
-  Core functions for waiting for and receiving events, and using event bases.
-*/
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <event2/event-config.h>
-#ifdef _EVENT_HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-#ifdef _EVENT_HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif
-
-#include <stdio.h>
-
-/* For int types. */
-#include <event2/util.h>
-
-/**
- * Structure to hold information and state for a Libevent dispatch loop.
- *
- * The event_base lies at the center of Libevent; every application will
- * have one.  It keeps track of all pending and active events, and
- * notifies your application of the active ones.
- *
- * This is an opaque structure; you can allocate one using
- * event_base_new() or event_base_new_with_config().
- *
- * @see event_base_new(), event_base_free(), event_base_loop(),
- *    event_base_new_with_config()
- */
-struct event_base
-#ifdef _EVENT_IN_DOXYGEN
-{/*Empty body so that doxygen will generate documentation here.*/}
-#endif
-;
-
-/**
- * @struct event
- *
- * Structure to represent a single event.
- *
- * An event can have some underlying condition it represents: a socket
- * becoming readable or writeable (or both), or a signal becoming raised.
- * (An event that represents no underlying condition is still useful: you
- * can use one to implement a timer, or to communicate between threads.)
- *
- * Generally, you can create events with event_new(), then make them
- * pending with event_add().  As your event_base runs, it will run the
- * callbacks of an events whose conditions are triggered.  When you
- * longer want the event, free it with event_free().
- *
- * In more depth:
- *
- * An event may be "pending" (one whose condition we are watching),
- * "active" (one whose condition has triggered and whose callback is about
- * to run), neither, or both.  Events come into existence via
- * event_assign() or event_new(), and are then neither active nor pending.
- *
- * To make an event pending, pass it to event_add().  When doing so, you
- * can also set a timeout for the event.
- *
- * Events become active during an event_base_loop() call when either their
- * condition has triggered, or when their timeout has elapsed.  You can
- * also activate an event manually using event_active().  The even_base
- * loop will run the callbacks of active events; after it has done so, it
- * marks them as no longer active.
- *
- * You can make an event non-pending by passing it to event_del().  This
- * also makes the event non-active.
- *
- * Events can be "persistent" or "non-persistent".  A non-persistent event
- * becomes non-pending as soon as it is triggered: thus, it only runs at
- * most once per call to event_add().  A persistent event remains pending
- * even when it becomes active: you'll need to event_del() it manually in
- * order to make it non-pending.  When a persistent event with a timeout
- * becomes active, its timeout is reset: this means you can use persistent
- * events to implement periodic timeouts.
- *
- * This should be treated as an opaque structure; you should never read or
- * write any of its fields directly.  For backward compatibility with old
- * code, it is defined in the event2/event_struct.h header; including this
- * header may make your code incompatible with other versions of Libevent.
- *
- * @see event_new(), event_free(), event_assign(), event_get_assignment(),
- *    event_add(), event_del(), event_active(), event_pending(),
- *    event_get_fd(), event_get_base(), event_get_events(),
- *    event_get_callback(), event_get_callback_arg(),
- *    event_priority_set()
- */
-struct event
-#ifdef _EVENT_IN_DOXYGEN
-{/*Empty body so that doxygen will generate documentation here.*/}
-#endif
-;
-
-/**
- * Configuration for an event_base.
- *
- * There are many options that can be used to alter the behavior and
- * implementation of an event_base.  To avoid having to pass them all in a
- * complex many-argument constructor, we provide an abstract data type
- * wrhere you set up configation information before passing it to
- * event_base_new_with_config().
- *
- * @see event_config_new(), event_config_free(), event_base_new_with_config(),
- *   event_config_avoid_method(), event_config_require_features(),
- *   event_config_set_flag(), event_config_set_num_cpus_hint()
- */
-struct event_config
-#ifdef _EVENT_IN_DOXYGEN
-{/*Empty body so that doxygen will generate documentation here.*/}
-#endif
-;
-
-/**
- * Enable some relatively expensive debugging checks in Libevent that
- * would normally be turned off.  Generally, these checks cause code that
- * would otherwise crash mysteriously to fail earlier with an assertion
- * failure.  Note that this method MUST be called before any events or
- * event_bases have been created.
- *
- * Debug mode can currently catch the following errors:
- *    An event is re-assigned while it is added
- *    Any function is called on a non-assigned event
- *
- * Note that debugging mode uses memory to track every event that has been
- * initialized (via event_assign, event_set, or event_new) but not yet
- * released (via event_free or event_debug_unassign).  If you want to use
- * debug mode, and you find yourself running out of memory, you will need
- * to use event_debug_unassign to explicitly stop tracking events that
- * are no longer considered set-up.
- *
- * @see event_debug_unassign()
- */
-void event_enable_debug_mode(void);
-
-/**
- * When debugging mode is enabled, informs Libevent that an event should no
- * longer be considered as assigned. When debugging mode is not enabled, does
- * nothing.
- *
- * This function must only be called on a non-added event.
- *
- * @see event_enable_debug_mode()
- */
-void event_debug_unassign(struct event *);
-
-/**
- * Create and return a new event_base to use with the rest of Libevent.
- *
- * @return a new event_base on success, or NULL on failure.
- *
- * @see event_base_free(), event_base_new_with_config()
- */
-struct event_base *event_base_new(void);
-
-/**
-  Reinitialize the event base after a fork
-
-  Some event mechanisms do not survive across fork.   The event base needs
-  to be reinitialized with the event_reinit() function.
-
-  @param base the event base that needs to be re-initialized
-  @return 0 if successful, or -1 if some events could not be re-added.
-  @see event_base_new()
-*/
-int event_reinit(struct event_base *base);
-
-/**
-   Event dispatching loop
-
-  This loop will run the event base until either there are no more pending or
-  active, or until something calls event_base_loopbreak() or
-  event_base_loopexit().
-
-  @param base the event_base structure returned by event_base_new() or
-     event_base_new_with_config()
-  @return 0 if successful, -1 if an error occurred, or 1 if we exited because
-     no events were pending or active.
-  @see event_base_loop()
- */
-int event_base_dispatch(struct event_base *);
-
-/**
- Get the kernel event notification mechanism used by Libevent.
-
- @param eb the event_base structure returned by event_base_new()
- @return a string identifying the kernel event mechanism (kqueue, epoll, etc.)
- */
-const char *event_base_get_method(const struct event_base *);
-
-/**
-   Gets all event notification mechanisms supported by Libevent.
-
-   This functions returns the event mechanism in order preferred by
-   Libevent.  Note that this list will include all backends that
-   Libevent has compiled-in support for, and will not necessarily check
-   your OS to see whether it has the required resources.
-
-   @return an array with pointers to the names of support methods.
-     The end of the array is indicated by a NULL pointer.  If an
-     error is encountered NULL is returned.
-*/
-const char **event_get_supported_methods(void);
-
-/**
-   Allocates a new event configuration object.
-
-   The event configuration object can be used to change the behavior of
-   an event base.
-
-   @return an event_config object that can be used to store configuration, or
-     NULL if an error is encountered.
-   @see event_base_new_with_config(), event_config_free(), event_config
-*/
-struct event_config *event_config_new(void);
-
-/**
-   Deallocates all memory associated with an event configuration object
-
-   @param cfg the event configuration object to be freed.
-*/
-void event_config_free(struct event_config *cfg);
-
-/**
-   Enters an event method that should be avoided into the configuration.
-
-   This can be used to avoid event mechanisms that do not support certain
-   file descriptor types, or for debugging to avoid certain event
-   mechanisms.  An application can make use of multiple event bases to
-   accommodate incompatible file descriptor types.
-
-   @param cfg the event configuration object
-   @param method the name of the event method to avoid
-   @return 0 on success, -1 on failure.
-*/
-int event_config_avoid_method(struct event_config *cfg, const char *method);
-
-/**
-   A flag used to describe which features an event_base (must) provide.
-
-   Because of OS limitations, not every Libevent backend supports every
-   possible feature.  You can use this type with
-   event_config_require_features() to tell Libevent to only proceed if your
-   event_base implements a given feature, and you can receive this type from
-   event_base_get_features() to see which features are available.
-*/
-enum event_method_feature {
-    /** Require an event method that allows edge-triggered events with EV_ET. */
-    EV_FEATURE_ET = 0x01,
-    /** Require an event method where having one event triggered among
-     * many is [approximately] an O(1) operation. This excludes (for
-     * example) select and poll, which are approximately O(N) for N
-     * equal to the total number of possible events. */
-    EV_FEATURE_O1 = 0x02,
-    /** Require an event method that allows file descriptors as well as
-     * sockets. */
-    EV_FEATURE_FDS = 0x04
-};
-
-/**
-   A flag passed to event_config_set_flag().
-
-    These flags change the behavior of an allocated event_base.
-
-    @see event_config_set_flag(), event_base_new_with_config(),
-       event_method_feature
- */
-enum event_base_config_flag {
-	/** Do not allocate a lock for the event base, even if we have
-	    locking set up. */
-	EVENT_BASE_FLAG_NOLOCK = 0x01,
-	/** Do not check the EVENT_* environment variables when configuring
-	    an event_base  */
-	EVENT_BASE_FLAG_IGNORE_ENV = 0x02,
-	/** Windows only: enable the IOCP dispatcher at startup
-
-	    If this flag is set then bufferevent_socket_new() and
-	    evconn_listener_new() will use IOCP-backed implementations
-	    instead of the usual select-based one on Windows.
-	 */
-	EVENT_BASE_FLAG_STARTUP_IOCP = 0x04,
-	/** Instead of checking the current time every time the event loop is
-	    ready to run timeout callbacks, check after each timeout callback.
-	 */
-	EVENT_BASE_FLAG_NO_CACHE_TIME = 0x08,
-
-	/** If we are using the epoll backend, this flag says that it is
-	    safe to use Libevent's internal change-list code to batch up
-	    adds and deletes in order to try to do as few syscalls as
-	    possible.  Setting this flag can make your code run faster, but
-	    it may trigger a Linux bug: it is not safe to use this flag
-	    if you have any fds cloned by dup() or its variants.  Doing so
-	    will produce strange and hard-to-diagnose bugs.
-
-	    This flag can also be activated by settnig the
-	    EVENT_EPOLL_USE_CHANGELIST environment variable.
-
-	    This flag has no effect if you wind up using a backend other than
-	    epoll.
-	 */
-	EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST = 0x10
-};
-
-/**
-   Return a bitmask of the features implemented by an event base.  This
-   will be a bitwise OR of one or more of the values of
-   event_method_feature
-
-   @see event_method_feature
- */
-int event_base_get_features(const struct event_base *base);
-
-/**
-   Enters a required event method feature that the application demands.
-
-   Note that not every feature or combination of features is supported
-   on every platform.  Code that requests features should be prepared
-   to handle the case where event_base_new_with_config() returns NULL, as in:
-   <pre>
-     event_config_require_features(cfg, EV_FEATURE_ET);
-     base = event_base_new_with_config(cfg);
-     if (base == NULL) {
-       // We can't get edge-triggered behavior here.
-       event_config_require_features(cfg, 0);
-       base = event_base_new_with_config(cfg);
-     }
-   </pre>
-
-   @param cfg the event configuration object
-   @param feature a bitfield of one or more event_method_feature values.
-          Replaces values from previous calls to this function.
-   @return 0 on success, -1 on failure.
-   @see event_method_feature, event_base_new_with_config()
-*/
-int event_config_require_features(struct event_config *cfg, int feature);
-
-/**
- * Sets one or more flags to configure what parts of the eventual event_base
- * will be initialized, and how they'll work.
- *
- * @see event_base_config_flags, event_base_new_with_config()
- **/
-int event_config_set_flag(struct event_config *cfg, int flag);
-
-/**
- * Records a hint for the number of CPUs in the system. This is used for
- * tuning thread pools, etc, for optimal performance.  In Libevent 2.0,
- * it is only on Windows, and only when IOCP is in use.
- *
- * @param cfg the event configuration object
- * @param cpus the number of cpus
- * @return 0 on success, -1 on failure.
- */
-int event_config_set_num_cpus_hint(struct event_config *cfg, int cpus);
-
-/**
-  Initialize the event API.
-
-  Use event_base_new_with_config() to initialize a new event base, taking
-  the specified configuration under consideration.  The configuration object
-  can currently be used to avoid certain event notification mechanisms.
-
-  @param cfg the event configuration object
-  @return an initialized event_base that can be used to registering events,
-     or NULL if no event base can be created with the requested event_config.
-  @see event_base_new(), event_base_free(), event_init(), event_assign()
-*/
-struct event_base *event_base_new_with_config(const struct event_config *);
-
-/**
-  Deallocate all memory associated with an event_base, and free the base.
-
-  Note that this function will not close any fds or free any memory passed
-  to event_new as the argument to callback.
-
-  @param eb an event_base to be freed
- */
-void event_base_free(struct event_base *);
-
-/** @name Log severities
- */
-/**@{*/
-#define EVENT_LOG_DEBUG 0
-#define EVENT_LOG_MSG   1
-#define EVENT_LOG_WARN  2
-#define EVENT_LOG_ERR   3
-/**@}*/
-
-/* Obsolete names: these are deprecated, but older programs might use them.
- * They violate the reserved-identifier namespace. */
-#define _EVENT_LOG_DEBUG EVENT_LOG_DEBUG
-#define _EVENT_LOG_MSG EVENT_LOG_MSG
-#define _EVENT_LOG_WARN EVENT_LOG_WARN
-#define _EVENT_LOG_ERR EVENT_LOG_ERR
-
-/**
-  A callback function used to intercept Libevent's log messages.
-
-  @see event_set_log_callback
- */
-typedef void (*event_log_cb)(int severity, const char *msg);
-/**
-  Redirect Libevent's log messages.
-
-  @param cb a function taking two arguments: an integer severity between
-     _EVENT_LOG_DEBUG and _EVENT_LOG_ERR, and a string.  If cb is NULL,
-	 then the default log is used.
-
-  NOTE: The function you provide *must not* call any other libevent
-  functionality.  Doing so can produce undefined behavior.
-  */
-void event_set_log_callback(event_log_cb cb);
-
-/**
-   A function to be called if Libevent encounters a fatal internal error.
-
-   @see event_set_fatal_callback
- */
-typedef void (*event_fatal_cb)(int err);
-
-/**
- Override Libevent's behavior in the event of a fatal internal error.
-
- By default, Libevent will call exit(1) if a programming error makes it
- impossible to continue correct operation.  This function allows you to supply
- another callback instead.  Note that if the function is ever invoked,
- something is wrong with your program, or with Libevent: any subsequent calls
- to Libevent may result in undefined behavior.
-
- Libevent will (almost) always log an _EVENT_LOG_ERR message before calling
- this function; look at the last log message to see why Libevent has died.
- */
-void event_set_fatal_callback(event_fatal_cb cb);
-
-/**
-  Associate a different event base with an event.
-
-  The event to be associated must not be currently active or pending.
-
-  @param eb the event base
-  @param ev the event
-  @return 0 on success, -1 on failure.
- */
-int event_base_set(struct event_base *, struct event *);
-
-/** @name Loop flags
-
-    These flags control the behavior of event_base_loop().
- */
-/**@{*/
-/** Block until we have an active event, then exit once all active events
- * have had their callbacks run. */
-#define EVLOOP_ONCE	0x01
-/** Do not block: see which events are ready now, run the callbacks
- * of the highest-priority ones, then exit. */
-#define EVLOOP_NONBLOCK	0x02
-/**@}*/
-
-/**
-  Wait for events to become active, and run their callbacks.
-
-  This is a more flexible version of event_base_dispatch().
-
-  By default, this loop will run the event base until either there are no more
-  pending or active events, or until something calls event_base_loopbreak() or
-  event_base_loopexit().  You can override this behavior with the 'flags'
-  argument.
-
-  @param eb the event_base structure returned by event_base_new() or
-     event_base_new_with_config()
-  @param flags any combination of EVLOOP_ONCE | EVLOOP_NONBLOCK
-  @return 0 if successful, -1 if an error occurred, or 1 if we exited because
-     no events were pending or active.
-  @see event_base_loopexit(), event_base_dispatch(), EVLOOP_ONCE,
-     EVLOOP_NONBLOCK
-  */
-int event_base_loop(struct event_base *, int);
-
-/**
-  Exit the event loop after the specified time
-
-  The next event_base_loop() iteration after the given timer expires will
-  complete normally (handling all queued events) then exit without
-  blocking for events again.
-
-  Subsequent invocations of event_base_loop() will proceed normally.
-
-  @param eb the event_base structure returned by event_init()
-  @param tv the amount of time after which the loop should terminate,
-    or NULL to exit after running all currently active events.
-  @return 0 if successful, or -1 if an error occurred
-  @see event_base_loopbreak()
- */
-int event_base_loopexit(struct event_base *, const struct timeval *);
-
-/**
-  Abort the active event_base_loop() immediately.
-
-  event_base_loop() will abort the loop after the next event is completed;
-  event_base_loopbreak() is typically invoked from this event's callback.
-  This behavior is analogous to the "break;" statement.
-
-  Subsequent invocations of event_loop() will proceed normally.
-
-  @param eb the event_base structure returned by event_init()
-  @return 0 if successful, or -1 if an error occurred
-  @see event_base_loopexit()
- */
-int event_base_loopbreak(struct event_base *);
-
-/**
-  Checks if the event loop was told to exit by event_loopexit().
-
-  This function will return true for an event_base at every point after
-  event_loopexit() is called, until the event loop is next entered.
-
-  @param eb the event_base structure returned by event_init()
-  @return true if event_base_loopexit() was called on this event base,
-    or 0 otherwise
-  @see event_base_loopexit()
-  @see event_base_got_break()
- */
-int event_base_got_exit(struct event_base *);
-
-/**
-  Checks if the event loop was told to abort immediately by event_loopbreak().
-
-  This function will return true for an event_base at every point after
-  event_loopbreak() is called, until the event loop is next entered.
-
-  @param eb the event_base structure returned by event_init()
-  @return true if event_base_loopbreak() was called on this event base,
-    or 0 otherwise
-  @see event_base_loopbreak()
-  @see event_base_got_exit()
- */
-int event_base_got_break(struct event_base *);
-
-/**
- * @name event flags
- *
- * Flags to pass to event_new(), event_assign(), event_pending(), and
- * anything else with an argument of the form "short events"
- */
-/**@{*/
-/** Indicates that a timeout has occurred.  It's not necessary to pass
- * this flag to event_for new()/event_assign() to get a timeout. */
-#define EV_TIMEOUT	0x01
-/** Wait for a socket or FD to become readable */
-#define EV_READ		0x02
-/** Wait for a socket or FD to become writeable */
-#define EV_WRITE	0x04
-/** Wait for a POSIX signal to be raised*/
-#define EV_SIGNAL	0x08
-/**
- * Persistent event: won't get removed automatically when activated.
- *
- * When a persistent event with a timeout becomes activated, its timeout
- * is reset to 0.
- */
-#define EV_PERSIST	0x10
-/** Select edge-triggered behavior, if supported by the backend. */
-#define EV_ET       0x20
-/**@}*/
-
-/**
-   @name evtimer_* macros
-
-    Aliases for working with one-shot timer events */
-/**@{*/
-#define evtimer_assign(ev, b, cb, arg) \
-	event_assign((ev), (b), -1, 0, (cb), (arg))
-#define evtimer_new(b, cb, arg)	       event_new((b), -1, 0, (cb), (arg))
-#define evtimer_add(ev, tv)		event_add((ev), (tv))
-#define evtimer_del(ev)			event_del(ev)
-#define evtimer_pending(ev, tv)		event_pending((ev), EV_TIMEOUT, (tv))
-#define evtimer_initialized(ev)		event_initialized(ev)
-/**@}*/
-
-/**
-   @name evsignal_* macros
-
-   Aliases for working with signal events
- */
-/**@{*/
-#define evsignal_add(ev, tv)		event_add((ev), (tv))
-#define evsignal_assign(ev, b, x, cb, arg)			\
-	event_assign((ev), (b), (x), EV_SIGNAL|EV_PERSIST, cb, (arg))
-#define evsignal_new(b, x, cb, arg)				\
-	event_new((b), (x), EV_SIGNAL|EV_PERSIST, (cb), (arg))
-#define evsignal_del(ev)		event_del(ev)
-#define evsignal_pending(ev, tv)	event_pending((ev), EV_SIGNAL, (tv))
-#define evsignal_initialized(ev)	event_initialized(ev)
-/**@}*/
-
-/**
-   A callback function for an event.
-
-   It receives three arguments:
-
-   @param fd An fd or signal
-   @param events One or more EV_* flags
-   @param arg A user-supplied argument.
-
-   @see event_new()
- */
-typedef void (*event_callback_fn)(evutil_socket_t, short, void *);
-
-/**
-  Allocate and asssign a new event structure, ready to be added.
-
-  The function event_new() returns a new event that can be used in
-  future calls to event_add() and event_del().  The fd and events
-  arguments determine which conditions will trigger the event; the
-  callback and callback_arg arguments tell Libevent what to do when the
-  event becomes active.
-
-  If events contains one of EV_READ, EV_WRITE, or EV_READ|EV_WRITE, then
-  fd is a file descriptor or socket that should get monitored for
-  readiness to read, readiness to write, or readiness for either operation
-  (respectively).  If events contains EV_SIGNAL, then fd is a signal
-  number to wait for.  If events contains none of those flags, then the
-  event can be triggered only by a timeout or by manual activation with
-  event_active(): In this case, fd must be -1.
-
-  The EV_PERSIST flag can also be passed in the events argument: it makes
-  event_add() persistent until event_del() is called.
-
-  The EV_ET flag is compatible with EV_READ and EV_WRITE, and supported
-  only by certain backends.  It tells Libevent to use edge-triggered
-  events.
-
-  The EV_TIMEOUT flag has no effect here.
-
-  It is okay to have multiple events all listening on the same fds; but
-  they must either all be edge-triggered, or all not be edge triggerd.
-
-  When the event becomes active, the event loop will run the provided
-  callbuck function, with three arguments.  The first will be the provided
-  fd value.  The second will be a bitfield of the events that triggered:
-  EV_READ, EV_WRITE, or EV_SIGNAL.  Here the EV_TIMEOUT flag indicates
-  that a timeout occurred, and EV_ET indicates that an edge-triggered
-  event occurred.  The third event will be the callback_arg pointer that
-  you provide.
-
-  @param base the event base to which the event should be attached.
-  @param fd the file descriptor or signal to be monitored, or -1.
-  @param events desired events to monitor: bitfield of EV_READ, EV_WRITE,
-      EV_SIGNAL, EV_PERSIST, EV_ET.
-  @param callback callback function to be invoked when the event occurs
-  @param callback_arg an argument to be passed to the callback function
-
-  @return a newly allocated struct event that must later be freed with
-    event_free().
-  @see event_free(), event_add(), event_del(), event_assign()
- */
-struct event *event_new(struct event_base *, evutil_socket_t, short, event_callback_fn, void *);
-
-
-/**
-  Prepare a new, already-allocated event structure to be added.
-
-  The function event_assign() prepares the event structure ev to be used
-  in future calls to event_add() and event_del().  Unlike event_new(), it
-  doesn't allocate memory itself: it requires that you have already
-  allocated a struct event, probably on the heap.  Doing this will
-  typically make your code depend on the size of the event structure, and
-  thereby create incompatibility with future versions of Libevent.
-
-  The easiest way to avoid this problem is just to use event_new() and
-  event_free() instead.
-
-  A slightly harder way to future-proof your code is to use
-  event_get_struct_event_size() to determine the required size of an event
-  at runtime.
-
-  Note that it is NOT safe to call this function on an event that is
-  active or pending.  Doing so WILL corrupt internal data structures in
-  Libevent, and lead to strange, hard-to-diagnose bugs.  You _can_ use
-  event_assign to change an existing event, but only if it is not active
-  or pending!
-
-  The arguments for this function, and the behavior of the events that it
-  makes, are as for event_new().
-
-  @param ev an event struct to be modified
-  @param base the event base to which ev should be attached.
-  @param fd the file descriptor to be monitored
-  @param events desired events to monitor; can be EV_READ and/or EV_WRITE
-  @param callback callback function to be invoked when the event occurs
-  @param callback_arg an argument to be passed to the callback function
-
-  @return 0 if success, or -1 on invalid arguments.
-
-  @see event_new(), event_add(), event_del(), event_base_once(),
-    event_get_struct_event_size()
-  */
-int event_assign(struct event *, struct event_base *, evutil_socket_t, short, event_callback_fn, void *);
-
-/**
-   Deallocate a struct event * returned by event_new().
-
-   If the event is pending or active, first make it non-pending and
-   non-active.
- */
-void event_free(struct event *);
-
-/**
-  Schedule a one-time event
-
-  The function event_base_once() is similar to event_set().  However, it
-  schedules a callback to be called exactly once, and does not require the
-  caller to prepare an event structure.
-
-  Note that in Libevent 2.0 and earlier, if the event is never triggered,
-  the internal memory used to hold it will never be freed.  This may be
-  fixed in a later version of Libevent.
-
-  @param base an event_base
-  @param fd a file descriptor to monitor, or -1 for no fd.
-  @param events event(s) to monitor; can be any of EV_READ |
-         EV_WRITE, or EV_TIMEOUT
-  @param callback callback function to be invoked when the event occurs
-  @param arg an argument to be passed to the callback function
-  @param timeout the maximum amount of time to wait for the event. NULL
-         makes an EV_READ/EV_WRITE event make forever; NULL makes an
-        EV_TIMEOUT event succees immediately.
-  @return 0 if successful, or -1 if an error occurred
- */
-int event_base_once(struct event_base *, evutil_socket_t, short, event_callback_fn, void *, const struct timeval *);
-
-/**
-  Add an event to the set of pending events.
-
-  The function event_add() schedules the execution of the ev event when the
-  event specified in event_assign()/event_new() occurs, or when the time
-  specified in timeout has elapesed.  If atimeout is NULL, no timeout
-  occurs and the function will only be
-  called if a matching event occurs.  The event in the
-  ev argument must be already initialized by event_assign() or event_new()
-  and may not be used
-  in calls to event_assign() until it is no longer pending.
-
-  If the event in the ev argument already has a scheduled timeout, calling
-  event_add() replaces the old timeout with the new one, or clears the old
-  timeout if the timeout argument is NULL.
-
-  @param ev an event struct initialized via event_set()
-  @param timeout the maximum amount of time to wait for the event, or NULL
-         to wait forever
-  @return 0 if successful, or -1 if an error occurred
-  @see event_del(), event_assign(), event_new()
-  */
-int event_add(struct event *ev, const struct timeval *timeout);
-
-/**
-  Remove an event from the set of monitored events.
-
-  The function event_del() will cancel the event in the argument ev.  If the
-  event has already executed or has never been added the call will have no
-  effect.
-
-  @param ev an event struct to be removed from the working set
-  @return 0 if successful, or -1 if an error occurred
-  @see event_add()
- */
-int event_del(struct event *);
-
-
-/**
-  Make an event active.
-
-  You can use this function on a pending or a non-pending event to make it
-  active, so that its callback will be run by event_base_dispatch() or
-  event_base_loop().
-
-  One common use in multithreaded programs is to wake the thread running
-  event_base_loop() from another thread.
-
-  @param ev an event to make active.
-  @param res a set of flags to pass to the event's callback.
-  @param ncalls an obsolete argument: this is ignored.
- **/
-void event_active(struct event *ev, int res, short ncalls);
-
-/**
-  Checks if a specific event is pending or scheduled.
-
-  @param ev an event struct previously passed to event_add()
-  @param events the requested event type; any of EV_TIMEOUT|EV_READ|
-         EV_WRITE|EV_SIGNAL
-  @param tv if this field is not NULL, and the event has a timeout,
-         this field is set to hold the time at which the timeout will
-	 expire.
-
-  @return true if the event is pending on any of the events in 'what', (that
-  is to say, it has been added), or 0 if the event is not added.
- */
-int event_pending(const struct event *ev, short events, struct timeval *tv);
-
-
-/**
-  Test if an event structure might be initialized.
-
-  The event_initialized() function can be used to check if an event has been
-  initialized.
-
-  Warning: This function is only useful for distinguishing a a zeroed-out
-    piece of memory from an initialized event, it can easily be confused by
-    uninitialized memory.  Thus, it should ONLY be used to distinguish an
-    initialized event from zero.
-
-  @param ev an event structure to be tested
-  @return 1 if the structure might be initialized, or 0 if it has not been
-          initialized
- */
-int event_initialized(const struct event *ev);
-
-/**
-   Get the signal number assigned to a signal event
-*/
-#define event_get_signal(ev) ((int)event_get_fd(ev))
-
-/**
-   Get the socket or signal assigned to an event, or -1 if the event has
-   no socket.
-*/
-evutil_socket_t event_get_fd(const struct event *ev);
-
-/**
-   Get the event_base associated with an event.
-*/
-struct event_base *event_get_base(const struct event *ev);
-
-/**
-   Return the events (EV_READ, EV_WRITE, etc) assigned to an event.
-*/
-short event_get_events(const struct event *ev);
-
-/**
-   Return the callback assigned to an event.
-*/
-event_callback_fn event_get_callback(const struct event *ev);
-
-/**
-   Return the callback argument assigned to an event.
-*/
-void *event_get_callback_arg(const struct event *ev);
-
-/**
-   Extract _all_ of arguments given to construct a given event.  The
-   event_base is copied into *base_out, the fd is copied into *fd_out, and so
-   on.
-
-   If any of the "_out" arguments is NULL, it will be ignored.
- */
-void event_get_assignment(const struct event *event,
-    struct event_base **base_out, evutil_socket_t *fd_out, short *events_out,
-    event_callback_fn *callback_out, void **arg_out);
-
-/**
-   Return the size of struct event that the Libevent library was compiled
-   with.
-
-   This will be NO GREATER than sizeof(struct event) if you're running with
-   the same version of Libevent that your application was built with, but
-   otherwise might not.
-
-   Note that it might be SMALLER than sizeof(struct event) if some future
-   version of Libevent adds extra padding to the end of struct event.
-   We might do this to help ensure ABI-compatibility between different
-   versions of Libevent.
- */
-size_t event_get_struct_event_size(void);
-
-/**
-   Get the Libevent version.
-
-   Note that this will give you the version of the library that you're
-   currently linked against, not the version of the headers that you've
-   compiled against.
-
-   @return a string containing the version number of Libevent
-*/
-const char *event_get_version(void);
-
-/**
-   Return a numeric representation of Libevent's version.
-
-   Note that this will give you the version of the library that you're
-   currently linked against, not the version of the headers you've used to
-   compile.
-
-   The format uses one byte each for the major, minor, and patchlevel parts of
-   the version number.  The low-order byte is unused.  For example, version
-   2.0.1-alpha has a numeric representation of 0x02000100
-*/
-ev_uint32_t event_get_version_number(void);
-
-/** As event_get_version, but gives the version of Libevent's headers. */
-#define LIBEVENT_VERSION _EVENT_VERSION
-/** As event_get_version_number, but gives the version number of Libevent's
- * headers. */
-#define LIBEVENT_VERSION_NUMBER _EVENT_NUMERIC_VERSION
-
-/** Largest number of priorities that Libevent can support. */
-#define EVENT_MAX_PRIORITIES 256
-/**
-  Set the number of different event priorities
-
-  By default Libevent schedules all active events with the same priority.
-  However, some time it is desirable to process some events with a higher
-  priority than others.  For that reason, Libevent supports strict priority
-  queues.  Active events with a lower priority are always processed before
-  events with a higher priority.
-
-  The number of different priorities can be set initially with the
-  event_base_priority_init() function.  This function should be called
-  before the first call to event_base_dispatch().  The
-  event_priority_set() function can be used to assign a priority to an
-  event.  By default, Libevent assigns the middle priority to all events
-  unless their priority is explicitly set.
-
-  Note that urgent-priority events can starve less-urgent events: after
-  running all urgent-priority callbacks, Libevent checks for more urgent
-  events again, before running less-urgent events.  Less-urgent events
-  will not have their callbacks run until there are no events more urgent
-  than them that want to be active.
-
-  @param eb the event_base structure returned by event_base_new()
-  @param npriorities the maximum number of priorities
-  @return 0 if successful, or -1 if an error occurred
-  @see event_priority_set()
- */
-int	event_base_priority_init(struct event_base *, int);
-
-/**
-  Assign a priority to an event.
-
-  @param ev an event struct
-  @param priority the new priority to be assigned
-  @return 0 if successful, or -1 if an error occurred
-  @see event_priority_init()
-  */
-int	event_priority_set(struct event *, int);
-
-/**
-   Prepare an event_base to use a large number of timeouts with the same
-   duration.
-
-   Libevent's default scheduling algorithm is optimized for having a large
-   number of timeouts with their durations more or less randomly
-   distributed.  But if you have a large number of timeouts that all have
-   the same duration (for example, if you have a large number of
-   connections that all have a 10-second timeout), then you can improve
-   Libevent's performance by telling Libevent about it.
-
-   To do this, call this function with the common duration.  It will return a
-   pointer to a different, opaque timeout value.  (Don't depend on its actual
-   contents!)  When you use this timeout value in event_add(), Libevent will
-   schedule the event more efficiently.
-
-   (This optimization probably will not be worthwhile until you have thousands
-   or tens of thousands of events with the same timeout.)
- */
-const struct timeval *event_base_init_common_timeout(struct event_base *base,
-    const struct timeval *duration);
-
-#if !defined(_EVENT_DISABLE_MM_REPLACEMENT) || defined(_EVENT_IN_DOXYGEN)
-/**
- Override the functions that Libevent uses for memory management.
-
- Usually, Libevent uses the standard libc functions malloc, realloc, and
- free to allocate memory.  Passing replacements for those functions to
- event_set_mem_functions() overrides this behavior.
-
- Note that all memory returned from Libevent will be allocated by the
- replacement functions rather than by malloc() and realloc().  Thus, if you
- have replaced those functions, it will not be appropriate to free() memory
- that you get from Libevent.  Instead, you must use the free_fn replacement
- that you provided.
-
- Note also that if you are going to call this function, you should do so
- before any call to any Libevent function that does allocation.
- Otherwise, those funtions will allocate their memory using malloc(), but
- then later free it using your provided free_fn.
-
- @param malloc_fn A replacement for malloc.
- @param realloc_fn A replacement for realloc
- @param free_fn A replacement for free.
- **/
-void event_set_mem_functions(
-	void *(*malloc_fn)(size_t sz),
-	void *(*realloc_fn)(void *ptr, size_t sz),
-	void (*free_fn)(void *ptr));
-/** This definition is present if Libevent was built with support for
-    event_set_mem_functions() */
-#define EVENT_SET_MEM_FUNCTIONS_IMPLEMENTED
-#endif
-
-void event_base_dump_events(struct event_base *, FILE *);
-
-/** Sets 'tv' to the current time (as returned by gettimeofday()),
-    looking at the cached value in 'base' if possible, and calling
-    gettimeofday() or clock_gettime() as appropriate if there is no
-    cached time.
-
-    Generally, this value will only be cached while actually
-    processing event callbacks, and may be very inaccuate if your
-    callbacks take a long time to execute.
-
-    Returns 0 on success, negative on failure.
- */
-int event_base_gettimeofday_cached(struct event_base *base,
-    struct timeval *tv);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _EVENT2_EVENT_H_ */
+/*
+ * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
+ * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EVENT2_EVENT_H_INCLUDED_
+#define EVENT2_EVENT_H_INCLUDED_
+
+/**
+   @mainpage
+
+  @section intro Introduction
+
+  Libevent is an event notification library for developing scalable network
+  servers.  The Libevent API provides a mechanism to execute a callback
+  function when a specific event occurs on a file descriptor or after a
+  timeout has been reached. Furthermore, Libevent also support callbacks due
+  to signals or regular timeouts.
+
+  Libevent is meant to replace the event loop found in event driven network
+  servers. An application just needs to call event_base_dispatch() and then add or
+  remove events dynamically without having to change the event loop.
+
+
+  Currently, Libevent supports /dev/poll, kqueue(2), select(2), poll(2),
+  epoll(4), and evports. The internal event mechanism is completely
+  independent of the exposed event API, and a simple update of Libevent can
+  provide new functionality without having to redesign the applications. As a
+  result, Libevent allows for portable application development and provides
+  the most scalable event notification mechanism available on an operating
+  system.  Libevent can also be used for multithreaded programs.  Libevent
+  should compile on Linux, *BSD, Mac OS X, Solaris and, Windows.
+
+  @section usage Standard usage
+
+  Every program that uses Libevent must include the <event2/event.h>
+  header, and pass the -levent flag to the linker.  (You can instead link
+  -levent_core if you only want the main event and buffered IO-based code,
+  and don't want to link any protocol code.)
+
+  @section setup Library setup
+
+  Before you call any other Libevent functions, you need to set up the
+  library.  If you're going to use Libevent from multiple threads in a
+  multithreaded application, you need to initialize thread support --
+  typically by using evthread_use_pthreads() or
+  evthread_use_windows_threads().  See <event2/thread.h> for more
+  information.
+
+  This is also the point where you can replace Libevent's memory
+  management functions with event_set_mem_functions, and enable debug mode
+  with event_enable_debug_mode().
+
+  @section base Creating an event base
+
+  Next, you need to create an event_base structure, using event_base_new()
+  or event_base_new_with_config().  The event_base is responsible for
+  keeping track of which events are "pending" (that is to say, being
+  watched to see if they become active) and which events are "active".
+  Every event is associated with a single event_base.
+
+  @section event Event notification
+
+  For each file descriptor that you wish to monitor, you must create an
+  event structure with event_new().  (You may also declare an event
+  structure and call event_assign() to initialize the members of the
+  structure.)  To enable notification, you add the structure to the list
+  of monitored events by calling event_add().  The event structure must
+  remain allocated as long as it is active, so it should generally be
+  allocated on the heap.
+
+  @section loop Dispatching events.
+
+  Finally, you call event_base_dispatch() to loop and dispatch events.
+  You can also use event_base_loop() for more fine-grained control.
+
+  Currently, only one thread can be dispatching a given event_base at a
+  time.  If you want to run events in multiple threads at once, you can
+  either have a single event_base whose events add work to a work queue,
+  or you can create multiple event_base objects.
+
+  @section bufferevent I/O Buffers
+
+  Libevent provides a buffered I/O abstraction on top of the regular event
+  callbacks. This abstraction is called a bufferevent. A bufferevent
+  provides input and output buffers that get filled and drained
+  automatically. The user of a buffered event no longer deals directly
+  with the I/O, but instead is reading from input and writing to output
+  buffers.
+
+  Once initialized via bufferevent_socket_new(), the bufferevent structure
+  can be used repeatedly with bufferevent_enable() and
+  bufferevent_disable().  Instead of reading and writing directly to a
+  socket, you would call bufferevent_read() and bufferevent_write().
+
+  When read enabled the bufferevent will try to read from the file descriptor
+  and call the read callback. The write callback is executed whenever the
+  output buffer is drained below the write low watermark, which is 0 by
+  default.
+
+  See <event2/bufferevent*.h> for more information.
+
+  @section timers Timers
+
+  Libevent can also be used to create timers that invoke a callback after a
+  certain amount of time has expired. The evtimer_new() macro returns
+  an event struct to use as a timer. To activate the timer, call
+  evtimer_add(). Timers can be deactivated by calling evtimer_del().
+  (These macros are thin wrappers around event_new(), event_add(),
+  and event_del(); you can also use those instead.)
+
+  @section evdns Asynchronous DNS resolution
+
+  Libevent provides an asynchronous DNS resolver that should be used instead
+  of the standard DNS resolver functions.  See the <event2/dns.h>
+  functions for more detail.
+
+  @section evhttp Event-driven HTTP servers
+
+  Libevent provides a very simple event-driven HTTP server that can be
+  embedded in your program and used to service HTTP requests.
+
+  To use this capability, you need to include the <event2/http.h> header in your
+  program.  See that header for more information.
+
+  @section evrpc A framework for RPC servers and clients
+
+  Libevent provides a framework for creating RPC servers and clients.  It
+  takes care of marshaling and unmarshaling all data structures.
+
+  @section api API Reference
+
+  To browse the complete documentation of the libevent API, click on any of
+  the following links.
+
+  event2/event.h
+  The primary libevent header
+
+  event2/thread.h
+  Functions for use by multithreaded programs
+
+  event2/buffer.h and event2/bufferevent.h
+  Buffer management for network reading and writing
+
+  event2/util.h
+  Utility functions for portable nonblocking network code
+
+  event2/dns.h
+  Asynchronous DNS resolution
+
+  event2/http.h
+  An embedded libevent-based HTTP server
+
+  event2/rpc.h
+  A framework for creating RPC servers and clients
+
+ */
+
+/** @file event2/event.h
+
+  Core functions for waiting for and receiving events, and using event bases.
+*/
+
+#include <event2/visibility.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <event2/event-config.h>
+#ifdef EVENT__HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef EVENT__HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+
+#include <stdio.h>
+
+/* For int types. */
+#include <event2/util.h>
+
+/**
+ * Structure to hold information and state for a Libevent dispatch loop.
+ *
+ * The event_base lies at the center of Libevent; every application will
+ * have one.  It keeps track of all pending and active events, and
+ * notifies your application of the active ones.
+ *
+ * This is an opaque structure; you can allocate one using
+ * event_base_new() or event_base_new_with_config().
+ *
+ * @see event_base_new(), event_base_free(), event_base_loop(),
+ *    event_base_new_with_config()
+ */
+struct event_base
+#ifdef EVENT_IN_DOXYGEN_
+{/*Empty body so that doxygen will generate documentation here.*/}
+#endif
+;
+
+/**
+ * @struct event
+ *
+ * Structure to represent a single event.
+ *
+ * An event can have some underlying condition it represents: a socket
+ * becoming readable or writeable (or both), or a signal becoming raised.
+ * (An event that represents no underlying condition is still useful: you
+ * can use one to implement a timer, or to communicate between threads.)
+ *
+ * Generally, you can create events with event_new(), then make them
+ * pending with event_add().  As your event_base runs, it will run the
+ * callbacks of an events whose conditions are triggered.  When you
+ * longer want the event, free it with event_free().
+ *
+ * In more depth:
+ *
+ * An event may be "pending" (one whose condition we are watching),
+ * "active" (one whose condition has triggered and whose callback is about
+ * to run), neither, or both.  Events come into existence via
+ * event_assign() or event_new(), and are then neither active nor pending.
+ *
+ * To make an event pending, pass it to event_add().  When doing so, you
+ * can also set a timeout for the event.
+ *
+ * Events become active during an event_base_loop() call when either their
+ * condition has triggered, or when their timeout has elapsed.  You can
+ * also activate an event manually using event_active().  The even_base
+ * loop will run the callbacks of active events; after it has done so, it
+ * marks them as no longer active.
+ *
+ * You can make an event non-pending by passing it to event_del().  This
+ * also makes the event non-active.
+ *
+ * Events can be "persistent" or "non-persistent".  A non-persistent event
+ * becomes non-pending as soon as it is triggered: thus, it only runs at
+ * most once per call to event_add().  A persistent event remains pending
+ * even when it becomes active: you'll need to event_del() it manually in
+ * order to make it non-pending.  When a persistent event with a timeout
+ * becomes active, its timeout is reset: this means you can use persistent
+ * events to implement periodic timeouts.
+ *
+ * This should be treated as an opaque structure; you should never read or
+ * write any of its fields directly.  For backward compatibility with old
+ * code, it is defined in the event2/event_struct.h header; including this
+ * header may make your code incompatible with other versions of Libevent.
+ *
+ * @see event_new(), event_free(), event_assign(), event_get_assignment(),
+ *    event_add(), event_del(), event_active(), event_pending(),
+ *    event_get_fd(), event_get_base(), event_get_events(),
+ *    event_get_callback(), event_get_callback_arg(),
+ *    event_priority_set()
+ */
+struct event
+#ifdef EVENT_IN_DOXYGEN_
+{/*Empty body so that doxygen will generate documentation here.*/}
+#endif
+;
+
+/**
+ * Configuration for an event_base.
+ *
+ * There are many options that can be used to alter the behavior and
+ * implementation of an event_base.  To avoid having to pass them all in a
+ * complex many-argument constructor, we provide an abstract data type
+ * wrhere you set up configation information before passing it to
+ * event_base_new_with_config().
+ *
+ * @see event_config_new(), event_config_free(), event_base_new_with_config(),
+ *   event_config_avoid_method(), event_config_require_features(),
+ *   event_config_set_flag(), event_config_set_num_cpus_hint()
+ */
+struct event_config
+#ifdef EVENT_IN_DOXYGEN_
+{/*Empty body so that doxygen will generate documentation here.*/}
+#endif
+;
+
+/**
+ * Enable some relatively expensive debugging checks in Libevent that
+ * would normally be turned off.  Generally, these checks cause code that
+ * would otherwise crash mysteriously to fail earlier with an assertion
+ * failure.  Note that this method MUST be called before any events or
+ * event_bases have been created.
+ *
+ * Debug mode can currently catch the following errors:
+ *    An event is re-assigned while it is added
+ *    Any function is called on a non-assigned event
+ *
+ * Note that debugging mode uses memory to track every event that has been
+ * initialized (via event_assign, event_set, or event_new) but not yet
+ * released (via event_free or event_debug_unassign).  If you want to use
+ * debug mode, and you find yourself running out of memory, you will need
+ * to use event_debug_unassign to explicitly stop tracking events that
+ * are no longer considered set-up.
+ *
+ * @see event_debug_unassign()
+ */
+EVENT2_EXPORT_SYMBOL
+void event_enable_debug_mode(void);
+
+/**
+ * When debugging mode is enabled, informs Libevent that an event should no
+ * longer be considered as assigned. When debugging mode is not enabled, does
+ * nothing.
+ *
+ * This function must only be called on a non-added event.
+ *
+ * @see event_enable_debug_mode()
+ */
+EVENT2_EXPORT_SYMBOL
+void event_debug_unassign(struct event *);
+
+/**
+ * Create and return a new event_base to use with the rest of Libevent.
+ *
+ * @return a new event_base on success, or NULL on failure.
+ *
+ * @see event_base_free(), event_base_new_with_config()
+ */
+EVENT2_EXPORT_SYMBOL
+struct event_base *event_base_new(void);
+
+/**
+  Reinitialize the event base after a fork
+
+  Some event mechanisms do not survive across fork.   The event base needs
+  to be reinitialized with the event_reinit() function.
+
+  @param base the event base that needs to be re-initialized
+  @return 0 if successful, or -1 if some events could not be re-added.
+  @see event_base_new()
+*/
+EVENT2_EXPORT_SYMBOL
+int event_reinit(struct event_base *base);
+
+/**
+   Event dispatching loop
+
+  This loop will run the event base until either there are no more pending or
+  active, or until something calls event_base_loopbreak() or
+  event_base_loopexit().
+
+  @param base the event_base structure returned by event_base_new() or
+     event_base_new_with_config()
+  @return 0 if successful, -1 if an error occurred, or 1 if we exited because
+     no events were pending or active.
+  @see event_base_loop()
+ */
+EVENT2_EXPORT_SYMBOL
+int event_base_dispatch(struct event_base *);
+
+/**
+ Get the kernel event notification mechanism used by Libevent.
+
+ @param eb the event_base structure returned by event_base_new()
+ @return a string identifying the kernel event mechanism (kqueue, epoll, etc.)
+ */
+EVENT2_EXPORT_SYMBOL
+const char *event_base_get_method(const struct event_base *);
+
+/**
+   Gets all event notification mechanisms supported by Libevent.
+
+   This functions returns the event mechanism in order preferred by
+   Libevent.  Note that this list will include all backends that
+   Libevent has compiled-in support for, and will not necessarily check
+   your OS to see whether it has the required resources.
+
+   @return an array with pointers to the names of support methods.
+     The end of the array is indicated by a NULL pointer.  If an
+     error is encountered NULL is returned.
+*/
+EVENT2_EXPORT_SYMBOL
+const char **event_get_supported_methods(void);
+
+/** Query the current monotonic time from a the timer for a struct
+ * event_base.
+ */
+EVENT2_EXPORT_SYMBOL
+int event_gettime_monotonic(struct event_base *base, struct timeval *tp);
+
+/**
+   @name event type flag
+
+   Flags to pass to event_base_get_num_events() to specify the kinds of events
+   we want to aggregate counts for
+*/
+/**@{*/
+/** count the number of active events, which have been triggered.*/
+#define EVENT_BASE_COUNT_ACTIVE                1U
+/** count the number of virtual events, which is used to represent an internal
+ * condition, other than a pending event, that keeps the loop from exiting. */
+#define EVENT_BASE_COUNT_VIRTUAL       2U
+/** count the number of events which have been added to event base, including
+ * internal events. */
+#define EVENT_BASE_COUNT_ADDED         4U
+/**@}*/
+
+/**
+   Gets the number of events in event_base, as specified in the flags.
+
+   Since event base has some internal events added to make some of its
+   functionalities work, EVENT_BASE_COUNT_ADDED may return more than the
+   number of events you added using event_add().
+
+   If you pass EVENT_BASE_COUNT_ACTIVE and EVENT_BASE_COUNT_ADDED together, an
+   active event will be counted twice. However, this might not be the case in
+   future libevent versions.  The return value is an indication of the work
+   load, but the user shouldn't rely on the exact value as this may change in
+   the future.
+
+   @param eb the event_base structure returned by event_base_new()
+   @param flags a bitwise combination of the kinds of events to aggregate
+       counts for
+   @return the number of events specified in the flags
+*/
+EVENT2_EXPORT_SYMBOL
+int event_base_get_num_events(struct event_base *, unsigned int);
+
+/**
+  Get the maximum number of events in a given event_base as specified in the
+  flags.
+
+  @param eb the event_base structure returned by event_base_new()
+  @param flags a bitwise combination of the kinds of events to aggregate
+         counts for
+  @param clear option used to reset the maximum count.
+  @return the number of events specified in the flags
+ */
+EVENT2_EXPORT_SYMBOL
+int event_base_get_max_events(struct event_base *, unsigned int, int);
+
+/**
+   Allocates a new event configuration object.
+
+   The event configuration object can be used to change the behavior of
+   an event base.
+
+   @return an event_config object that can be used to store configuration, or
+     NULL if an error is encountered.
+   @see event_base_new_with_config(), event_config_free(), event_config
+*/
+EVENT2_EXPORT_SYMBOL
+struct event_config *event_config_new(void);
+
+/**
+   Deallocates all memory associated with an event configuration object
+
+   @param cfg the event configuration object to be freed.
+*/
+EVENT2_EXPORT_SYMBOL
+void event_config_free(struct event_config *cfg);
+
+/**
+   Enters an event method that should be avoided into the configuration.
+
+   This can be used to avoid event mechanisms that do not support certain
+   file descriptor types, or for debugging to avoid certain event
+   mechanisms.  An application can make use of multiple event bases to
+   accommodate incompatible file descriptor types.
+
+   @param cfg the event configuration object
+   @param method the name of the event method to avoid
+   @return 0 on success, -1 on failure.
+*/
+EVENT2_EXPORT_SYMBOL
+int event_config_avoid_method(struct event_config *cfg, const char *method);
+
+/**
+   A flag used to describe which features an event_base (must) provide.
+
+   Because of OS limitations, not every Libevent backend supports every
+   possible feature.  You can use this type with
+   event_config_require_features() to tell Libevent to only proceed if your
+   event_base implements a given feature, and you can receive this type from
+   event_base_get_features() to see which features are available.
+*/
+enum event_method_feature {
+    /** Require an event method that allows edge-triggered events with EV_ET. */
+    EV_FEATURE_ET = 0x01,
+    /** Require an event method where having one event triggered among
+     * many is [approximately] an O(1) operation. This excludes (for
+     * example) select and poll, which are approximately O(N) for N
+     * equal to the total number of possible events. */
+    EV_FEATURE_O1 = 0x02,
+    /** Require an event method that allows file descriptors as well as
+     * sockets. */
+    EV_FEATURE_FDS = 0x04,
+    /** Require an event method that allows you to use EV_CLOSED to detect
+     * connection close without the necessity of reading all the pending data.
+     *
+     * Methods that do support EV_CLOSED may not be able to provide support on
+     * all kernel versions.
+     **/
+    EV_FEATURE_EARLY_CLOSE = 0x08
+};
+
+/**
+   A flag passed to event_config_set_flag().
+
+    These flags change the behavior of an allocated event_base.
+
+    @see event_config_set_flag(), event_base_new_with_config(),
+       event_method_feature
+ */
+enum event_base_config_flag {
+	/** Do not allocate a lock for the event base, even if we have
+	    locking set up.
+
+	    Setting this option will make it unsafe and nonfunctional to call
+	    functions on the base concurrently from multiple threads.
+	*/
+	EVENT_BASE_FLAG_NOLOCK = 0x01,
+	/** Do not check the EVENT_* environment variables when configuring
+	    an event_base  */
+	EVENT_BASE_FLAG_IGNORE_ENV = 0x02,
+	/** Windows only: enable the IOCP dispatcher at startup
+
+	    If this flag is set then bufferevent_socket_new() and
+	    evconn_listener_new() will use IOCP-backed implementations
+	    instead of the usual select-based one on Windows.
+	 */
+	EVENT_BASE_FLAG_STARTUP_IOCP = 0x04,
+	/** Instead of checking the current time every time the event loop is
+	    ready to run timeout callbacks, check after each timeout callback.
+	 */
+	EVENT_BASE_FLAG_NO_CACHE_TIME = 0x08,
+
+	/** If we are using the epoll backend, this flag says that it is
+	    safe to use Libevent's internal change-list code to batch up
+	    adds and deletes in order to try to do as few syscalls as
+	    possible.  Setting this flag can make your code run faster, but
+	    it may trigger a Linux bug: it is not safe to use this flag
+	    if you have any fds cloned by dup() or its variants.  Doing so
+	    will produce strange and hard-to-diagnose bugs.
+
+	    This flag can also be activated by setting the
+	    EVENT_EPOLL_USE_CHANGELIST environment variable.
+
+	    This flag has no effect if you wind up using a backend other than
+	    epoll.
+	 */
+	EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST = 0x10,
+
+	/** Ordinarily, Libevent implements its time and timeout code using
+	    the fastest monotonic timer that we have.  If this flag is set,
+	    however, we use less efficient more precise timer, assuming one is
+	    present.
+	 */
+	EVENT_BASE_FLAG_PRECISE_TIMER = 0x20
+};
+
+/**
+   Return a bitmask of the features implemented by an event base.  This
+   will be a bitwise OR of one or more of the values of
+   event_method_feature
+
+   @see event_method_feature
+ */
+EVENT2_EXPORT_SYMBOL
+int event_base_get_features(const struct event_base *base);
+
+/**
+   Enters a required event method feature that the application demands.
+
+   Note that not every feature or combination of features is supported
+   on every platform.  Code that requests features should be prepared
+   to handle the case where event_base_new_with_config() returns NULL, as in:
+   <pre>
+     event_config_require_features(cfg, EV_FEATURE_ET);
+     base = event_base_new_with_config(cfg);
+     if (base == NULL) {
+       // We can't get edge-triggered behavior here.
+       event_config_require_features(cfg, 0);
+       base = event_base_new_with_config(cfg);
+     }
+   </pre>
+
+   @param cfg the event configuration object
+   @param feature a bitfield of one or more event_method_feature values.
+          Replaces values from previous calls to this function.
+   @return 0 on success, -1 on failure.
+   @see event_method_feature, event_base_new_with_config()
+*/
+EVENT2_EXPORT_SYMBOL
+int event_config_require_features(struct event_config *cfg, int feature);
+
+/**
+ * Sets one or more flags to configure what parts of the eventual event_base
+ * will be initialized, and how they'll work.
+ *
+ * @see event_base_config_flags, event_base_new_with_config()
+ **/
+EVENT2_EXPORT_SYMBOL
+int event_config_set_flag(struct event_config *cfg, int flag);
+
+/**
+ * Records a hint for the number of CPUs in the system. This is used for
+ * tuning thread pools, etc, for optimal performance.  In Libevent 2.0,
+ * it is only on Windows, and only when IOCP is in use.
+ *
+ * @param cfg the event configuration object
+ * @param cpus the number of cpus
+ * @return 0 on success, -1 on failure.
+ */
+EVENT2_EXPORT_SYMBOL
+int event_config_set_num_cpus_hint(struct event_config *cfg, int cpus);
+
+/**
+ * Record an interval and/or a number of callbacks after which the event base
+ * should check for new events.  By default, the event base will run as many
+ * events are as activated at the higest activated priority before checking
+ * for new events.  If you configure it by setting max_interval, it will check
+ * the time after each callback, and not allow more than max_interval to
+ * elapse before checking for new events.  If you configure it by setting
+ * max_callbacks to a value >= 0, it will run no more than max_callbacks
+ * callbacks before checking for new events.
+ *
+ * This option can decrease the latency of high-priority events, and
+ * avoid priority inversions where multiple low-priority events keep us from
+ * polling for high-priority events, but at the expense of slightly decreasing
+ * the throughput.  Use it with caution!
+ *
+ * @param cfg The event_base configuration object.
+ * @param max_interval An interval after which Libevent should stop running
+ *     callbacks and check for more events, or NULL if there should be
+ *     no such interval.
+ * @param max_callbacks A number of callbacks after which Libevent should
+ *     stop running callbacks and check for more events, or -1 if there
+ *     should be no such limit.
+ * @param min_priority A priority below which max_interval and max_callbacks
+ *     should not be enforced.  If this is set to 0, they are enforced
+ *     for events of every priority; if it's set to 1, they're enforced
+ *     for events of priority 1 and above, and so on.
+ * @return 0 on success, -1 on failure.
+ **/
+EVENT2_EXPORT_SYMBOL
+int event_config_set_max_dispatch_interval(struct event_config *cfg,
+    const struct timeval *max_interval, int max_callbacks,
+    int min_priority);
+
+/**
+  Initialize the event API.
+
+  Use event_base_new_with_config() to initialize a new event base, taking
+  the specified configuration under consideration.  The configuration object
+  can currently be used to avoid certain event notification mechanisms.
+
+  @param cfg the event configuration object
+  @return an initialized event_base that can be used to registering events,
+     or NULL if no event base can be created with the requested event_config.
+  @see event_base_new(), event_base_free(), event_init(), event_assign()
+*/
+EVENT2_EXPORT_SYMBOL
+struct event_base *event_base_new_with_config(const struct event_config *);
+
+/**
+  Deallocate all memory associated with an event_base, and free the base.
+
+  Note that this function will not close any fds or free any memory passed
+  to event_new as the argument to callback.
+
+  If there are any pending finalizer callbacks, this function will invoke
+  them.
+
+  @param eb an event_base to be freed
+ */
+EVENT2_EXPORT_SYMBOL
+void event_base_free(struct event_base *);
+
+/**
+   As event_free, but do not run finalizers.
+
+   THIS IS AN EXPERIMENTAL API. IT MIGHT CHANGE BEFORE THE LIBEVENT 2.1 SERIES
+   BECOMES STABLE.
+ */
+EVENT2_EXPORT_SYMBOL
+void event_base_free_nofinalize(struct event_base *);
+
+/** @name Log severities
+ */
+/**@{*/
+#define EVENT_LOG_DEBUG 0
+#define EVENT_LOG_MSG   1
+#define EVENT_LOG_WARN  2
+#define EVENT_LOG_ERR   3
+/**@}*/
+
+/* Obsolete names: these are deprecated, but older programs might use them.
+ * They violate the reserved-identifier namespace. */
+#define _EVENT_LOG_DEBUG EVENT_LOG_DEBUG
+#define _EVENT_LOG_MSG EVENT_LOG_MSG
+#define _EVENT_LOG_WARN EVENT_LOG_WARN
+#define _EVENT_LOG_ERR EVENT_LOG_ERR
+
+/**
+  A callback function used to intercept Libevent's log messages.
+
+  @see event_set_log_callback
+ */
+typedef void (*event_log_cb)(int severity, const char *msg);
+/**
+  Redirect Libevent's log messages.
+
+  @param cb a function taking two arguments: an integer severity between
+     EVENT_LOG_DEBUG and EVENT_LOG_ERR, and a string.  If cb is NULL,
+	 then the default log is used.
+
+  NOTE: The function you provide *must not* call any other libevent
+  functionality.  Doing so can produce undefined behavior.
+  */
+EVENT2_EXPORT_SYMBOL
+void event_set_log_callback(event_log_cb cb);
+
+/**
+   A function to be called if Libevent encounters a fatal internal error.
+
+   @see event_set_fatal_callback
+ */
+typedef void (*event_fatal_cb)(int err);
+
+/**
+ Override Libevent's behavior in the event of a fatal internal error.
+
+ By default, Libevent will call exit(1) if a programming error makes it
+ impossible to continue correct operation.  This function allows you to supply
+ another callback instead.  Note that if the function is ever invoked,
+ something is wrong with your program, or with Libevent: any subsequent calls
+ to Libevent may result in undefined behavior.
+
+ Libevent will (almost) always log an EVENT_LOG_ERR message before calling
+ this function; look at the last log message to see why Libevent has died.
+ */
+EVENT2_EXPORT_SYMBOL
+void event_set_fatal_callback(event_fatal_cb cb);
+
+#define EVENT_DBG_ALL 0xffffffffu
+#define EVENT_DBG_NONE 0
+
+/**
+ Turn on debugging logs and have them sent to the default log handler.
+
+ This is a global setting; if you are going to call it, you must call this
+ before any calls that create an event-base.  You must call it before any
+ multithreaded use of Libevent.
+
+ Debug logs are verbose.
+
+ @param which Controls which debug messages are turned on.  This option is
+   unused for now; for forward compatibility, you must pass in the constant
+   "EVENT_DBG_ALL" to turn debugging logs on, or "EVENT_DBG_NONE" to turn
+   debugging logs off.
+ */
+EVENT2_EXPORT_SYMBOL
+void event_enable_debug_logging(ev_uint32_t which);
+
+/**
+  Associate a different event base with an event.
+
+  The event to be associated must not be currently active or pending.
+
+  @param eb the event base
+  @param ev the event
+  @return 0 on success, -1 on failure.
+ */
+EVENT2_EXPORT_SYMBOL
+int event_base_set(struct event_base *, struct event *);
+
+/** @name Loop flags
+
+    These flags control the behavior of event_base_loop().
+ */
+/**@{*/
+/** Block until we have an active event, then exit once all active events
+ * have had their callbacks run. */
+#define EVLOOP_ONCE	0x01
+/** Do not block: see which events are ready now, run the callbacks
+ * of the highest-priority ones, then exit. */
+#define EVLOOP_NONBLOCK	0x02
+/** Do not exit the loop because we have no pending events.  Instead, keep
+ * running until event_base_loopexit() or event_base_loopbreak() makes us
+ * stop.
+ */
+#define EVLOOP_NO_EXIT_ON_EMPTY 0x04
+/**@}*/
+
+/**
+  Wait for events to become active, and run their callbacks.
+
+  This is a more flexible version of event_base_dispatch().
+
+  By default, this loop will run the event base until either there are no more
+  pending or active events, or until something calls event_base_loopbreak() or
+  event_base_loopexit().  You can override this behavior with the 'flags'
+  argument.
+
+  @param eb the event_base structure returned by event_base_new() or
+     event_base_new_with_config()
+  @param flags any combination of EVLOOP_ONCE | EVLOOP_NONBLOCK
+  @return 0 if successful, -1 if an error occurred, or 1 if we exited because
+     no events were pending or active.
+  @see event_base_loopexit(), event_base_dispatch(), EVLOOP_ONCE,
+     EVLOOP_NONBLOCK
+  */
+EVENT2_EXPORT_SYMBOL
+int event_base_loop(struct event_base *, int);
+
+/**
+  Exit the event loop after the specified time
+
+  The next event_base_loop() iteration after the given timer expires will
+  complete normally (handling all queued events) then exit without
+  blocking for events again.
+
+  Subsequent invocations of event_base_loop() will proceed normally.
+
+  @param eb the event_base structure returned by event_init()
+  @param tv the amount of time after which the loop should terminate,
+    or NULL to exit after running all currently active events.
+  @return 0 if successful, or -1 if an error occurred
+  @see event_base_loopbreak()
+ */
+EVENT2_EXPORT_SYMBOL
+int event_base_loopexit(struct event_base *, const struct timeval *);
+
+/**
+  Abort the active event_base_loop() immediately.
+
+  event_base_loop() will abort the loop after the next event is completed;
+  event_base_loopbreak() is typically invoked from this event's callback.
+  This behavior is analogous to the "break;" statement.
+
+  Subsequent invocations of event_base_loop() will proceed normally.
+
+  @param eb the event_base structure returned by event_init()
+  @return 0 if successful, or -1 if an error occurred
+  @see event_base_loopexit()
+ */
+EVENT2_EXPORT_SYMBOL
+int event_base_loopbreak(struct event_base *);
+
+/**
+  Tell the active event_base_loop() to scan for new events immediately.
+
+  Calling this function makes the currently active event_base_loop()
+  start the loop over again (scanning for new events) after the current
+  event callback finishes.  If the event loop is not running, this
+  function has no effect.
+
+  event_base_loopbreak() is typically invoked from this event's callback.
+  This behavior is analogous to the "continue;" statement.
+
+  Subsequent invocations of event loop will proceed normally.
+
+  @param eb the event_base structure returned by event_init()
+  @return 0 if successful, or -1 if an error occurred
+  @see event_base_loopbreak()
+ */
+EVENT2_EXPORT_SYMBOL
+int event_base_loopcontinue(struct event_base *);
+
+/**
+  Checks if the event loop was told to exit by event_base_loopexit().
+
+  This function will return true for an event_base at every point after
+  event_loopexit() is called, until the event loop is next entered.
+
+  @param eb the event_base structure returned by event_init()
+  @return true if event_base_loopexit() was called on this event base,
+    or 0 otherwise
+  @see event_base_loopexit()
+  @see event_base_got_break()
+ */
+EVENT2_EXPORT_SYMBOL
+int event_base_got_exit(struct event_base *);
+
+/**
+  Checks if the event loop was told to abort immediately by event_base_loopbreak().
+
+  This function will return true for an event_base at every point after
+  event_base_loopbreak() is called, until the event loop is next entered.
+
+  @param eb the event_base structure returned by event_init()
+  @return true if event_base_loopbreak() was called on this event base,
+    or 0 otherwise
+  @see event_base_loopbreak()
+  @see event_base_got_exit()
+ */
+EVENT2_EXPORT_SYMBOL
+int event_base_got_break(struct event_base *);
+
+/**
+ * @name event flags
+ *
+ * Flags to pass to event_new(), event_assign(), event_pending(), and
+ * anything else with an argument of the form "short events"
+ */
+/**@{*/
+/** Indicates that a timeout has occurred.  It's not necessary to pass
+ * this flag to event_for new()/event_assign() to get a timeout. */
+#define EV_TIMEOUT	0x01
+/** Wait for a socket or FD to become readable */
+#define EV_READ		0x02
+/** Wait for a socket or FD to become writeable */
+#define EV_WRITE	0x04
+/** Wait for a POSIX signal to be raised*/
+#define EV_SIGNAL	0x08
+/**
+ * Persistent event: won't get removed automatically when activated.
+ *
+ * When a persistent event with a timeout becomes activated, its timeout
+ * is reset to 0.
+ */
+#define EV_PERSIST	0x10
+/** Select edge-triggered behavior, if supported by the backend. */
+#define EV_ET		0x20
+/**
+ * If this option is provided, then event_del() will not block in one thread
+ * while waiting for the event callback to complete in another thread.
+ *
+ * To use this option safely, you may need to use event_finalize() or
+ * event_free_finalize() in order to safely tear down an event in a
+ * multithreaded application.  See those functions for more information.
+ *
+ * THIS IS AN EXPERIMENTAL API. IT MIGHT CHANGE BEFORE THE LIBEVENT 2.1 SERIES
+ * BECOMES STABLE.
+ **/
+#define EV_FINALIZE     0x40
+/**
+ * Detects connection close events.  You can use this to detect when a
+ * connection has been closed, without having to read all the pending data
+ * from a connection.
+ *
+ * Not all backends support EV_CLOSED.  To detect or require it, use the
+ * feature flag EV_FEATURE_EARLY_CLOSE.
+ **/
+#define EV_CLOSED	0x80
+/**@}*/
+
+/**
+   @name evtimer_* macros
+
+    Aliases for working with one-shot timer events */
+/**@{*/
+#define evtimer_assign(ev, b, cb, arg) \
+	event_assign((ev), (b), -1, 0, (cb), (arg))
+#define evtimer_new(b, cb, arg)	       event_new((b), -1, 0, (cb), (arg))
+#define evtimer_add(ev, tv)		event_add((ev), (tv))
+#define evtimer_del(ev)			event_del(ev)
+#define evtimer_pending(ev, tv)		event_pending((ev), EV_TIMEOUT, (tv))
+#define evtimer_initialized(ev)		event_initialized(ev)
+/**@}*/
+
+/**
+   @name evsignal_* macros
+
+   Aliases for working with signal events
+ */
+/**@{*/
+#define evsignal_add(ev, tv)		event_add((ev), (tv))
+#define evsignal_assign(ev, b, x, cb, arg)			\
+	event_assign((ev), (b), (x), EV_SIGNAL|EV_PERSIST, cb, (arg))
+#define evsignal_new(b, x, cb, arg)				\
+	event_new((b), (x), EV_SIGNAL|EV_PERSIST, (cb), (arg))
+#define evsignal_del(ev)		event_del(ev)
+#define evsignal_pending(ev, tv)	event_pending((ev), EV_SIGNAL, (tv))
+#define evsignal_initialized(ev)	event_initialized(ev)
+/**@}*/
+
+/**
+   A callback function for an event.
+
+   It receives three arguments:
+
+   @param fd An fd or signal
+   @param events One or more EV_* flags
+   @param arg A user-supplied argument.
+
+   @see event_new()
+ */
+typedef void (*event_callback_fn)(evutil_socket_t, short, void *);
+
+/**
+  Return a value used to specify that the event itself must be used as the callback argument.
+
+  The function event_new() takes a callback argument which is passed
+  to the event's callback function. To specify that the argument to be
+  passed to the callback function is the event that event_new() returns,
+  pass in the return value of event_self_cbarg() as the callback argument
+  for event_new().
+
+  For example:
+  <pre>
+      struct event *ev = event_new(base, sock, events, callback, %event_self_cbarg());
+  </pre>
+
+  For consistency with event_new(), it is possible to pass the return value
+  of this function as the callback argument for event_assign() &ndash; this
+  achieves the same result as passing the event in directly.
+
+  @return a value to be passed as the callback argument to event_new() or
+  event_assign().
+  @see event_new(), event_assign()
+ */
+EVENT2_EXPORT_SYMBOL
+void *event_self_cbarg(void);
+
+/**
+  Allocate and asssign a new event structure, ready to be added.
+
+  The function event_new() returns a new event that can be used in
+  future calls to event_add() and event_del().  The fd and events
+  arguments determine which conditions will trigger the event; the
+  callback and callback_arg arguments tell Libevent what to do when the
+  event becomes active.
+
+  If events contains one of EV_READ, EV_WRITE, or EV_READ|EV_WRITE, then
+  fd is a file descriptor or socket that should get monitored for
+  readiness to read, readiness to write, or readiness for either operation
+  (respectively).  If events contains EV_SIGNAL, then fd is a signal
+  number to wait for.  If events contains none of those flags, then the
+  event can be triggered only by a timeout or by manual activation with
+  event_active(): In this case, fd must be -1.
+
+  The EV_PERSIST flag can also be passed in the events argument: it makes
+  event_add() persistent until event_del() is called.
+
+  The EV_ET flag is compatible with EV_READ and EV_WRITE, and supported
+  only by certain backends.  It tells Libevent to use edge-triggered
+  events.
+
+  The EV_TIMEOUT flag has no effect here.
+
+  It is okay to have multiple events all listening on the same fds; but
+  they must either all be edge-triggered, or all not be edge triggerd.
+
+  When the event becomes active, the event loop will run the provided
+  callbuck function, with three arguments.  The first will be the provided
+  fd value.  The second will be a bitfield of the events that triggered:
+  EV_READ, EV_WRITE, or EV_SIGNAL.  Here the EV_TIMEOUT flag indicates
+  that a timeout occurred, and EV_ET indicates that an edge-triggered
+  event occurred.  The third event will be the callback_arg pointer that
+  you provide.
+
+  @param base the event base to which the event should be attached.
+  @param fd the file descriptor or signal to be monitored, or -1.
+  @param events desired events to monitor: bitfield of EV_READ, EV_WRITE,
+      EV_SIGNAL, EV_PERSIST, EV_ET.
+  @param callback callback function to be invoked when the event occurs
+  @param callback_arg an argument to be passed to the callback function
+
+  @return a newly allocated struct event that must later be freed with
+    event_free().
+  @see event_free(), event_add(), event_del(), event_assign()
+ */
+EVENT2_EXPORT_SYMBOL
+struct event *event_new(struct event_base *, evutil_socket_t, short, event_callback_fn, void *);
+
+
+/**
+  Prepare a new, already-allocated event structure to be added.
+
+  The function event_assign() prepares the event structure ev to be used
+  in future calls to event_add() and event_del().  Unlike event_new(), it
+  doesn't allocate memory itself: it requires that you have already
+  allocated a struct event, probably on the heap.  Doing this will
+  typically make your code depend on the size of the event structure, and
+  thereby create incompatibility with future versions of Libevent.
+
+  The easiest way to avoid this problem is just to use event_new() and
+  event_free() instead.
+
+  A slightly harder way to future-proof your code is to use
+  event_get_struct_event_size() to determine the required size of an event
+  at runtime.
+
+  Note that it is NOT safe to call this function on an event that is
+  active or pending.  Doing so WILL corrupt internal data structures in
+  Libevent, and lead to strange, hard-to-diagnose bugs.  You _can_ use
+  event_assign to change an existing event, but only if it is not active
+  or pending!
+
+  The arguments for this function, and the behavior of the events that it
+  makes, are as for event_new().
+
+  @param ev an event struct to be modified
+  @param base the event base to which ev should be attached.
+  @param fd the file descriptor to be monitored
+  @param events desired events to monitor; can be EV_READ and/or EV_WRITE
+  @param callback callback function to be invoked when the event occurs
+  @param callback_arg an argument to be passed to the callback function
+
+  @return 0 if success, or -1 on invalid arguments.
+
+  @see event_new(), event_add(), event_del(), event_base_once(),
+    event_get_struct_event_size()
+  */
+EVENT2_EXPORT_SYMBOL
+int event_assign(struct event *, struct event_base *, evutil_socket_t, short, event_callback_fn, void *);
+
+/**
+   Deallocate a struct event * returned by event_new().
+
+   If the event is pending or active, first make it non-pending and
+   non-active.
+ */
+EVENT2_EXPORT_SYMBOL
+void event_free(struct event *);
+
+/**
+ * Callback type for event_finalize and event_free_finalize().
+ *
+ * THIS IS AN EXPERIMENTAL API. IT MIGHT CHANGE BEFORE THE LIBEVENT 2.1 SERIES
+ * BECOMES STABLE.
+ *
+ **/
+typedef void (*event_finalize_callback_fn)(struct event *, void *);
+/**
+   @name Finalization functions
+
+   These functions are used to safely tear down an event in a multithreaded
+   application.  If you construct your events with EV_FINALIZE to avoid
+   deadlocks, you will need a way to remove an event in the certainty that
+   it will definitely not be running its callback when you deallocate it
+   and its callback argument.
+
+   To do this, call one of event_finalize() or event_free_finalize with
+   0 for its first argument, the event to tear down as its second argument,
+   and a callback function as its third argument.  The callback will be
+   invoked as part of the event loop, with the event's priority.
+
+   After you call a finalizer function, event_add() and event_active() will
+   no longer work on the event, and event_del() will produce a no-op. You
+   must not try to change the event's fields with event_assign() or
+   event_set() while the finalize callback is in progress.  Once the
+   callback has been invoked, you should treat the event structure as
+   containing uninitialized memory.
+
+   The event_free_finalize() function frees the event after it's finalized;
+   event_finalize() does not.
+
+   A finalizer callback must not make events pending or active.  It must not
+   add events, activate events, or attempt to "resucitate" the event being
+   finalized in any way.
+
+   THIS IS AN EXPERIMENTAL API. IT MIGHT CHANGE BEFORE THE LIBEVENT 2.1 SERIES
+   BECOMES STABLE.
+
+   @return 0 on succes, -1 on failure.
+ */
+/**@{*/
+EVENT2_EXPORT_SYMBOL
+int event_finalize(unsigned, struct event *, event_finalize_callback_fn);
+EVENT2_EXPORT_SYMBOL
+int event_free_finalize(unsigned, struct event *, event_finalize_callback_fn);
+/**@}*/
+
+/**
+  Schedule a one-time event
+
+  The function event_base_once() is similar to event_new().  However, it
+  schedules a callback to be called exactly once, and does not require the
+  caller to prepare an event structure.
+
+  Note that in Libevent 2.0 and earlier, if the event is never triggered, the
+  internal memory used to hold it will never be freed.  In Libevent 2.1,
+  the internal memory will get freed by event_base_free() if the event
+  is never triggered.  The 'arg' value, however, will not get freed in either
+  case--you'll need to free that on your own if you want it to go away.
+
+  @param base an event_base
+  @param fd a file descriptor to monitor, or -1 for no fd.
+  @param events event(s) to monitor; can be any of EV_READ |
+         EV_WRITE, or EV_TIMEOUT
+  @param callback callback function to be invoked when the event occurs
+  @param arg an argument to be passed to the callback function
+  @param timeout the maximum amount of time to wait for the event. NULL
+         makes an EV_READ/EV_WRITE event make forever; NULL makes an
+        EV_TIMEOUT event succees immediately.
+  @return 0 if successful, or -1 if an error occurred
+ */
+EVENT2_EXPORT_SYMBOL
+int event_base_once(struct event_base *, evutil_socket_t, short, event_callback_fn, void *, const struct timeval *);
+
+/**
+  Add an event to the set of pending events.
+
+  The function event_add() schedules the execution of the event 'ev' when the
+  condition specified by event_assign() or event_new() occurs, or when the time
+  specified in timeout has elapesed.  If atimeout is NULL, no timeout
+  occurs and the function will only be
+  called if a matching event occurs.  The event in the
+  ev argument must be already initialized by event_assign() or event_new()
+  and may not be used
+  in calls to event_assign() until it is no longer pending.
+
+  If the event in the ev argument already has a scheduled timeout, calling
+  event_add() replaces the old timeout with the new one if tv is non-NULL.
+
+  @param ev an event struct initialized via event_assign() or event_new()
+  @param timeout the maximum amount of time to wait for the event, or NULL
+         to wait forever
+  @return 0 if successful, or -1 if an error occurred
+  @see event_del(), event_assign(), event_new()
+  */
+EVENT2_EXPORT_SYMBOL
+int event_add(struct event *ev, const struct timeval *timeout);
+
+/**
+   Remove a timer from a pending event without removing the event itself.
+
+   If the event has a scheduled timeout, this function unschedules it but
+   leaves the event otherwise pending.
+
+   @param ev an event struct initialized via event_assign() or event_new()
+   @return 0 on success, or -1 if  an error occurrect.
+*/
+EVENT2_EXPORT_SYMBOL
+int event_remove_timer(struct event *ev);
+
+/**
+  Remove an event from the set of monitored events.
+
+  The function event_del() will cancel the event in the argument ev.  If the
+  event has already executed or has never been added the call will have no
+  effect.
+
+  @param ev an event struct to be removed from the working set
+  @return 0 if successful, or -1 if an error occurred
+  @see event_add()
+ */
+EVENT2_EXPORT_SYMBOL
+int event_del(struct event *);
+
+/**
+   As event_del(), but never blocks while the event's callback is running
+   in another thread, even if the event was constructed without the
+   EV_FINALIZE flag.
+
+   THIS IS AN EXPERIMENTAL API. IT MIGHT CHANGE BEFORE THE LIBEVENT 2.1 SERIES
+   BECOMES STABLE.
+ */
+EVENT2_EXPORT_SYMBOL
+int event_del_noblock(struct event *ev);
+/**
+   As event_del(), but always blocks while the event's callback is running
+   in another thread, even if the event was constructed with the
+   EV_FINALIZE flag.
+
+   THIS IS AN EXPERIMENTAL API. IT MIGHT CHANGE BEFORE THE LIBEVENT 2.1 SERIES
+   BECOMES STABLE.
+ */
+EVENT2_EXPORT_SYMBOL
+int event_del_block(struct event *ev);
+
+/**
+  Make an event active.
+
+  You can use this function on a pending or a non-pending event to make it
+  active, so that its callback will be run by event_base_dispatch() or
+  event_base_loop().
+
+  One common use in multithreaded programs is to wake the thread running
+  event_base_loop() from another thread.
+
+  @param ev an event to make active.
+  @param res a set of flags to pass to the event's callback.
+  @param ncalls an obsolete argument: this is ignored.
+ **/
+EVENT2_EXPORT_SYMBOL
+void event_active(struct event *ev, int res, short ncalls);
+
+/**
+  Checks if a specific event is pending or scheduled.
+
+  @param ev an event struct previously passed to event_add()
+  @param events the requested event type; any of EV_TIMEOUT|EV_READ|
+         EV_WRITE|EV_SIGNAL
+  @param tv if this field is not NULL, and the event has a timeout,
+         this field is set to hold the time at which the timeout will
+	 expire.
+
+  @return true if the event is pending on any of the events in 'what', (that
+  is to say, it has been added), or 0 if the event is not added.
+ */
+EVENT2_EXPORT_SYMBOL
+int event_pending(const struct event *ev, short events, struct timeval *tv);
+
+/**
+   If called from within the callback for an event, returns that event.
+
+   The behavior of this function is not defined when called from outside the
+   callback function for an event.
+ */
+EVENT2_EXPORT_SYMBOL
+struct event *event_base_get_running_event(struct event_base *base);
+
+/**
+  Test if an event structure might be initialized.
+
+  The event_initialized() function can be used to check if an event has been
+  initialized.
+
+  Warning: This function is only useful for distinguishing a a zeroed-out
+    piece of memory from an initialized event, it can easily be confused by
+    uninitialized memory.  Thus, it should ONLY be used to distinguish an
+    initialized event from zero.
+
+  @param ev an event structure to be tested
+  @return 1 if the structure might be initialized, or 0 if it has not been
+          initialized
+ */
+EVENT2_EXPORT_SYMBOL
+int event_initialized(const struct event *ev);
+
+/**
+   Get the signal number assigned to a signal event
+*/
+#define event_get_signal(ev) ((int)event_get_fd(ev))
+
+/**
+   Get the socket or signal assigned to an event, or -1 if the event has
+   no socket.
+*/
+EVENT2_EXPORT_SYMBOL
+evutil_socket_t event_get_fd(const struct event *ev);
+
+/**
+   Get the event_base associated with an event.
+*/
+EVENT2_EXPORT_SYMBOL
+struct event_base *event_get_base(const struct event *ev);
+
+/**
+   Return the events (EV_READ, EV_WRITE, etc) assigned to an event.
+*/
+EVENT2_EXPORT_SYMBOL
+short event_get_events(const struct event *ev);
+
+/**
+   Return the callback assigned to an event.
+*/
+EVENT2_EXPORT_SYMBOL
+event_callback_fn event_get_callback(const struct event *ev);
+
+/**
+   Return the callback argument assigned to an event.
+*/
+EVENT2_EXPORT_SYMBOL
+void *event_get_callback_arg(const struct event *ev);
+
+/**
+   Return the priority of an event.
+   @see event_priority_init(), event_get_priority()
+*/
+EVENT2_EXPORT_SYMBOL
+int event_get_priority(const struct event *ev);
+
+/**
+   Extract _all_ of arguments given to construct a given event.  The
+   event_base is copied into *base_out, the fd is copied into *fd_out, and so
+   on.
+
+   If any of the "_out" arguments is NULL, it will be ignored.
+ */
+EVENT2_EXPORT_SYMBOL
+void event_get_assignment(const struct event *event,
+    struct event_base **base_out, evutil_socket_t *fd_out, short *events_out,
+    event_callback_fn *callback_out, void **arg_out);
+
+/**
+   Return the size of struct event that the Libevent library was compiled
+   with.
+
+   This will be NO GREATER than sizeof(struct event) if you're running with
+   the same version of Libevent that your application was built with, but
+   otherwise might not.
+
+   Note that it might be SMALLER than sizeof(struct event) if some future
+   version of Libevent adds extra padding to the end of struct event.
+   We might do this to help ensure ABI-compatibility between different
+   versions of Libevent.
+ */
+EVENT2_EXPORT_SYMBOL
+size_t event_get_struct_event_size(void);
+
+/**
+   Get the Libevent version.
+
+   Note that this will give you the version of the library that you're
+   currently linked against, not the version of the headers that you've
+   compiled against.
+
+   @return a string containing the version number of Libevent
+*/
+EVENT2_EXPORT_SYMBOL
+const char *event_get_version(void);
+
+/**
+   Return a numeric representation of Libevent's version.
+
+   Note that this will give you the version of the library that you're
+   currently linked against, not the version of the headers you've used to
+   compile.
+
+   The format uses one byte each for the major, minor, and patchlevel parts of
+   the version number.  The low-order byte is unused.  For example, version
+   2.0.1-alpha has a numeric representation of 0x02000100
+*/
+EVENT2_EXPORT_SYMBOL
+ev_uint32_t event_get_version_number(void);
+
+/** As event_get_version, but gives the version of Libevent's headers. */
+#define LIBEVENT_VERSION EVENT__VERSION
+/** As event_get_version_number, but gives the version number of Libevent's
+ * headers. */
+#define LIBEVENT_VERSION_NUMBER EVENT__NUMERIC_VERSION
+
+/** Largest number of priorities that Libevent can support. */
+#define EVENT_MAX_PRIORITIES 256
+/**
+  Set the number of different event priorities
+
+  By default Libevent schedules all active events with the same priority.
+  However, some time it is desirable to process some events with a higher
+  priority than others.  For that reason, Libevent supports strict priority
+  queues.  Active events with a lower priority are always processed before
+  events with a higher priority.
+
+  The number of different priorities can be set initially with the
+  event_base_priority_init() function.  This function should be called
+  before the first call to event_base_dispatch().  The
+  event_priority_set() function can be used to assign a priority to an
+  event.  By default, Libevent assigns the middle priority to all events
+  unless their priority is explicitly set.
+
+  Note that urgent-priority events can starve less-urgent events: after
+  running all urgent-priority callbacks, Libevent checks for more urgent
+  events again, before running less-urgent events.  Less-urgent events
+  will not have their callbacks run until there are no events more urgent
+  than them that want to be active.
+
+  @param eb the event_base structure returned by event_base_new()
+  @param npriorities the maximum number of priorities
+  @return 0 if successful, or -1 if an error occurred
+  @see event_priority_set()
+ */
+EVENT2_EXPORT_SYMBOL
+int	event_base_priority_init(struct event_base *, int);
+
+/**
+  Get the number of different event priorities.
+
+  @param eb the event_base structure returned by event_base_new()
+  @return Number of different event priorities
+  @see event_base_priority_init()
+*/
+EVENT2_EXPORT_SYMBOL
+int	event_base_get_npriorities(struct event_base *eb);
+
+/**
+  Assign a priority to an event.
+
+  @param ev an event struct
+  @param priority the new priority to be assigned
+  @return 0 if successful, or -1 if an error occurred
+  @see event_priority_init(), event_get_priority()
+  */
+EVENT2_EXPORT_SYMBOL
+int	event_priority_set(struct event *, int);
+
+/**
+   Prepare an event_base to use a large number of timeouts with the same
+   duration.
+
+   Libevent's default scheduling algorithm is optimized for having a large
+   number of timeouts with their durations more or less randomly
+   distributed.  But if you have a large number of timeouts that all have
+   the same duration (for example, if you have a large number of
+   connections that all have a 10-second timeout), then you can improve
+   Libevent's performance by telling Libevent about it.
+
+   To do this, call this function with the common duration.  It will return a
+   pointer to a different, opaque timeout value.  (Don't depend on its actual
+   contents!)  When you use this timeout value in event_add(), Libevent will
+   schedule the event more efficiently.
+
+   (This optimization probably will not be worthwhile until you have thousands
+   or tens of thousands of events with the same timeout.)
+ */
+EVENT2_EXPORT_SYMBOL
+const struct timeval *event_base_init_common_timeout(struct event_base *base,
+    const struct timeval *duration);
+
+#if !defined(EVENT__DISABLE_MM_REPLACEMENT) || defined(EVENT_IN_DOXYGEN_)
+/**
+ Override the functions that Libevent uses for memory management.
+
+ Usually, Libevent uses the standard libc functions malloc, realloc, and
+ free to allocate memory.  Passing replacements for those functions to
+ event_set_mem_functions() overrides this behavior.
+
+ Note that all memory returned from Libevent will be allocated by the
+ replacement functions rather than by malloc() and realloc().  Thus, if you
+ have replaced those functions, it will not be appropriate to free() memory
+ that you get from Libevent.  Instead, you must use the free_fn replacement
+ that you provided.
+
+ Note also that if you are going to call this function, you should do so
+ before any call to any Libevent function that does allocation.
+ Otherwise, those funtions will allocate their memory using malloc(), but
+ then later free it using your provided free_fn.
+
+ @param malloc_fn A replacement for malloc.
+ @param realloc_fn A replacement for realloc
+ @param free_fn A replacement for free.
+ **/
+EVENT2_EXPORT_SYMBOL
+void event_set_mem_functions(
+	void *(*malloc_fn)(size_t sz),
+	void *(*realloc_fn)(void *ptr, size_t sz),
+	void (*free_fn)(void *ptr));
+/** This definition is present if Libevent was built with support for
+    event_set_mem_functions() */
+#define EVENT_SET_MEM_FUNCTIONS_IMPLEMENTED
+#endif
+
+/**
+   Writes a human-readable description of all inserted and/or active
+   events to a provided stdio stream.
+
+   This is intended for debugging; its format is not guaranteed to be the same
+   between libevent versions.
+
+   @param base An event_base on which to scan the events.
+   @param output A stdio file to write on.
+ */
+EVENT2_EXPORT_SYMBOL
+void event_base_dump_events(struct event_base *, FILE *);
+
+
+/**
+   Activates all pending events for the given fd and event mask.
+
+   This function activates pending events only.  Events which have not been
+   added will not become active.
+
+   @param base the event_base on which to activate the events.
+   @param fd An fd to active events on.
+   @param events One or more of EV_{READ,WRITE}.
+ */
+EVENT2_EXPORT_SYMBOL
+void event_base_active_by_fd(struct event_base *base, evutil_socket_t fd, short events);
+
+/**
+   Activates all pending signals with a given signal number
+
+   This function activates pending events only.  Events which have not been
+   added will not become active.
+
+   @param base the event_base on which to activate the events.
+   @param fd The signal to active events on.
+ */
+EVENT2_EXPORT_SYMBOL
+void event_base_active_by_signal(struct event_base *base, int sig);
+
+/**
+ * Callback for iterating events in an event base via event_base_foreach_event
+ */
+typedef int (*event_base_foreach_event_cb)(const struct event_base *, const struct event *, void *);
+
+/**
+   Iterate over all added or active events events in an event loop, and invoke
+   a given callback on each one.
+
+   The callback must not call any function that modifies the event base, that
+   modifies any event in the event base, or that adds or removes any event to
+   the event base.  Doing so is unsupported and will lead to undefined
+   behavior -- likely, to crashes.
+
+   event_base_foreach_event() holds a lock on the event_base() for the whole
+   time it's running: slow callbacks are not advisable.
+
+   Note that Libevent adds some events of its own to make pieces of its
+   functionality work.  You must not assume that the only events you'll
+   encounter will be the ones you added yourself.
+
+   The callback function must return 0 to continue iteration, or some other
+   integer to stop iterating.
+
+   @param base An event_base on which to scan the events.
+   @param fn   A callback function to receive the events.
+   @param arg  An argument passed to the callback function.
+   @return 0 if we iterated over every event, or the value returned by the
+      callback function if the loop exited early.
+*/
+EVENT2_EXPORT_SYMBOL
+int event_base_foreach_event(struct event_base *base, event_base_foreach_event_cb fn, void *arg);
+
+
+/** Sets 'tv' to the current time (as returned by gettimeofday()),
+    looking at the cached value in 'base' if possible, and calling
+    gettimeofday() or clock_gettime() as appropriate if there is no
+    cached time.
+
+    Generally, this value will only be cached while actually
+    processing event callbacks, and may be very inaccuate if your
+    callbacks take a long time to execute.
+
+    Returns 0 on success, negative on failure.
+ */
+EVENT2_EXPORT_SYMBOL
+int event_base_gettimeofday_cached(struct event_base *base,
+    struct timeval *tv);
+
+/** Update cached_tv in the 'base' to the current time
+ *
+ * You can use this function is useful for selectively increasing
+ * the accuracy of the cached time value in 'base' during callbacks
+ * that take a long time to execute.
+ *
+ * This function has no effect if the base is currently not in its
+ * event loop, or if timeval caching is disabled via
+ * EVENT_BASE_FLAG_NO_CACHE_TIME.
+ *
+ * @return 0 on success, -1 on failure
+ */
+EVENT2_EXPORT_SYMBOL
+int event_base_update_cache_time(struct event_base *base);
+
+/** Release up all globally-allocated resources allocated by Libevent.
+
+    This function does not free developer-controlled resources like
+    event_bases, events, bufferevents, listeners, and so on.  It only releases
+    resources like global locks that there is no other way to free.
+
+    It is not actually necessary to call this function before exit: every
+    resource that it frees would be released anyway on exit.  It mainly exists
+    so that resource-leak debugging tools don't see Libevent as holding
+    resources at exit.
+
+    You should only call this function when no other Libevent functions will
+    be invoked -- e.g., when cleanly exiting a program.
+ */
+EVENT2_EXPORT_SYMBOL
+void libevent_global_shutdown(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EVENT2_EVENT_H_INCLUDED_ */
Index: dep/libevent/inc/event2/event_compat.h
===================================================================
--- dep/libevent/inc/event2/event_compat.h	(revision 49)
+++ dep/libevent/inc/event2/event_compat.h	(working copy)
@@ -1,220 +1,230 @@
-/*
- * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
- * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _EVENT2_EVENT_COMPAT_H_
-#define _EVENT2_EVENT_COMPAT_H_
-
-/** @file event2/event_compat.h
-
-  Potentially non-threadsafe versions of the functions in event.h: provided
-  only for backwards compatibility.
-
-  In the oldest versions of Libevent, event_base was not a first-class
-  structure.  Instead, there was a single event base that every function
-  manipulated.  Later, when separate event bases were added, the old functions
-  that didn't take an event_base argument needed to work by manipulating the
-  "current" event base.  This could lead to thread-safety issues, and obscure,
-  hard-to-diagnose bugs.
-
-  @deprecated All functions in this file are by definition deprecated.
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <event2/event-config.h>
-#ifdef _EVENT_HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-#ifdef _EVENT_HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif
-
-/* For int types. */
-#include <event2/util.h>
-
-/**
-  Initialize the event API.
-
-  The event API needs to be initialized with event_init() before it can be
-  used.  Sets the global current base that gets used for events that have no
-  base associated with them.
-
-  @deprecated This function is deprecated because it replaces the "current"
-    event_base, and is totally unsafe for multithreaded use.  The replacement
-    is event_base_new().
-
-  @see event_base_set(), event_base_new()
- */
-struct event_base *event_init(void);
-
-/**
-  Loop to process events.
-
-  Like event_base_dispatch(), but uses the "current" base.
-
-  @deprecated This function is deprecated because it is easily confused by
-    multiple calls to event_init(), and because it is not safe for
-    multithreaded use.  The replacement is event_base_dispatch().
-
-  @see event_base_dispatch(), event_init()
- */
-int event_dispatch(void);
-
-/**
-  Handle events.
-
-  This function behaves like event_base_loop(), but uses the "current" base
-
-  @deprecated This function is deprecated because it uses the event base from
-    the last call to event_init, and is therefore not safe for multithreaded
-    use.  The replacement is event_base_loop().
-
-  @see event_base_loop(), event_init()
-*/
-int event_loop(int);
-
-
-/**
-  Exit the event loop after the specified time.
-
-  This function behaves like event_base_loopexit(), except that it uses the
-  "current" base.
-
-  @deprecated This function is deprecated because it uses the event base from
-    the last call to event_init, and is therefore not safe for multithreaded
-    use.  The replacement is event_base_loopexit().
-
-  @see event_init, event_base_loopexit()
-  */
-int event_loopexit(const struct timeval *);
-
-
-/**
-  Abort the active event_loop() immediately.
-
-  This function behaves like event_base_loopbreakt(), except that it uses the
-  "current" base.
-
-  @deprecated This function is deprecated because it uses the event base from
-    the last call to event_init, and is therefore not safe for multithreaded
-    use.  The replacement is event_base_loopbreak().
-
-  @see event_base_loopbreak(), event_init()
- */
-int event_loopbreak(void);
-
-/**
-  Schedule a one-time event to occur.
-
-  @deprecated This function is obsolete, and has been replaced by
-    event_base_once(). Its use is deprecated because it relies on the
-    "current" base configured by event_init().
-
-  @see event_base_once()
- */
-int event_once(evutil_socket_t , short,
-    void (*)(evutil_socket_t, short, void *), void *, const struct timeval *);
-
-
-/**
-  Get the kernel event notification mechanism used by Libevent.
-
-  @deprecated This function is obsolete, and has been replaced by
-    event_base_get_method(). Its use is deprecated because it relies on the
-    "current" base configured by event_init().
-
-  @see event_base_get_method()
- */
-const char *event_get_method(void);
-
-
-/**
-  Set the number of different event priorities.
-
-  @deprecated This function is deprecated because it is easily confused by
-    multiple calls to event_init(), and because it is not safe for
-    multithreaded use.  The replacement is event_base_priority_init().
-
-  @see event_base_priority_init()
- */
-int	event_priority_init(int);
-
-/**
-  Prepare an event structure to be added.
-
-  @deprecated event_set() is not recommended for new code, because it requires
-     a subsequent call to event_base_set() to be safe under most circumstances.
-     Use event_assign() or event_new() instead.
- */
-void event_set(struct event *, evutil_socket_t, short, void (*)(evutil_socket_t, short, void *), void *);
-
-#define evtimer_set(ev, cb, arg)	event_set((ev), -1, 0, (cb), (arg))
-#define evsignal_set(ev, x, cb, arg)	\
-	event_set((ev), (x), EV_SIGNAL|EV_PERSIST, (cb), (arg))
-
-
-/**
-   @name timeout_* macros
-
-   @deprecated These macros are deprecated because their naming is inconsistent
-     with the rest of Libevent.  Use the evtimer_* macros instead.
-   @{
- */
-#define timeout_add(ev, tv)		event_add((ev), (tv))
-#define timeout_set(ev, cb, arg)	event_set((ev), -1, 0, (cb), (arg))
-#define timeout_del(ev)			event_del(ev)
-#define timeout_pending(ev, tv)		event_pending((ev), EV_TIMEOUT, (tv))
-#define timeout_initialized(ev)		event_initialized(ev)
-/**@}*/
-
-/**
-   @name signal_* macros
-
-   @deprecated These macros are deprecated because their naming is inconsistent
-     with the rest of Libevent.  Use the evsignal_* macros instead.
-   @{
- */
-#define signal_add(ev, tv)		event_add((ev), (tv))
-#define signal_set(ev, x, cb, arg)				\
-	event_set((ev), (x), EV_SIGNAL|EV_PERSIST, (cb), (arg))
-#define signal_del(ev)			event_del(ev)
-#define signal_pending(ev, tv)		event_pending((ev), EV_SIGNAL, (tv))
-#define signal_initialized(ev)		event_initialized(ev)
-/**@}*/
-
-#ifndef EVENT_FD
-/* These macros are obsolete; use event_get_fd and event_get_signal instead. */
-#define EVENT_FD(ev)		((int)event_get_fd(ev))
-#define EVENT_SIGNAL(ev)	event_get_signal(ev)
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _EVENT2_EVENT_COMPAT_H_ */
+/*
+ * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
+ * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EVENT2_EVENT_COMPAT_H_INCLUDED_
+#define EVENT2_EVENT_COMPAT_H_INCLUDED_
+
+/** @file event2/event_compat.h
+
+  Potentially non-threadsafe versions of the functions in event.h: provided
+  only for backwards compatibility.
+
+  In the oldest versions of Libevent, event_base was not a first-class
+  structure.  Instead, there was a single event base that every function
+  manipulated.  Later, when separate event bases were added, the old functions
+  that didn't take an event_base argument needed to work by manipulating the
+  "current" event base.  This could lead to thread-safety issues, and obscure,
+  hard-to-diagnose bugs.
+
+  @deprecated All functions in this file are by definition deprecated.
+ */
+#include <event2/visibility.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <event2/event-config.h>
+#ifdef EVENT__HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef EVENT__HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+
+/* For int types. */
+#include <event2/util.h>
+
+/**
+  Initialize the event API.
+
+  The event API needs to be initialized with event_init() before it can be
+  used.  Sets the global current base that gets used for events that have no
+  base associated with them.
+
+  @deprecated This function is deprecated because it replaces the "current"
+    event_base, and is totally unsafe for multithreaded use.  The replacement
+    is event_base_new().
+
+  @see event_base_set(), event_base_new()
+ */
+EVENT2_EXPORT_SYMBOL
+struct event_base *event_init(void);
+
+/**
+  Loop to process events.
+
+  Like event_base_dispatch(), but uses the "current" base.
+
+  @deprecated This function is deprecated because it is easily confused by
+    multiple calls to event_init(), and because it is not safe for
+    multithreaded use.  The replacement is event_base_dispatch().
+
+  @see event_base_dispatch(), event_init()
+ */
+EVENT2_EXPORT_SYMBOL
+int event_dispatch(void);
+
+/**
+  Handle events.
+
+  This function behaves like event_base_loop(), but uses the "current" base
+
+  @deprecated This function is deprecated because it uses the event base from
+    the last call to event_init, and is therefore not safe for multithreaded
+    use.  The replacement is event_base_loop().
+
+  @see event_base_loop(), event_init()
+*/
+EVENT2_EXPORT_SYMBOL
+int event_loop(int);
+
+
+/**
+  Exit the event loop after the specified time.
+
+  This function behaves like event_base_loopexit(), except that it uses the
+  "current" base.
+
+  @deprecated This function is deprecated because it uses the event base from
+    the last call to event_init, and is therefore not safe for multithreaded
+    use.  The replacement is event_base_loopexit().
+
+  @see event_init, event_base_loopexit()
+  */
+EVENT2_EXPORT_SYMBOL
+int event_loopexit(const struct timeval *);
+
+
+/**
+  Abort the active event_loop() immediately.
+
+  This function behaves like event_base_loopbreakt(), except that it uses the
+  "current" base.
+
+  @deprecated This function is deprecated because it uses the event base from
+    the last call to event_init, and is therefore not safe for multithreaded
+    use.  The replacement is event_base_loopbreak().
+
+  @see event_base_loopbreak(), event_init()
+ */
+EVENT2_EXPORT_SYMBOL
+int event_loopbreak(void);
+
+/**
+  Schedule a one-time event to occur.
+
+  @deprecated This function is obsolete, and has been replaced by
+    event_base_once(). Its use is deprecated because it relies on the
+    "current" base configured by event_init().
+
+  @see event_base_once()
+ */
+EVENT2_EXPORT_SYMBOL
+int event_once(evutil_socket_t , short,
+    void (*)(evutil_socket_t, short, void *), void *, const struct timeval *);
+
+
+/**
+  Get the kernel event notification mechanism used by Libevent.
+
+  @deprecated This function is obsolete, and has been replaced by
+    event_base_get_method(). Its use is deprecated because it relies on the
+    "current" base configured by event_init().
+
+  @see event_base_get_method()
+ */
+EVENT2_EXPORT_SYMBOL
+const char *event_get_method(void);
+
+
+/**
+  Set the number of different event priorities.
+
+  @deprecated This function is deprecated because it is easily confused by
+    multiple calls to event_init(), and because it is not safe for
+    multithreaded use.  The replacement is event_base_priority_init().
+
+  @see event_base_priority_init()
+ */
+EVENT2_EXPORT_SYMBOL
+int	event_priority_init(int);
+
+/**
+  Prepare an event structure to be added.
+
+  @deprecated event_set() is not recommended for new code, because it requires
+     a subsequent call to event_base_set() to be safe under most circumstances.
+     Use event_assign() or event_new() instead.
+ */
+EVENT2_EXPORT_SYMBOL
+void event_set(struct event *, evutil_socket_t, short, void (*)(evutil_socket_t, short, void *), void *);
+
+#define evtimer_set(ev, cb, arg)	event_set((ev), -1, 0, (cb), (arg))
+#define evsignal_set(ev, x, cb, arg)	\
+	event_set((ev), (x), EV_SIGNAL|EV_PERSIST, (cb), (arg))
+
+
+/**
+   @name timeout_* macros
+
+   @deprecated These macros are deprecated because their naming is inconsistent
+     with the rest of Libevent.  Use the evtimer_* macros instead.
+   @{
+ */
+#define timeout_add(ev, tv)		event_add((ev), (tv))
+#define timeout_set(ev, cb, arg)	event_set((ev), -1, 0, (cb), (arg))
+#define timeout_del(ev)			event_del(ev)
+#define timeout_pending(ev, tv)		event_pending((ev), EV_TIMEOUT, (tv))
+#define timeout_initialized(ev)		event_initialized(ev)
+/**@}*/
+
+/**
+   @name signal_* macros
+
+   @deprecated These macros are deprecated because their naming is inconsistent
+     with the rest of Libevent.  Use the evsignal_* macros instead.
+   @{
+ */
+#define signal_add(ev, tv)		event_add((ev), (tv))
+#define signal_set(ev, x, cb, arg)				\
+	event_set((ev), (x), EV_SIGNAL|EV_PERSIST, (cb), (arg))
+#define signal_del(ev)			event_del(ev)
+#define signal_pending(ev, tv)		event_pending((ev), EV_SIGNAL, (tv))
+#define signal_initialized(ev)		event_initialized(ev)
+/**@}*/
+
+#ifndef EVENT_FD
+/* These macros are obsolete; use event_get_fd and event_get_signal instead. */
+#define EVENT_FD(ev)		((int)event_get_fd(ev))
+#define EVENT_SIGNAL(ev)	event_get_signal(ev)
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EVENT2_EVENT_COMPAT_H_INCLUDED_ */
Index: dep/libevent/inc/event2/event_struct.h
===================================================================
--- dep/libevent/inc/event2/event_struct.h	(revision 49)
+++ dep/libevent/inc/event2/event_struct.h	(working copy)
@@ -1,141 +1,180 @@
-/*
- * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
- * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _EVENT2_EVENT_STRUCT_H_
-#define _EVENT2_EVENT_STRUCT_H_
-
-/** @file event2/event_struct.h
-
-  Structures used by event.h.  Using these structures directly WILL harm
-  forward compatibility: be careful.
-
-  No field declared in this file should be used directly in user code.  Except
-  for historical reasons, these fields would not be exposed at all.
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <event2/event-config.h>
-#ifdef _EVENT_HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-#ifdef _EVENT_HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif
-
-/* For int types. */
-#include <event2/util.h>
-
-/* For evkeyvalq */
-#include <event2/keyvalq_struct.h>
-
-#define EVLIST_TIMEOUT	0x01
-#define EVLIST_INSERTED	0x02
-#define EVLIST_SIGNAL	0x04
-#define EVLIST_ACTIVE	0x08
-#define EVLIST_INTERNAL	0x10
-#define EVLIST_INIT	0x80
-
-/* EVLIST_X_ Private space: 0x1000-0xf000 */
-#define EVLIST_ALL	(0xf000 | 0x9f)
-
-/* Fix so that people don't have to run with <sys/queue.h> */
-#ifndef TAILQ_ENTRY
-#define _EVENT_DEFINED_TQENTRY
-#define TAILQ_ENTRY(type)						\
-struct {								\
-	struct type *tqe_next;	/* next element */			\
-	struct type **tqe_prev;	/* address of previous next element */	\
-}
-#endif /* !TAILQ_ENTRY */
-
-#ifndef TAILQ_HEAD
-#define _EVENT_DEFINED_TQHEAD
-#define TAILQ_HEAD(name, type)			\
-struct name {					\
-	struct type *tqh_first;			\
-	struct type **tqh_last;			\
-}
-#endif
-
-struct event_base;
-struct event {
-	TAILQ_ENTRY(event) ev_active_next;
-	TAILQ_ENTRY(event) ev_next;
-	/* for managing timeouts */
-	union {
-		TAILQ_ENTRY(event) ev_next_with_common_timeout;
-		int min_heap_idx;
-	} ev_timeout_pos;
-	evutil_socket_t ev_fd;
-
-	struct event_base *ev_base;
-
-	union {
-		/* used for io events */
-		struct {
-			TAILQ_ENTRY(event) ev_io_next;
-			struct timeval ev_timeout;
-		} ev_io;
-
-		/* used by signal events */
-		struct {
-			TAILQ_ENTRY(event) ev_signal_next;
-			short ev_ncalls;
-			/* Allows deletes in callback */
-			short *ev_pncalls;
-		} ev_signal;
-	} _ev;
-
-	short ev_events;
-	short ev_res;		/* result passed to event callback */
-	short ev_flags;
-	ev_uint8_t ev_pri;	/* smaller numbers are higher priority */
-	ev_uint8_t ev_closure;
-	struct timeval ev_timeout;
-
-	/* allows us to adopt for different types of events */
-	void (*ev_callback)(evutil_socket_t, short, void *arg);
-	void *ev_arg;
-};
-
-TAILQ_HEAD (event_list, event);
-
-#ifdef _EVENT_DEFINED_TQENTRY
-#undef TAILQ_ENTRY
-#endif
-
-#ifdef _EVENT_DEFINED_TQHEAD
-#undef TAILQ_HEAD
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _EVENT2_EVENT_STRUCT_H_ */
+/*
+ * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
+ * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EVENT2_EVENT_STRUCT_H_INCLUDED_
+#define EVENT2_EVENT_STRUCT_H_INCLUDED_
+
+/** @file event2/event_struct.h
+
+  Structures used by event.h.  Using these structures directly WILL harm
+  forward compatibility: be careful.
+
+  No field declared in this file should be used directly in user code.  Except
+  for historical reasons, these fields would not be exposed at all.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <event2/event-config.h>
+#ifdef EVENT__HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef EVENT__HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+
+/* For int types. */
+#include <event2/util.h>
+
+/* For evkeyvalq */
+#include <event2/keyvalq_struct.h>
+
+#define EVLIST_TIMEOUT	    0x01
+#define EVLIST_INSERTED	    0x02
+#define EVLIST_SIGNAL	    0x04
+#define EVLIST_ACTIVE	    0x08
+#define EVLIST_INTERNAL	    0x10
+#define EVLIST_ACTIVE_LATER 0x20
+#define EVLIST_FINALIZING   0x40
+#define EVLIST_INIT	    0x80
+
+#define EVLIST_ALL          0xff
+
+/* Fix so that people don't have to run with <sys/queue.h> */
+#ifndef TAILQ_ENTRY
+#define EVENT_DEFINED_TQENTRY_
+#define TAILQ_ENTRY(type)						\
+struct {								\
+	struct type *tqe_next;	/* next element */			\
+	struct type **tqe_prev;	/* address of previous next element */	\
+}
+#endif /* !TAILQ_ENTRY */
+
+#ifndef TAILQ_HEAD
+#define EVENT_DEFINED_TQHEAD_
+#define TAILQ_HEAD(name, type)			\
+struct name {					\
+	struct type *tqh_first;			\
+	struct type **tqh_last;			\
+}
+#endif
+
+/* Fix so that people don't have to run with <sys/queue.h> */
+#ifndef LIST_ENTRY
+#define EVENT_DEFINED_LISTENTRY_
+#define LIST_ENTRY(type)						\
+struct {								\
+	struct type *le_next;	/* next element */			\
+	struct type **le_prev;	/* address of previous next element */	\
+}
+#endif /* !LIST_ENTRY */
+
+#ifndef LIST_HEAD
+#define EVENT_DEFINED_LISTHEAD_
+#define LIST_HEAD(name, type)						\
+struct name {								\
+	struct type *lh_first;  /* first element */			\
+	}
+#endif /* !LIST_HEAD */
+
+struct event;
+
+struct event_callback {
+	TAILQ_ENTRY(event_callback) evcb_active_next;
+	short evcb_flags;
+	ev_uint8_t evcb_pri;	/* smaller numbers are higher priority */
+	ev_uint8_t evcb_closure;
+	/* allows us to adopt for different types of events */
+        union {
+		void (*evcb_callback)(evutil_socket_t, short, void *);
+		void (*evcb_selfcb)(struct event_callback *, void *);
+		void (*evcb_evfinalize)(struct event *, void *);
+		void (*evcb_cbfinalize)(struct event_callback *, void *);
+	} evcb_cb_union;
+	void *evcb_arg;
+};
+
+struct event_base;
+struct event {
+	struct event_callback ev_evcallback;
+
+	/* for managing timeouts */
+	union {
+		TAILQ_ENTRY(event) ev_next_with_common_timeout;
+		int min_heap_idx;
+	} ev_timeout_pos;
+	evutil_socket_t ev_fd;
+
+	struct event_base *ev_base;
+
+	union {
+		/* used for io events */
+		struct {
+			LIST_ENTRY (event) ev_io_next;
+			struct timeval ev_timeout;
+		} ev_io;
+
+		/* used by signal events */
+		struct {
+			LIST_ENTRY (event) ev_signal_next;
+			short ev_ncalls;
+			/* Allows deletes in callback */
+			short *ev_pncalls;
+		} ev_signal;
+	} ev_;
+
+	short ev_events;
+	short ev_res;		/* result passed to event callback */
+	struct timeval ev_timeout;
+};
+
+TAILQ_HEAD (event_list, event);
+
+#ifdef EVENT_DEFINED_TQENTRY_
+#undef TAILQ_ENTRY
+#endif
+
+#ifdef EVENT_DEFINED_TQHEAD_
+#undef TAILQ_HEAD
+#endif
+
+LIST_HEAD (event_dlist, event); 
+
+#ifdef EVENT_DEFINED_LISTENTRY_
+#undef LIST_ENTRY
+#endif
+
+#ifdef EVENT_DEFINED_LISTHEAD_
+#undef LIST_HEAD
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EVENT2_EVENT_STRUCT_H_INCLUDED_ */
Index: dep/libevent/inc/event2/http.h
===================================================================
--- dep/libevent/inc/event2/http.h	(revision 49)
+++ dep/libevent/inc/event2/http.h	(working copy)
@@ -1,863 +1,1189 @@
-/*
- * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
- * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _EVENT2_HTTP_H_
-#define _EVENT2_HTTP_H_
-
-/* For int types. */
-#include <event2/util.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* In case we haven't included the right headers yet. */
-struct evbuffer;
-struct event_base;
-
-/** @file event2/http.h
- *
- * Basic support for HTTP serving.
- *
- * As Libevent is a library for dealing with event notification and most
- * interesting applications are networked today, I have often found the
- * need to write HTTP code.  The following prototypes and definitions provide
- * an application with a minimal interface for making HTTP requests and for
- * creating a very simple HTTP server.
- */
-
-/* Response codes */
-#define HTTP_OK			200	/**< request completed ok */
-#define HTTP_NOCONTENT		204	/**< request does not have content */
-#define HTTP_MOVEPERM		301	/**< the uri moved permanently */
-#define HTTP_MOVETEMP		302	/**< the uri moved temporarily */
-#define HTTP_NOTMODIFIED	304	/**< page was not modified from last */
-#define HTTP_BADREQUEST		400	/**< invalid http request was made */
-#define HTTP_NOTFOUND		404	/**< could not find content for uri */
-#define HTTP_BADMETHOD		405 	/**< method not allowed for this uri */
-#define HTTP_ENTITYTOOLARGE	413	/**<  */
-#define HTTP_EXPECTATIONFAILED	417	/**< we can't handle this expectation */
-#define HTTP_INTERNAL           500     /**< internal error */
-#define HTTP_NOTIMPLEMENTED     501     /**< not implemented */
-#define HTTP_SERVUNAVAIL	503	/**< the server is not available */
-
-struct evhttp;
-struct evhttp_request;
-struct evkeyvalq;
-struct evhttp_bound_socket;
-struct evconnlistener;
-
-/**
- * Create a new HTTP server.
- *
- * @param base (optional) the event base to receive the HTTP events
- * @return a pointer to a newly initialized evhttp server structure
- * @see evhttp_free()
- */
-struct evhttp *evhttp_new(struct event_base *base);
-
-/**
- * Binds an HTTP server on the specified address and port.
- *
- * Can be called multiple times to bind the same http server
- * to multiple different ports.
- *
- * @param http a pointer to an evhttp object
- * @param address a string containing the IP address to listen(2) on
- * @param port the port number to listen on
- * @return 0 on success, -1 on failure.
- * @see evhttp_accept_socket()
- */
-int evhttp_bind_socket(struct evhttp *http, const char *address, ev_uint16_t port);
-
-/**
- * Like evhttp_bind_socket(), but returns a handle for referencing the socket.
- *
- * The returned pointer is not valid after \a http is freed.
- *
- * @param http a pointer to an evhttp object
- * @param address a string containing the IP address to listen(2) on
- * @param port the port number to listen on
- * @return Handle for the socket on success, NULL on failure.
- * @see evhttp_bind_socket(), evhttp_del_accept_socket()
- */
-struct evhttp_bound_socket *evhttp_bind_socket_with_handle(struct evhttp *http, const char *address, ev_uint16_t port);
-
-/**
- * Makes an HTTP server accept connections on the specified socket.
- *
- * This may be useful to create a socket and then fork multiple instances
- * of an http server, or when a socket has been communicated via file
- * descriptor passing in situations where an http servers does not have
- * permissions to bind to a low-numbered port.
- *
- * Can be called multiple times to have the http server listen to
- * multiple different sockets.
- *
- * @param http a pointer to an evhttp object
- * @param fd a socket fd that is ready for accepting connections
- * @return 0 on success, -1 on failure.
- * @see evhttp_bind_socket()
- */
-int evhttp_accept_socket(struct evhttp *http, evutil_socket_t fd);
-
-/**
- * Like evhttp_accept_socket(), but returns a handle for referencing the socket.
- *
- * The returned pointer is not valid after \a http is freed.
- *
- * @param http a pointer to an evhttp object
- * @param fd a socket fd that is ready for accepting connections
- * @return Handle for the socket on success, NULL on failure.
- * @see evhttp_accept_socket(), evhttp_del_accept_socket()
- */
-struct evhttp_bound_socket *evhttp_accept_socket_with_handle(struct evhttp *http, evutil_socket_t fd);
-
-/**
- * The most low-level evhttp_bind/accept method: takes an evconnlistener, and
- * returns an evhttp_bound_socket.  The listener will be freed when the bound
- * socket is freed.
- */
-struct evhttp_bound_socket *evhttp_bind_listener(struct evhttp *http, struct evconnlistener *listener);
-
-/**
- * Return the listener used to implement a bound socket.
- */
-struct evconnlistener *evhttp_bound_socket_get_listener(struct evhttp_bound_socket *bound);
-
-/**
- * Makes an HTTP server stop accepting connections on the specified socket
- *
- * This may be useful when a socket has been sent via file descriptor passing
- * and is no longer needed by the current process.
- *
- * If you created this bound socket with evhttp_bind_socket_with_handle or
- * evhttp_accept_socket_with_handle, this function closes the fd you provided.
- * If you created this bound socket with evhttp_bind_listener, this function
- * frees the listener you provided.
- *
- * \a bound_socket is an invalid pointer after this call returns.
- *
- * @param http a pointer to an evhttp object
- * @param bound_socket a handle returned by evhttp_{bind,accept}_socket_with_handle
- * @see evhttp_bind_socket_with_handle(), evhttp_accept_socket_with_handle()
- */
-void evhttp_del_accept_socket(struct evhttp *http, struct evhttp_bound_socket *bound_socket);
-
-/**
- * Get the raw file descriptor referenced by an evhttp_bound_socket.
- *
- * @param bound_socket a handle returned by evhttp_{bind,accept}_socket_with_handle
- * @return the file descriptor used by the bound socket
- * @see evhttp_bind_socket_with_handle(), evhttp_accept_socket_with_handle()
- */
-evutil_socket_t evhttp_bound_socket_get_fd(struct evhttp_bound_socket *bound_socket);
-
-/**
- * Free the previously created HTTP server.
- *
- * Works only if no requests are currently being served.
- *
- * @param http the evhttp server object to be freed
- * @see evhttp_start()
- */
-void evhttp_free(struct evhttp* http);
-
-/** XXX Document. */
-void evhttp_set_max_headers_size(struct evhttp* http, ev_ssize_t max_headers_size);
-/** XXX Document. */
-void evhttp_set_max_body_size(struct evhttp* http, ev_ssize_t max_body_size);
-
-/**
-  Sets the what HTTP methods are supported in requests accepted by this
-  server, and passed to user callbacks.
-
-  If not supported they will generate a "405 Method not allowed" response.
-
-  By default this includes the following methods: GET, POST, HEAD, PUT, DELETE
-
-  @param http the http server on which to set the methods
-  @param methods bit mask constructed from evhttp_cmd_type values
-*/
-void evhttp_set_allowed_methods(struct evhttp* http, ev_uint16_t methods);
-
-/**
-   Set a callback for a specified URI
-
-   @param http the http sever on which to set the callback
-   @param path the path for which to invoke the callback
-   @param cb the callback function that gets invoked on requesting path
-   @param cb_arg an additional context argument for the callback
-   @return 0 on success, -1 if the callback existed already, -2 on failure
-*/
-int evhttp_set_cb(struct evhttp *http, const char *path,
-    void (*cb)(struct evhttp_request *, void *), void *cb_arg);
-
-/** Removes the callback for a specified URI */
-int evhttp_del_cb(struct evhttp *, const char *);
-
-/**
-    Set a callback for all requests that are not caught by specific callbacks
-
-    Invokes the specified callback for all requests that do not match any of
-    the previously specified request paths.  This is catchall for requests not
-    specifically configured with evhttp_set_cb().
-
-    @param http the evhttp server object for which to set the callback
-    @param cb the callback to invoke for any unmatched requests
-    @param arg an context argument for the callback
-*/
-void evhttp_set_gencb(struct evhttp *http,
-    void (*cb)(struct evhttp_request *, void *), void *arg);
-
-/**
-   Adds a virtual host to the http server.
-
-   A virtual host is a newly initialized evhttp object that has request
-   callbacks set on it via evhttp_set_cb() or evhttp_set_gencb().  It
-   most not have any listing sockets associated with it.
-
-   If the virtual host has not been removed by the time that evhttp_free()
-   is called on the main http server, it will be automatically freed, too.
-
-   It is possible to have hierarchical vhosts.  For example: A vhost
-   with the pattern *.example.com may have other vhosts with patterns
-   foo.example.com and bar.example.com associated with it.
-
-   @param http the evhttp object to which to add a virtual host
-   @param pattern the glob pattern against which the hostname is matched.
-     The match is case insensitive and follows otherwise regular shell
-     matching.
-   @param vhost the virtual host to add the regular http server.
-   @return 0 on success, -1 on failure
-   @see evhttp_remove_virtual_host()
-*/
-int evhttp_add_virtual_host(struct evhttp* http, const char *pattern,
-    struct evhttp* vhost);
-
-/**
-   Removes a virtual host from the http server.
-
-   @param http the evhttp object from which to remove the virtual host
-   @param vhost the virtual host to remove from the regular http server.
-   @return 0 on success, -1 on failure
-   @see evhttp_add_virtual_host()
-*/
-int evhttp_remove_virtual_host(struct evhttp* http, struct evhttp* vhost);
-
-/**
-   Add a server alias to an http object. The http object can be a virtual
-   host or the main server.
-
-   @param http the evhttp object
-   @param alias the alias to add
-   @see evhttp_add_remove_alias()
-*/
-int evhttp_add_server_alias(struct evhttp *http, const char *alias);
-
-/**
-   Remove a server alias from an http object.
-
-   @param http the evhttp object
-   @param alias the alias to remove
-   @see evhttp_add_server_alias()
-*/
-int evhttp_remove_server_alias(struct evhttp *http, const char *alias);
-
-/**
- * Set the timeout for an HTTP request.
- *
- * @param http an evhttp object
- * @param timeout_in_secs the timeout, in seconds
- */
-void evhttp_set_timeout(struct evhttp *http, int timeout_in_secs);
-
-/* Request/Response functionality */
-
-/**
- * Send an HTML error message to the client.
- *
- * @param req a request object
- * @param error the HTTP error code
- * @param reason a brief explanation of the error.  If this is NULL, we'll
- *    just use the standard meaning of the error code.
- */
-void evhttp_send_error(struct evhttp_request *req, int error,
-    const char *reason);
-
-/**
- * Send an HTML reply to the client.
- *
- * The body of the reply consists of the data in databuf.  After calling
- * evhttp_send_reply() databuf will be empty, but the buffer is still
- * owned by the caller and needs to be deallocated by the caller if
- * necessary.
- *
- * @param req a request object
- * @param code the HTTP response code to send
- * @param reason a brief message to send with the response code
- * @param databuf the body of the response
- */
-void evhttp_send_reply(struct evhttp_request *req, int code,
-    const char *reason, struct evbuffer *databuf);
-
-/* Low-level response interface, for streaming/chunked replies */
-
-/**
-   Initiate a reply that uses Transfer-Encoding chunked.
-
-   This allows the caller to stream the reply back to the client and is
-   useful when either not all of the reply data is immediately available
-   or when sending very large replies.
-
-   The caller needs to supply data chunks with evhttp_send_reply_chunk()
-   and complete the reply by calling evhttp_send_reply_end().
-
-   @param req a request object
-   @param code the HTTP response code to send
-   @param reason a brief message to send with the response code
-*/
-void evhttp_send_reply_start(struct evhttp_request *req, int code,
-    const char *reason);
-
-/**
-   Send another data chunk as part of an ongoing chunked reply.
-
-   The reply chunk consists of the data in databuf.  After calling
-   evhttp_send_reply_chunk() databuf will be empty, but the buffer is
-   still owned by the caller and needs to be deallocated by the caller
-   if necessary.
-
-   @param req a request object
-   @param databuf the data chunk to send as part of the reply.
-*/
-void evhttp_send_reply_chunk(struct evhttp_request *req,
-    struct evbuffer *databuf);
-/**
-   Complete a chunked reply, freeing the request as appropriate.
-
-   @param req a request object
-*/
-void evhttp_send_reply_end(struct evhttp_request *req);
-
-/*
- * Interfaces for making requests
- */
-
-/** The different request types supported by evhttp.  These are as specified
- * in RFC2616, except for PATCH which is specified by RFC5789.
- *
- * By default, only some of these methods are accepted and passed to user
- * callbacks; use evhttp_set_allowed_methods() to change which methods
- * are allowed.
- */
-enum evhttp_cmd_type {
-	EVHTTP_REQ_GET     = 1 << 0,
-	EVHTTP_REQ_POST    = 1 << 1,
-	EVHTTP_REQ_HEAD    = 1 << 2,
-	EVHTTP_REQ_PUT     = 1 << 3,
-	EVHTTP_REQ_DELETE  = 1 << 4,
-	EVHTTP_REQ_OPTIONS = 1 << 5,
-	EVHTTP_REQ_TRACE   = 1 << 6,
-	EVHTTP_REQ_CONNECT = 1 << 7,
-	EVHTTP_REQ_PATCH   = 1 << 8
-};
-
-/** a request object can represent either a request or a reply */
-enum evhttp_request_kind { EVHTTP_REQUEST, EVHTTP_RESPONSE };
-
-/**
- * Creates a new request object that needs to be filled in with the request
- * parameters.  The callback is executed when the request completed or an
- * error occurred.
- */
-struct evhttp_request *evhttp_request_new(
-	void (*cb)(struct evhttp_request *, void *), void *arg);
-
-/**
- * Enable delivery of chunks to requestor.
- * @param cb will be called after every read of data with the same argument
- *           as the completion callback. Will never be called on an empty
- *           response. May drain the input buffer; it will be drained
- *           automatically on return.
- */
-void evhttp_request_set_chunked_cb(struct evhttp_request *,
-    void (*cb)(struct evhttp_request *, void *));
-
-/** Frees the request object and removes associated events. */
-void evhttp_request_free(struct evhttp_request *req);
-
-struct evdns_base;
-
-/**
- * A connection object that can be used to for making HTTP requests.  The
- * connection object tries to resolve address and establish the connection
- * when it is given an http request object.
- *
- * @param base the event_base to use for handling the connection
- * @param dnsbase the dns_base to use for resolving host names; if not
- *     specified host name resolution will block.
- * @param address the address to which to connect
- * @param port the port to connect to
- * @return an evhttp_connection object that can be used for making requests
- */
-struct evhttp_connection *evhttp_connection_base_new(
-	struct event_base *base, struct evdns_base *dnsbase,
-	const char *address, unsigned short port);
-
-/**
- * Return the bufferevent that an evhttp_connection is using.
- */
-struct bufferevent *evhttp_connection_get_bufferevent(
-	struct evhttp_connection *evcon);
-
-/** Takes ownership of the request object
- *
- * Can be used in a request callback to keep onto the request until
- * evhttp_request_free() is explicitly called by the user.
- */
-void evhttp_request_own(struct evhttp_request *req);
-
-/** Returns 1 if the request is owned by the user */
-int evhttp_request_is_owned(struct evhttp_request *req);
-
-/**
- * Returns the connection object associated with the request or NULL
- *
- * The user needs to either free the request explicitly or call
- * evhttp_send_reply_end().
- */
-struct evhttp_connection *evhttp_request_get_connection(struct evhttp_request *req);
-
-/**
- * Returns the underlying event_base for this connection
- */
-struct event_base *evhttp_connection_get_base(struct evhttp_connection *req);
-
-void evhttp_connection_set_max_headers_size(struct evhttp_connection *evcon,
-    ev_ssize_t new_max_headers_size);
-
-void evhttp_connection_set_max_body_size(struct evhttp_connection* evcon,
-    ev_ssize_t new_max_body_size);
-
-/** Frees an http connection */
-void evhttp_connection_free(struct evhttp_connection *evcon);
-
-/** sets the ip address from which http connections are made */
-void evhttp_connection_set_local_address(struct evhttp_connection *evcon,
-    const char *address);
-
-/** sets the local port from which http connections are made */
-void evhttp_connection_set_local_port(struct evhttp_connection *evcon,
-    ev_uint16_t port);
-
-/** Sets the timeout for events related to this connection */
-void evhttp_connection_set_timeout(struct evhttp_connection *evcon,
-    int timeout_in_secs);
-
-/** Sets the retry limit for this connection - -1 repeats indefinitely */
-void evhttp_connection_set_retries(struct evhttp_connection *evcon,
-    int retry_max);
-
-/** Set a callback for connection close. */
-void evhttp_connection_set_closecb(struct evhttp_connection *evcon,
-    void (*)(struct evhttp_connection *, void *), void *);
-
-/** Get the remote address and port associated with this connection. */
-void evhttp_connection_get_peer(struct evhttp_connection *evcon,
-    char **address, ev_uint16_t *port);
-
-/**
-    Make an HTTP request over the specified connection.
-
-    The connection gets ownership of the request.  On failure, the
-    request object is no longer valid as it has been freed.
-
-    @param evcon the evhttp_connection object over which to send the request
-    @param req the previously created and configured request object
-    @param type the request type EVHTTP_REQ_GET, EVHTTP_REQ_POST, etc.
-    @param uri the URI associated with the request
-    @return 0 on success, -1 on failure
-    @see evhttp_cancel_request()
-*/
-int evhttp_make_request(struct evhttp_connection *evcon,
-    struct evhttp_request *req,
-    enum evhttp_cmd_type type, const char *uri);
-
-/**
-   Cancels a pending HTTP request.
-
-   Cancels an ongoing HTTP request.  The callback associated with this request
-   is not executed and the request object is freed.  If the request is
-   currently being processed, e.g. it is ongoing, the corresponding
-   evhttp_connection object is going to get reset.
-
-   A request cannot be canceled if its callback has executed already. A request
-   may be canceled reentrantly from its chunked callback.
-
-   @param req the evhttp_request to cancel; req becomes invalid after this call.
-*/
-void evhttp_cancel_request(struct evhttp_request *req);
-
-/**
- * A structure to hold a parsed URI or Relative-Ref conforming to RFC3986.
- */
-struct evhttp_uri;
-
-/** Returns the request URI */
-const char *evhttp_request_get_uri(const struct evhttp_request *req);
-/** Returns the request URI (parsed) */
-const struct evhttp_uri *evhttp_request_get_evhttp_uri(const struct evhttp_request *req);
-/** Returns the request command */
-enum evhttp_cmd_type evhttp_request_get_command(const struct evhttp_request *req);
-
-int evhttp_request_get_response_code(const struct evhttp_request *req);
-
-/** Returns the input headers */
-struct evkeyvalq *evhttp_request_get_input_headers(struct evhttp_request *req);
-/** Returns the output headers */
-struct evkeyvalq *evhttp_request_get_output_headers(struct evhttp_request *req);
-/** Returns the input buffer */
-struct evbuffer *evhttp_request_get_input_buffer(struct evhttp_request *req);
-/** Returns the output buffer */
-struct evbuffer *evhttp_request_get_output_buffer(struct evhttp_request *req);
-/** Returns the host associated with the request. If a client sends an absolute
-    URI, the host part of that is preferred. Otherwise, the input headers are
-    searched for a Host: header. NULL is returned if no absolute URI or Host:
-    header is provided. */
-const char *evhttp_request_get_host(struct evhttp_request *req);
-
-/* Interfaces for dealing with HTTP headers */
-
-/**
-   Finds the value belonging to a header.
-
-   @param headers the evkeyvalq object in which to find the header
-   @param key the name of the header to find
-   @returns a pointer to the value for the header or NULL if the header
-     count not be found.
-   @see evhttp_add_header(), evhttp_remove_header()
-*/
-const char *evhttp_find_header(const struct evkeyvalq *headers,
-    const char *key);
-
-/**
-   Removes a header from a list of existing headers.
-
-   @param headers the evkeyvalq object from which to remove a header
-   @param key the name of the header to remove
-   @returns 0 if the header was removed, -1  otherwise.
-   @see evhttp_find_header(), evhttp_add_header()
-*/
-int evhttp_remove_header(struct evkeyvalq *headers, const char *key);
-
-/**
-   Adds a header to a list of existing headers.
-
-   @param headers the evkeyvalq object to which to add a header
-   @param key the name of the header
-   @param value the value belonging to the header
-   @returns 0 on success, -1  otherwise.
-   @see evhttp_find_header(), evhttp_clear_headers()
-*/
-int evhttp_add_header(struct evkeyvalq *headers, const char *key, const char *value);
-
-/**
-   Removes all headers from the header list.
-
-   @param headers the evkeyvalq object from which to remove all headers
-*/
-void evhttp_clear_headers(struct evkeyvalq *headers);
-
-/* Miscellaneous utility functions */
-
-
-/**
-   Helper function to encode a string for inclusion in a URI.  All
-   characters are replaced by their hex-escaped (%22) equivalents,
-   except for characters explicitly unreserved by RFC3986 -- that is,
-   ASCII alphanumeric characters, hyphen, dot, underscore, and tilde.
-
-   The returned string must be freed by the caller.
-
-   @param str an unencoded string
-   @return a newly allocated URI-encoded string or NULL on failure
- */
-char *evhttp_encode_uri(const char *str);
-
-/**
-   As evhttp_encode_uri, but if 'size' is nonnegative, treat the string
-   as being 'size' bytes long.  This allows you to encode strings that
-   may contain 0-valued bytes.
-
-   The returned string must be freed by the caller.
-
-   @param str an unencoded string
-   @param size the length of the string to encode, or -1 if the string
-      is NUL-terminated
-   @param space_to_plus if true, space characters in 'str' are encoded
-      as +, not %20.
-   @return a newly allocate URI-encoded string, or NULL on failure.
- */
-char *evhttp_uriencode(const char *str, ev_ssize_t size, int space_to_plus);
-
-/**
-  Helper function to sort of decode a URI-encoded string.  Unlike
-  evhttp_get_decoded_uri, it decodes all plus characters that appear
-  _after_ the first question mark character, but no plusses that occur
-  before.  This is not a good way to decode URIs in whole or in part.
-
-  The returned string must be freed by the caller
-
-  @deprecated  This function is deprecated; you probably want to use
-     evhttp_get_decoded_uri instead.
-
-  @param uri an encoded URI
-  @return a newly allocated unencoded URI or NULL on failure
- */
-char *evhttp_decode_uri(const char *uri);
-
-/**
-  Helper function to decode a URI-escaped string or HTTP parameter.
-
-  If 'decode_plus' is 1, then we decode the string as an HTTP parameter
-  value, and convert all plus ('+') characters to spaces.  If
-  'decode_plus' is 0, we leave all plus characters unchanged.
-
-  The returned string must be freed by the caller.
-
-  @param uri a URI-encode encoded URI
-  @param decode_plus determines whether we convert '+' to sapce.
-  @param size_out if size_out is not NULL, *size_out is set to the size of the
-     returned string
-  @return a newly allocated unencoded URI or NULL on failure
- */
-char *evhttp_uridecode(const char *uri, int decode_plus,
-    size_t *size_out);
-
-/**
-   Helper function to parse out arguments in a query.
-
-   Parsing a URI like
-
-      http://foo.com/?q=test&s=some+thing
-
-   will result in two entries in the key value queue.
-
-   The first entry is: key="q", value="test"
-   The second entry is: key="s", value="some thing"
-
-   @deprecated This function is deprecated as of Libevent 2.0.9.  Use
-     evhttp_uri_parse and evhttp_parse_query_str instead.
-
-   @param uri the request URI
-   @param headers the head of the evkeyval queue
-   @return 0 on success, -1 on failure
- */
-int evhttp_parse_query(const char *uri, struct evkeyvalq *headers);
-
-/**
-   Helper function to parse out arguments from the query portion of an
-   HTTP URI.
-
-   Parsing a query string like
-
-     q=test&s=some+thing
-
-   will result in two entries in the key value queue.
-
-   The first entry is: key="q", value="test"
-   The second entry is: key="s", value="some thing"
-
-   @param query_parse the query portion of the URI
-   @param headers the head of the evkeyval queue
-   @return 0 on success, -1 on failure
- */
-int evhttp_parse_query_str(const char *uri, struct evkeyvalq *headers);
-
-/**
- * Escape HTML character entities in a string.
- *
- * Replaces <, >, ", ' and & with &lt;, &gt;, &quot;,
- * &#039; and &amp; correspondingly.
- *
- * The returned string needs to be freed by the caller.
- *
- * @param html an unescaped HTML string
- * @return an escaped HTML string or NULL on error
- */
-char *evhttp_htmlescape(const char *html);
-
-/**
- * Return a new empty evhttp_uri with no fields set.
- */
-struct evhttp_uri *evhttp_uri_new(void);
-
-/**
- * Changes the flags set on a given URI.  See EVHTTP_URI_* for
- * a list of flags.
- **/
-void evhttp_uri_set_flags(struct evhttp_uri *uri, unsigned flags);
-
-/** Return the scheme of an evhttp_uri, or NULL if there is no scheme has
- * been set and the evhttp_uri contains a Relative-Ref. */
-const char *evhttp_uri_get_scheme(const struct evhttp_uri *uri);
-/**
- * Return the userinfo part of an evhttp_uri, or NULL if it has no userinfo
- * set.
- */
-const char *evhttp_uri_get_userinfo(const struct evhttp_uri *uri);
-/**
- * Return the host part of an evhttp_uri, or NULL if it has no host set.
- * The host may either be a regular hostname (conforming to the RFC 3986
- * "regname" production), or an IPv4 address, or the empty string, or a
- * bracketed IPv6 address, or a bracketed 'IP-Future' address.
- *
- * Note that having a NULL host means that the URI has no authority
- * section, but having an empty-string host means that the URI has an
- * authority section with no host part.  For example,
- * "mailto:user@example.com" has a host of NULL, but "file:///etc/motd"
- * has a host of "".
- */
-const char *evhttp_uri_get_host(const struct evhttp_uri *uri);
-/** Return the port part of an evhttp_uri, or -1 if there is no port set. */
-int evhttp_uri_get_port(const struct evhttp_uri *uri);
-/** Return the path part of an evhttp_uri, or NULL if it has no path set */
-const char *evhttp_uri_get_path(const struct evhttp_uri *uri);
-/** Return the query part of an evhttp_uri (excluding the leading "?"), or
- * NULL if it has no query set */
-const char *evhttp_uri_get_query(const struct evhttp_uri *uri);
-/** Return the fragment part of an evhttp_uri (excluding the leading "#"),
- * or NULL if it has no fragment set */
-const char *evhttp_uri_get_fragment(const struct evhttp_uri *uri);
-
-/** Set the scheme of an evhttp_uri, or clear the scheme if scheme==NULL.
- * Returns 0 on success, -1 if scheme is not well-formed. */
-int evhttp_uri_set_scheme(struct evhttp_uri *uri, const char *scheme);
-/** Set the userinfo of an evhttp_uri, or clear the userinfo if userinfo==NULL.
- * Returns 0 on success, -1 if userinfo is not well-formed. */
-int evhttp_uri_set_userinfo(struct evhttp_uri *uri, const char *userinfo);
-/** Set the host of an evhttp_uri, or clear the host if host==NULL.
- * Returns 0 on success, -1 if host is not well-formed. */
-int evhttp_uri_set_host(struct evhttp_uri *uri, const char *host);
-/** Set the port of an evhttp_uri, or clear the port if port==-1.
- * Returns 0 on success, -1 if port is not well-formed. */
-int evhttp_uri_set_port(struct evhttp_uri *uri, int port);
-/** Set the path of an evhttp_uri, or clear the path if path==NULL.
- * Returns 0 on success, -1 if path is not well-formed. */
-int evhttp_uri_set_path(struct evhttp_uri *uri, const char *path);
-/** Set the query of an evhttp_uri, or clear the query if query==NULL.
- * The query should not include a leading "?".
- * Returns 0 on success, -1 if query is not well-formed. */
-int evhttp_uri_set_query(struct evhttp_uri *uri, const char *query);
-/** Set the fragment of an evhttp_uri, or clear the fragment if fragment==NULL.
- * The fragment should not include a leading "#".
- * Returns 0 on success, -1 if fragment is not well-formed. */
-int evhttp_uri_set_fragment(struct evhttp_uri *uri, const char *fragment);
-
-/**
- * Helper function to parse a URI-Reference as specified by RFC3986.
- *
- * This function matches the URI-Reference production from RFC3986,
- * which includes both URIs like
- *
- *    scheme://[[userinfo]@]foo.com[:port]]/[path][?query][#fragment]
- *
- *  and relative-refs like
- *
- *    [path][?query][#fragment]
- *
- * Any optional elements portions not present in the original URI are
- * left set to NULL in the resulting evhttp_uri.  If no port is
- * specified, the port is set to -1.
- *
- * Note that no decoding is performed on percent-escaped characters in
- * the string; if you want to parse them, use evhttp_uridecode or
- * evhttp_parse_query_str as appropriate.
- *
- * Note also that most URI schemes will have additional constraints that
- * this function does not know about, and cannot check.  For example,
- * mailto://www.example.com/cgi-bin/fortune.pl is not a reasonable
- * mailto url, http://www.example.com:99999/ is not a reasonable HTTP
- * URL, and ftp:username@example.com is not a reasonable FTP URL.
- * Nevertheless, all of these URLs conform to RFC3986, and this function
- * accepts all of them as valid.
- *
- * @param source_uri the request URI
- * @param flags Zero or more EVHTTP_URI_* flags to affect the behavior
- *              of the parser.
- * @return uri container to hold parsed data, or NULL if there is error
- * @see evhttp_uri_free()
- */
-struct evhttp_uri *evhttp_uri_parse_with_flags(const char *source_uri,
-    unsigned flags);
-
-/** Tolerate URIs that do not conform to RFC3986.
- *
- * Unfortunately, some HTTP clients generate URIs that, according to RFC3986,
- * are not conformant URIs.  If you need to support these URIs, you can
- * do so by passing this flag to evhttp_uri_parse_with_flags.
- *
- * Currently, these changes are:
- * <ul>
- *   <li> Nonconformant URIs are allowed to contain otherwise unreasonable
- *        characters in their path, query, and fragment components.
- * </ul>
- */
-#define EVHTTP_URI_NONCONFORMANT 0x01
-
-/** Alias for evhttp_uri_parse_with_flags(source_uri, 0) */
-struct evhttp_uri *evhttp_uri_parse(const char *source_uri);
-
-/**
- * Free all memory allocated for a parsed uri.  Only use this for URIs
- * generated by evhttp_uri_parse.
- *
- * @param uri container with parsed data
- * @see evhttp_uri_parse()
- */
-void evhttp_uri_free(struct evhttp_uri *uri);
-
-/**
- * Join together the uri parts from parsed data to form a URI-Reference.
- *
- * Note that no escaping of reserved characters is done on the members
- * of the evhttp_uri, so the generated string might not be a valid URI
- * unless the members of evhttp_uri are themselves valid.
- *
- * @param uri container with parsed data
- * @param buf destination buffer
- * @param limit destination buffer size
- * @return an joined uri as string or NULL on error
- * @see evhttp_uri_parse()
- */
-char *evhttp_uri_join(struct evhttp_uri *uri, char *buf, size_t limit);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _EVENT2_HTTP_H_ */
+/*
+ * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
+ * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EVENT2_HTTP_H_INCLUDED_
+#define EVENT2_HTTP_H_INCLUDED_
+
+/* For int types. */
+#include <event2/util.h>
+#include <event2/visibility.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* In case we haven't included the right headers yet. */
+struct evbuffer;
+struct event_base;
+struct bufferevent;
+struct evhttp_connection;
+
+/** @file event2/http.h
+ *
+ * Basic support for HTTP serving.
+ *
+ * As Libevent is a library for dealing with event notification and most
+ * interesting applications are networked today, I have often found the
+ * need to write HTTP code.  The following prototypes and definitions provide
+ * an application with a minimal interface for making HTTP requests and for
+ * creating a very simple HTTP server.
+ */
+
+/* Response codes */
+#define HTTP_OK			200	/**< request completed ok */
+#define HTTP_NOCONTENT		204	/**< request does not have content */
+#define HTTP_MOVEPERM		301	/**< the uri moved permanently */
+#define HTTP_MOVETEMP		302	/**< the uri moved temporarily */
+#define HTTP_NOTMODIFIED	304	/**< page was not modified from last */
+#define HTTP_BADREQUEST		400	/**< invalid http request was made */
+#define HTTP_NOTFOUND		404	/**< could not find content for uri */
+#define HTTP_BADMETHOD		405 	/**< method not allowed for this uri */
+#define HTTP_ENTITYTOOLARGE	413	/**<  */
+#define HTTP_EXPECTATIONFAILED	417	/**< we can't handle this expectation */
+#define HTTP_INTERNAL           500     /**< internal error */
+#define HTTP_NOTIMPLEMENTED     501     /**< not implemented */
+#define HTTP_SERVUNAVAIL	503	/**< the server is not available */
+
+struct evhttp;
+struct evhttp_request;
+struct evkeyvalq;
+struct evhttp_bound_socket;
+struct evconnlistener;
+struct evdns_base;
+
+/**
+ * Create a new HTTP server.
+ *
+ * @param base (optional) the event base to receive the HTTP events
+ * @return a pointer to a newly initialized evhttp server structure
+ * @see evhttp_free()
+ */
+EVENT2_EXPORT_SYMBOL
+struct evhttp *evhttp_new(struct event_base *base);
+
+/**
+ * Binds an HTTP server on the specified address and port.
+ *
+ * Can be called multiple times to bind the same http server
+ * to multiple different ports.
+ *
+ * @param http a pointer to an evhttp object
+ * @param address a string containing the IP address to listen(2) on
+ * @param port the port number to listen on
+ * @return 0 on success, -1 on failure.
+ * @see evhttp_accept_socket()
+ */
+EVENT2_EXPORT_SYMBOL
+int evhttp_bind_socket(struct evhttp *http, const char *address, ev_uint16_t port);
+
+/**
+ * Like evhttp_bind_socket(), but returns a handle for referencing the socket.
+ *
+ * The returned pointer is not valid after \a http is freed.
+ *
+ * @param http a pointer to an evhttp object
+ * @param address a string containing the IP address to listen(2) on
+ * @param port the port number to listen on
+ * @return Handle for the socket on success, NULL on failure.
+ * @see evhttp_bind_socket(), evhttp_del_accept_socket()
+ */
+EVENT2_EXPORT_SYMBOL
+struct evhttp_bound_socket *evhttp_bind_socket_with_handle(struct evhttp *http, const char *address, ev_uint16_t port);
+
+/**
+ * Makes an HTTP server accept connections on the specified socket.
+ *
+ * This may be useful to create a socket and then fork multiple instances
+ * of an http server, or when a socket has been communicated via file
+ * descriptor passing in situations where an http servers does not have
+ * permissions to bind to a low-numbered port.
+ *
+ * Can be called multiple times to have the http server listen to
+ * multiple different sockets.
+ *
+ * @param http a pointer to an evhttp object
+ * @param fd a socket fd that is ready for accepting connections
+ * @return 0 on success, -1 on failure.
+ * @see evhttp_bind_socket()
+ */
+EVENT2_EXPORT_SYMBOL
+int evhttp_accept_socket(struct evhttp *http, evutil_socket_t fd);
+
+/**
+ * Like evhttp_accept_socket(), but returns a handle for referencing the socket.
+ *
+ * The returned pointer is not valid after \a http is freed.
+ *
+ * @param http a pointer to an evhttp object
+ * @param fd a socket fd that is ready for accepting connections
+ * @return Handle for the socket on success, NULL on failure.
+ * @see evhttp_accept_socket(), evhttp_del_accept_socket()
+ */
+EVENT2_EXPORT_SYMBOL
+struct evhttp_bound_socket *evhttp_accept_socket_with_handle(struct evhttp *http, evutil_socket_t fd);
+
+/**
+ * The most low-level evhttp_bind/accept method: takes an evconnlistener, and
+ * returns an evhttp_bound_socket.  The listener will be freed when the bound
+ * socket is freed.
+ */
+EVENT2_EXPORT_SYMBOL
+struct evhttp_bound_socket *evhttp_bind_listener(struct evhttp *http, struct evconnlistener *listener);
+
+/**
+ * Return the listener used to implement a bound socket.
+ */
+EVENT2_EXPORT_SYMBOL
+struct evconnlistener *evhttp_bound_socket_get_listener(struct evhttp_bound_socket *bound);
+
+typedef void evhttp_bound_socket_foreach_fn(struct evhttp_bound_socket *, void *);
+/**
+ * Applies the function specified in the first argument to all
+ * evhttp_bound_sockets associated with "http". The user must not
+ * attempt to free or remove any connections, sockets or listeners
+ * in the callback "function".
+ *
+ * @param http pointer to an evhttp object
+ * @param function function to apply to every bound socket
+ * @param argument pointer value passed to function for every socket iterated
+ */
+EVENT2_EXPORT_SYMBOL
+void evhttp_foreach_bound_socket(struct evhttp *http, evhttp_bound_socket_foreach_fn *function, void *argument);
+
+/**
+ * Makes an HTTP server stop accepting connections on the specified socket
+ *
+ * This may be useful when a socket has been sent via file descriptor passing
+ * and is no longer needed by the current process.
+ *
+ * If you created this bound socket with evhttp_bind_socket_with_handle or
+ * evhttp_accept_socket_with_handle, this function closes the fd you provided.
+ * If you created this bound socket with evhttp_bind_listener, this function
+ * frees the listener you provided.
+ *
+ * \a bound_socket is an invalid pointer after this call returns.
+ *
+ * @param http a pointer to an evhttp object
+ * @param bound_socket a handle returned by evhttp_{bind,accept}_socket_with_handle
+ * @see evhttp_bind_socket_with_handle(), evhttp_accept_socket_with_handle()
+ */
+EVENT2_EXPORT_SYMBOL
+void evhttp_del_accept_socket(struct evhttp *http, struct evhttp_bound_socket *bound_socket);
+
+/**
+ * Get the raw file descriptor referenced by an evhttp_bound_socket.
+ *
+ * @param bound_socket a handle returned by evhttp_{bind,accept}_socket_with_handle
+ * @return the file descriptor used by the bound socket
+ * @see evhttp_bind_socket_with_handle(), evhttp_accept_socket_with_handle()
+ */
+EVENT2_EXPORT_SYMBOL
+evutil_socket_t evhttp_bound_socket_get_fd(struct evhttp_bound_socket *bound_socket);
+
+/**
+ * Free the previously created HTTP server.
+ *
+ * Works only if no requests are currently being served.
+ *
+ * @param http the evhttp server object to be freed
+ * @see evhttp_start()
+ */
+EVENT2_EXPORT_SYMBOL
+void evhttp_free(struct evhttp* http);
+
+/** XXX Document. */
+EVENT2_EXPORT_SYMBOL
+void evhttp_set_max_headers_size(struct evhttp* http, ev_ssize_t max_headers_size);
+/** XXX Document. */
+EVENT2_EXPORT_SYMBOL
+void evhttp_set_max_body_size(struct evhttp* http, ev_ssize_t max_body_size);
+
+/**
+  Set the value to use for the Content-Type header when none was provided. If
+  the content type string is NULL, the Content-Type header will not be
+  automatically added.
+
+  @param http the http server on which to set the default content type
+  @param content_type the value for the Content-Type header
+*/
+EVENT2_EXPORT_SYMBOL
+void evhttp_set_default_content_type(struct evhttp *http,
+	const char *content_type);
+
+/**
+  Sets the what HTTP methods are supported in requests accepted by this
+  server, and passed to user callbacks.
+
+  If not supported they will generate a "405 Method not allowed" response.
+
+  By default this includes the following methods: GET, POST, HEAD, PUT, DELETE
+
+  @param http the http server on which to set the methods
+  @param methods bit mask constructed from evhttp_cmd_type values
+*/
+EVENT2_EXPORT_SYMBOL
+void evhttp_set_allowed_methods(struct evhttp* http, ev_uint16_t methods);
+
+/**
+   Set a callback for a specified URI
+
+   @param http the http sever on which to set the callback
+   @param path the path for which to invoke the callback
+   @param cb the callback function that gets invoked on requesting path
+   @param cb_arg an additional context argument for the callback
+   @return 0 on success, -1 if the callback existed already, -2 on failure
+*/
+EVENT2_EXPORT_SYMBOL
+int evhttp_set_cb(struct evhttp *http, const char *path,
+    void (*cb)(struct evhttp_request *, void *), void *cb_arg);
+
+/** Removes the callback for a specified URI */
+EVENT2_EXPORT_SYMBOL
+int evhttp_del_cb(struct evhttp *, const char *);
+
+/**
+    Set a callback for all requests that are not caught by specific callbacks
+
+    Invokes the specified callback for all requests that do not match any of
+    the previously specified request paths.  This is catchall for requests not
+    specifically configured with evhttp_set_cb().
+
+    @param http the evhttp server object for which to set the callback
+    @param cb the callback to invoke for any unmatched requests
+    @param arg an context argument for the callback
+*/
+EVENT2_EXPORT_SYMBOL
+void evhttp_set_gencb(struct evhttp *http,
+    void (*cb)(struct evhttp_request *, void *), void *arg);
+
+/**
+   Set a callback used to create new bufferevents for connections
+   to a given evhttp object.
+
+   You can use this to override the default bufferevent type -- for example,
+   to make this evhttp object use SSL bufferevents rather than unencrypted
+   ones.
+
+   New bufferevents must be allocated with no fd set on them.
+
+   @param http the evhttp server object for which to set the callback
+   @param cb the callback to invoke for incoming connections
+   @param arg an context argument for the callback
+ */
+EVENT2_EXPORT_SYMBOL
+void evhttp_set_bevcb(struct evhttp *http,
+    struct bufferevent *(*cb)(struct event_base *, void *), void *arg);
+
+/**
+   Adds a virtual host to the http server.
+
+   A virtual host is a newly initialized evhttp object that has request
+   callbacks set on it via evhttp_set_cb() or evhttp_set_gencb().  It
+   most not have any listing sockets associated with it.
+
+   If the virtual host has not been removed by the time that evhttp_free()
+   is called on the main http server, it will be automatically freed, too.
+
+   It is possible to have hierarchical vhosts.  For example: A vhost
+   with the pattern *.example.com may have other vhosts with patterns
+   foo.example.com and bar.example.com associated with it.
+
+   @param http the evhttp object to which to add a virtual host
+   @param pattern the glob pattern against which the hostname is matched.
+     The match is case insensitive and follows otherwise regular shell
+     matching.
+   @param vhost the virtual host to add the regular http server.
+   @return 0 on success, -1 on failure
+   @see evhttp_remove_virtual_host()
+*/
+EVENT2_EXPORT_SYMBOL
+int evhttp_add_virtual_host(struct evhttp* http, const char *pattern,
+    struct evhttp* vhost);
+
+/**
+   Removes a virtual host from the http server.
+
+   @param http the evhttp object from which to remove the virtual host
+   @param vhost the virtual host to remove from the regular http server.
+   @return 0 on success, -1 on failure
+   @see evhttp_add_virtual_host()
+*/
+EVENT2_EXPORT_SYMBOL
+int evhttp_remove_virtual_host(struct evhttp* http, struct evhttp* vhost);
+
+/**
+   Add a server alias to an http object. The http object can be a virtual
+   host or the main server.
+
+   @param http the evhttp object
+   @param alias the alias to add
+   @see evhttp_add_remove_alias()
+*/
+EVENT2_EXPORT_SYMBOL
+int evhttp_add_server_alias(struct evhttp *http, const char *alias);
+
+/**
+   Remove a server alias from an http object.
+
+   @param http the evhttp object
+   @param alias the alias to remove
+   @see evhttp_add_server_alias()
+*/
+EVENT2_EXPORT_SYMBOL
+int evhttp_remove_server_alias(struct evhttp *http, const char *alias);
+
+/**
+ * Set the timeout for an HTTP request.
+ *
+ * @param http an evhttp object
+ * @param timeout_in_secs the timeout, in seconds
+ */
+EVENT2_EXPORT_SYMBOL
+void evhttp_set_timeout(struct evhttp *http, int timeout_in_secs);
+
+/**
+ * Set the timeout for an HTTP request.
+ *
+ * @param http an evhttp object
+ * @param tv the timeout, or NULL
+ */
+EVENT2_EXPORT_SYMBOL
+void evhttp_set_timeout_tv(struct evhttp *http, const struct timeval* tv);
+
+/* Read all the clients body, and only after this respond with an error if the
+ * clients body exceed max_body_size */
+#define EVHTTP_SERVER_LINGERING_CLOSE	0x0001
+/**
+ * Set connection flags for HTTP server.
+ *
+ * @see EVHTTP_SERVER_*
+ * @return 0 on success, otherwise non zero (for example if flag doesn't
+ * supported).
+ */
+EVENT2_EXPORT_SYMBOL
+int evhttp_set_flags(struct evhttp *http, int flags);
+
+/* Request/Response functionality */
+
+/**
+ * Send an HTML error message to the client.
+ *
+ * @param req a request object
+ * @param error the HTTP error code
+ * @param reason a brief explanation of the error.  If this is NULL, we'll
+ *    just use the standard meaning of the error code.
+ */
+EVENT2_EXPORT_SYMBOL
+void evhttp_send_error(struct evhttp_request *req, int error,
+    const char *reason);
+
+/**
+ * Send an HTML reply to the client.
+ *
+ * The body of the reply consists of the data in databuf.  After calling
+ * evhttp_send_reply() databuf will be empty, but the buffer is still
+ * owned by the caller and needs to be deallocated by the caller if
+ * necessary.
+ *
+ * @param req a request object
+ * @param code the HTTP response code to send
+ * @param reason a brief message to send with the response code
+ * @param databuf the body of the response
+ */
+EVENT2_EXPORT_SYMBOL
+void evhttp_send_reply(struct evhttp_request *req, int code,
+    const char *reason, struct evbuffer *databuf);
+
+/* Low-level response interface, for streaming/chunked replies */
+
+/**
+   Initiate a reply that uses Transfer-Encoding chunked.
+
+   This allows the caller to stream the reply back to the client and is
+   useful when either not all of the reply data is immediately available
+   or when sending very large replies.
+
+   The caller needs to supply data chunks with evhttp_send_reply_chunk()
+   and complete the reply by calling evhttp_send_reply_end().
+
+   @param req a request object
+   @param code the HTTP response code to send
+   @param reason a brief message to send with the response code
+*/
+EVENT2_EXPORT_SYMBOL
+void evhttp_send_reply_start(struct evhttp_request *req, int code,
+    const char *reason);
+
+/**
+   Send another data chunk as part of an ongoing chunked reply.
+
+   The reply chunk consists of the data in databuf.  After calling
+   evhttp_send_reply_chunk() databuf will be empty, but the buffer is
+   still owned by the caller and needs to be deallocated by the caller
+   if necessary.
+
+   @param req a request object
+   @param databuf the data chunk to send as part of the reply.
+*/
+EVENT2_EXPORT_SYMBOL
+void evhttp_send_reply_chunk(struct evhttp_request *req,
+    struct evbuffer *databuf);
+
+/**
+   Send another data chunk as part of an ongoing chunked reply.
+
+   The reply chunk consists of the data in databuf.  After calling
+   evhttp_send_reply_chunk() databuf will be empty, but the buffer is
+   still owned by the caller and needs to be deallocated by the caller
+   if necessary.
+
+   @param req a request object
+   @param databuf the data chunk to send as part of the reply.
+   @param cb callback funcion
+   @param call back's argument.
+*/
+EVENT2_EXPORT_SYMBOL
+void evhttp_send_reply_chunk_with_cb(struct evhttp_request *, struct evbuffer *,
+    void (*cb)(struct evhttp_connection *, void *), void *arg);
+
+/**
+   Complete a chunked reply, freeing the request as appropriate.
+
+   @param req a request object
+*/
+EVENT2_EXPORT_SYMBOL
+void evhttp_send_reply_end(struct evhttp_request *req);
+
+/*
+ * Interfaces for making requests
+ */
+
+/** The different request types supported by evhttp.  These are as specified
+ * in RFC2616, except for PATCH which is specified by RFC5789.
+ *
+ * By default, only some of these methods are accepted and passed to user
+ * callbacks; use evhttp_set_allowed_methods() to change which methods
+ * are allowed.
+ */
+enum evhttp_cmd_type {
+	EVHTTP_REQ_GET     = 1 << 0,
+	EVHTTP_REQ_POST    = 1 << 1,
+	EVHTTP_REQ_HEAD    = 1 << 2,
+	EVHTTP_REQ_PUT     = 1 << 3,
+	EVHTTP_REQ_DELETE  = 1 << 4,
+	EVHTTP_REQ_OPTIONS = 1 << 5,
+	EVHTTP_REQ_TRACE   = 1 << 6,
+	EVHTTP_REQ_CONNECT = 1 << 7,
+	EVHTTP_REQ_PATCH   = 1 << 8
+};
+
+/** a request object can represent either a request or a reply */
+enum evhttp_request_kind { EVHTTP_REQUEST, EVHTTP_RESPONSE };
+
+/**
+ * Create and return a connection object that can be used to for making HTTP
+ * requests.  The connection object tries to resolve address and establish the
+ * connection when it is given an http request object.
+ *
+ * @param base the event_base to use for handling the connection
+ * @param dnsbase the dns_base to use for resolving host names; if not
+ *     specified host name resolution will block.
+ * @param bev a bufferevent to use for connecting to the server; if NULL, a
+ *     socket-based bufferevent will be created.  This buffrevent will be freed
+ *     when the connection closes.  It must have no fd set on it.
+ * @param address the address to which to connect
+ * @param port the port to connect to
+ * @return an evhttp_connection object that can be used for making requests
+ */
+EVENT2_EXPORT_SYMBOL
+struct evhttp_connection *evhttp_connection_base_bufferevent_new(
+	struct event_base *base, struct evdns_base *dnsbase, struct bufferevent* bev, const char *address, unsigned short port);
+
+/**
+ * Return the bufferevent that an evhttp_connection is using.
+ */
+EVENT2_EXPORT_SYMBOL
+struct bufferevent* evhttp_connection_get_bufferevent(struct evhttp_connection *evcon);
+
+/**
+ * Return the HTTP server associated with this connection, or NULL.
+ */
+EVENT2_EXPORT_SYMBOL
+struct evhttp *evhttp_connection_get_server(struct evhttp_connection *evcon);
+
+/**
+ * Creates a new request object that needs to be filled in with the request
+ * parameters.  The callback is executed when the request completed or an
+ * error occurred.
+ */
+EVENT2_EXPORT_SYMBOL
+struct evhttp_request *evhttp_request_new(
+	void (*cb)(struct evhttp_request *, void *), void *arg);
+
+/**
+ * Enable delivery of chunks to requestor.
+ * @param cb will be called after every read of data with the same argument
+ *           as the completion callback. Will never be called on an empty
+ *           response. May drain the input buffer; it will be drained
+ *           automatically on return.
+ */
+EVENT2_EXPORT_SYMBOL
+void evhttp_request_set_chunked_cb(struct evhttp_request *,
+    void (*cb)(struct evhttp_request *, void *));
+
+/**
+ * Register callback for additional parsing of request headers.
+ * @param cb will be called after receiving and parsing the full header.
+ * It allows analyzing the header and possibly closing the connection
+ * by returning a value < 0.
+ */
+EVENT2_EXPORT_SYMBOL
+void evhttp_request_set_header_cb(struct evhttp_request *,
+    int (*cb)(struct evhttp_request *, void *));
+
+/**
+ * The different error types supported by evhttp
+ *
+ * @see evhttp_request_set_error_cb()
+ */
+enum evhttp_request_error {
+  /**
+   * Timeout reached, also @see evhttp_connection_set_timeout()
+   */
+  EVREQ_HTTP_TIMEOUT,
+  /**
+   * EOF reached
+   */
+  EVREQ_HTTP_EOF,
+  /**
+   * Error while reading header, or invalid header
+   */
+  EVREQ_HTTP_INVALID_HEADER,
+  /**
+   * Error encountered while reading or writing
+   */
+  EVREQ_HTTP_BUFFER_ERROR,
+  /**
+   * The evhttp_cancel_request() called on this request.
+   */
+  EVREQ_HTTP_REQUEST_CANCEL,
+  /**
+   * Body is greater then evhttp_connection_set_max_body_size()
+   */
+  EVREQ_HTTP_DATA_TOO_LONG
+};
+/**
+ * Set a callback for errors
+ * @see evhttp_request_error for error types.
+ *
+ * On error, both the error callback and the regular callback will be called,
+ * error callback is called before the regular callback.
+ **/
+EVENT2_EXPORT_SYMBOL
+void evhttp_request_set_error_cb(struct evhttp_request *,
+    void (*)(enum evhttp_request_error, void *));
+
+/**
+ * Set a callback to be called on request completion of evhttp_send_* function.
+ *
+ * The callback function will be called on the completion of the request after
+ * the output data has been written and before the evhttp_request object
+ * is destroyed. This can be useful for tracking resources associated with a
+ * request (ex: timing metrics).
+ *
+ * @param req a request object
+ * @param cb callback function that will be called on request completion
+ * @param cb_arg an additional context argument for the callback
+ */
+EVENT2_EXPORT_SYMBOL
+void evhttp_request_set_on_complete_cb(struct evhttp_request *req,
+    void (*cb)(struct evhttp_request *, void *), void *cb_arg);
+
+/** Frees the request object and removes associated events. */
+EVENT2_EXPORT_SYMBOL
+void evhttp_request_free(struct evhttp_request *req);
+
+/**
+ * Create and return a connection object that can be used to for making HTTP
+ * requests.  The connection object tries to resolve address and establish the
+ * connection when it is given an http request object.
+ *
+ * @param base the event_base to use for handling the connection
+ * @param dnsbase the dns_base to use for resolving host names; if not
+ *     specified host name resolution will block.
+ * @param address the address to which to connect
+ * @param port the port to connect to
+ * @return an evhttp_connection object that can be used for making requests
+ */
+EVENT2_EXPORT_SYMBOL
+struct evhttp_connection *evhttp_connection_base_new(
+	struct event_base *base, struct evdns_base *dnsbase,
+	const char *address, unsigned short port);
+
+/**
+ * Set family hint for DNS requests.
+ */
+EVENT2_EXPORT_SYMBOL
+void evhttp_connection_set_family(struct evhttp_connection *evcon,
+	int family);
+
+/* reuse connection address on retry */
+#define EVHTTP_CON_REUSE_CONNECTED_ADDR	0x0008
+/* Try to read error, since server may already send and close
+ * connection, but if at that time we have some data to send then we
+ * can send get EPIPE and fail, while we can read that HTTP error. */
+#define EVHTTP_CON_READ_ON_WRITE_ERROR	0x0010
+/* @see EVHTTP_SERVER_LINGERING_CLOSE */
+#define EVHTTP_CON_LINGERING_CLOSE	0x0020
+/* Padding for public flags, @see EVHTTP_CON_* in http-internal.h */
+#define EVHTTP_CON_PUBLIC_FLAGS_END	0x100000
+/**
+ * Set connection flags.
+ *
+ * @see EVHTTP_CON_*
+ * @return 0 on success, otherwise non zero (for example if flag doesn't
+ * supported).
+ */
+EVENT2_EXPORT_SYMBOL
+int evhttp_connection_set_flags(struct evhttp_connection *evcon,
+	int flags);
+
+/** Takes ownership of the request object
+ *
+ * Can be used in a request callback to keep onto the request until
+ * evhttp_request_free() is explicitly called by the user.
+ */
+EVENT2_EXPORT_SYMBOL
+void evhttp_request_own(struct evhttp_request *req);
+
+/** Returns 1 if the request is owned by the user */
+EVENT2_EXPORT_SYMBOL
+int evhttp_request_is_owned(struct evhttp_request *req);
+
+/**
+ * Returns the connection object associated with the request or NULL
+ *
+ * The user needs to either free the request explicitly or call
+ * evhttp_send_reply_end().
+ */
+EVENT2_EXPORT_SYMBOL
+struct evhttp_connection *evhttp_request_get_connection(struct evhttp_request *req);
+
+/**
+ * Returns the underlying event_base for this connection
+ */
+EVENT2_EXPORT_SYMBOL
+struct event_base *evhttp_connection_get_base(struct evhttp_connection *req);
+
+EVENT2_EXPORT_SYMBOL
+void evhttp_connection_set_max_headers_size(struct evhttp_connection *evcon,
+    ev_ssize_t new_max_headers_size);
+
+EVENT2_EXPORT_SYMBOL
+void evhttp_connection_set_max_body_size(struct evhttp_connection* evcon,
+    ev_ssize_t new_max_body_size);
+
+/** Frees an http connection */
+EVENT2_EXPORT_SYMBOL
+void evhttp_connection_free(struct evhttp_connection *evcon);
+
+/** Disowns a given connection object
+ *
+ * Can be used to tell libevent to free the connection object after
+ * the last request has completed or failed.
+ */
+EVENT2_EXPORT_SYMBOL
+void evhttp_connection_free_on_completion(struct evhttp_connection *evcon);
+
+/** sets the ip address from which http connections are made */
+EVENT2_EXPORT_SYMBOL
+void evhttp_connection_set_local_address(struct evhttp_connection *evcon,
+    const char *address);
+
+/** sets the local port from which http connections are made */
+EVENT2_EXPORT_SYMBOL
+void evhttp_connection_set_local_port(struct evhttp_connection *evcon,
+    ev_uint16_t port);
+
+/** Sets the timeout in seconds for events related to this connection */
+EVENT2_EXPORT_SYMBOL
+void evhttp_connection_set_timeout(struct evhttp_connection *evcon,
+    int timeout_in_secs);
+
+/** Sets the timeout for events related to this connection.  Takes a struct
+ * timeval. */
+EVENT2_EXPORT_SYMBOL
+void evhttp_connection_set_timeout_tv(struct evhttp_connection *evcon,
+    const struct timeval *tv);
+
+/** Sets the delay before retrying requests on this connection. This is only
+ * used if evhttp_connection_set_retries is used to make the number of retries
+ * at least one. Each retry after the first is twice as long as the one before
+ * it. */
+EVENT2_EXPORT_SYMBOL
+void evhttp_connection_set_initial_retry_tv(struct evhttp_connection *evcon,
+    const struct timeval *tv);
+
+/** Sets the retry limit for this connection - -1 repeats indefinitely */
+EVENT2_EXPORT_SYMBOL
+void evhttp_connection_set_retries(struct evhttp_connection *evcon,
+    int retry_max);
+
+/** Set a callback for connection close. */
+EVENT2_EXPORT_SYMBOL
+void evhttp_connection_set_closecb(struct evhttp_connection *evcon,
+    void (*)(struct evhttp_connection *, void *), void *);
+
+/** Get the remote address and port associated with this connection. */
+EVENT2_EXPORT_SYMBOL
+void evhttp_connection_get_peer(struct evhttp_connection *evcon,
+    char **address, ev_uint16_t *port);
+
+/** Get the remote address associated with this connection.
+ * extracted from getpeername() OR from nameserver.
+ *
+ * @return NULL if getpeername() return non success,
+ * or connection is not connected,
+ * otherwise it return pointer to struct sockaddr_storage */
+EVENT2_EXPORT_SYMBOL
+const struct sockaddr*
+evhttp_connection_get_addr(struct evhttp_connection *evcon);
+
+/**
+    Make an HTTP request over the specified connection.
+
+    The connection gets ownership of the request.  On failure, the
+    request object is no longer valid as it has been freed.
+
+    @param evcon the evhttp_connection object over which to send the request
+    @param req the previously created and configured request object
+    @param type the request type EVHTTP_REQ_GET, EVHTTP_REQ_POST, etc.
+    @param uri the URI associated with the request
+    @return 0 on success, -1 on failure
+    @see evhttp_cancel_request()
+*/
+EVENT2_EXPORT_SYMBOL
+int evhttp_make_request(struct evhttp_connection *evcon,
+    struct evhttp_request *req,
+    enum evhttp_cmd_type type, const char *uri);
+
+/**
+   Cancels a pending HTTP request.
+
+   Cancels an ongoing HTTP request.  The callback associated with this request
+   is not executed and the request object is freed.  If the request is
+   currently being processed, e.g. it is ongoing, the corresponding
+   evhttp_connection object is going to get reset.
+
+   A request cannot be canceled if its callback has executed already. A request
+   may be canceled reentrantly from its chunked callback.
+
+   @param req the evhttp_request to cancel; req becomes invalid after this call.
+*/
+EVENT2_EXPORT_SYMBOL
+void evhttp_cancel_request(struct evhttp_request *req);
+
+/**
+ * A structure to hold a parsed URI or Relative-Ref conforming to RFC3986.
+ */
+struct evhttp_uri;
+
+/** Returns the request URI */
+EVENT2_EXPORT_SYMBOL
+const char *evhttp_request_get_uri(const struct evhttp_request *req);
+/** Returns the request URI (parsed) */
+EVENT2_EXPORT_SYMBOL
+const struct evhttp_uri *evhttp_request_get_evhttp_uri(const struct evhttp_request *req);
+/** Returns the request command */
+EVENT2_EXPORT_SYMBOL
+enum evhttp_cmd_type evhttp_request_get_command(const struct evhttp_request *req);
+
+EVENT2_EXPORT_SYMBOL
+int evhttp_request_get_response_code(const struct evhttp_request *req);
+EVENT2_EXPORT_SYMBOL
+const char * evhttp_request_get_response_code_line(const struct evhttp_request *req);
+
+/** Returns the input headers */
+EVENT2_EXPORT_SYMBOL
+struct evkeyvalq *evhttp_request_get_input_headers(struct evhttp_request *req);
+/** Returns the output headers */
+EVENT2_EXPORT_SYMBOL
+struct evkeyvalq *evhttp_request_get_output_headers(struct evhttp_request *req);
+/** Returns the input buffer */
+EVENT2_EXPORT_SYMBOL
+struct evbuffer *evhttp_request_get_input_buffer(struct evhttp_request *req);
+/** Returns the output buffer */
+EVENT2_EXPORT_SYMBOL
+struct evbuffer *evhttp_request_get_output_buffer(struct evhttp_request *req);
+/** Returns the host associated with the request. If a client sends an absolute
+    URI, the host part of that is preferred. Otherwise, the input headers are
+    searched for a Host: header. NULL is returned if no absolute URI or Host:
+    header is provided. */
+EVENT2_EXPORT_SYMBOL
+const char *evhttp_request_get_host(struct evhttp_request *req);
+
+/* Interfaces for dealing with HTTP headers */
+
+/**
+   Finds the value belonging to a header.
+
+   @param headers the evkeyvalq object in which to find the header
+   @param key the name of the header to find
+   @returns a pointer to the value for the header or NULL if the header
+     could not be found.
+   @see evhttp_add_header(), evhttp_remove_header()
+*/
+EVENT2_EXPORT_SYMBOL
+const char *evhttp_find_header(const struct evkeyvalq *headers,
+    const char *key);
+
+/**
+   Removes a header from a list of existing headers.
+
+   @param headers the evkeyvalq object from which to remove a header
+   @param key the name of the header to remove
+   @returns 0 if the header was removed, -1  otherwise.
+   @see evhttp_find_header(), evhttp_add_header()
+*/
+EVENT2_EXPORT_SYMBOL
+int evhttp_remove_header(struct evkeyvalq *headers, const char *key);
+
+/**
+   Adds a header to a list of existing headers.
+
+   @param headers the evkeyvalq object to which to add a header
+   @param key the name of the header
+   @param value the value belonging to the header
+   @returns 0 on success, -1  otherwise.
+   @see evhttp_find_header(), evhttp_clear_headers()
+*/
+EVENT2_EXPORT_SYMBOL
+int evhttp_add_header(struct evkeyvalq *headers, const char *key, const char *value);
+
+/**
+   Removes all headers from the header list.
+
+   @param headers the evkeyvalq object from which to remove all headers
+*/
+EVENT2_EXPORT_SYMBOL
+void evhttp_clear_headers(struct evkeyvalq *headers);
+
+/* Miscellaneous utility functions */
+
+
+/**
+   Helper function to encode a string for inclusion in a URI.  All
+   characters are replaced by their hex-escaped (%22) equivalents,
+   except for characters explicitly unreserved by RFC3986 -- that is,
+   ASCII alphanumeric characters, hyphen, dot, underscore, and tilde.
+
+   The returned string must be freed by the caller.
+
+   @param str an unencoded string
+   @return a newly allocated URI-encoded string or NULL on failure
+ */
+EVENT2_EXPORT_SYMBOL
+char *evhttp_encode_uri(const char *str);
+
+/**
+   As evhttp_encode_uri, but if 'size' is nonnegative, treat the string
+   as being 'size' bytes long.  This allows you to encode strings that
+   may contain 0-valued bytes.
+
+   The returned string must be freed by the caller.
+
+   @param str an unencoded string
+   @param size the length of the string to encode, or -1 if the string
+      is NUL-terminated
+   @param space_to_plus if true, space characters in 'str' are encoded
+      as +, not %20.
+   @return a newly allocate URI-encoded string, or NULL on failure.
+ */
+EVENT2_EXPORT_SYMBOL
+char *evhttp_uriencode(const char *str, ev_ssize_t size, int space_to_plus);
+
+/**
+  Helper function to sort of decode a URI-encoded string.  Unlike
+  evhttp_get_decoded_uri, it decodes all plus characters that appear
+  _after_ the first question mark character, but no plusses that occur
+  before.  This is not a good way to decode URIs in whole or in part.
+
+  The returned string must be freed by the caller
+
+  @deprecated  This function is deprecated; you probably want to use
+     evhttp_get_decoded_uri instead.
+
+  @param uri an encoded URI
+  @return a newly allocated unencoded URI or NULL on failure
+ */
+EVENT2_EXPORT_SYMBOL
+char *evhttp_decode_uri(const char *uri);
+
+/**
+  Helper function to decode a URI-escaped string or HTTP parameter.
+
+  If 'decode_plus' is 1, then we decode the string as an HTTP parameter
+  value, and convert all plus ('+') characters to spaces.  If
+  'decode_plus' is 0, we leave all plus characters unchanged.
+
+  The returned string must be freed by the caller.
+
+  @param uri a URI-encode encoded URI
+  @param decode_plus determines whether we convert '+' to space.
+  @param size_out if size_out is not NULL, *size_out is set to the size of the
+     returned string
+  @return a newly allocated unencoded URI or NULL on failure
+ */
+EVENT2_EXPORT_SYMBOL
+char *evhttp_uridecode(const char *uri, int decode_plus,
+    size_t *size_out);
+
+/**
+   Helper function to parse out arguments in a query.
+
+   Parsing a URI like
+
+      http://foo.com/?q=test&s=some+thing
+
+   will result in two entries in the key value queue.
+
+   The first entry is: key="q", value="test"
+   The second entry is: key="s", value="some thing"
+
+   @deprecated This function is deprecated as of Libevent 2.0.9.  Use
+     evhttp_uri_parse and evhttp_parse_query_str instead.
+
+   @param uri the request URI
+   @param headers the head of the evkeyval queue
+   @return 0 on success, -1 on failure
+ */
+EVENT2_EXPORT_SYMBOL
+int evhttp_parse_query(const char *uri, struct evkeyvalq *headers);
+
+/**
+   Helper function to parse out arguments from the query portion of an
+   HTTP URI.
+
+   Parsing a query string like
+
+     q=test&s=some+thing
+
+   will result in two entries in the key value queue.
+
+   The first entry is: key="q", value="test"
+   The second entry is: key="s", value="some thing"
+
+   @param query_parse the query portion of the URI
+   @param headers the head of the evkeyval queue
+   @return 0 on success, -1 on failure
+ */
+EVENT2_EXPORT_SYMBOL
+int evhttp_parse_query_str(const char *uri, struct evkeyvalq *headers);
+
+/**
+ * Escape HTML character entities in a string.
+ *
+ * Replaces <, >, ", ' and & with &lt;, &gt;, &quot;,
+ * &#039; and &amp; correspondingly.
+ *
+ * The returned string needs to be freed by the caller.
+ *
+ * @param html an unescaped HTML string
+ * @return an escaped HTML string or NULL on error
+ */
+EVENT2_EXPORT_SYMBOL
+char *evhttp_htmlescape(const char *html);
+
+/**
+ * Return a new empty evhttp_uri with no fields set.
+ */
+EVENT2_EXPORT_SYMBOL
+struct evhttp_uri *evhttp_uri_new(void);
+
+/**
+ * Changes the flags set on a given URI.  See EVHTTP_URI_* for
+ * a list of flags.
+ **/
+EVENT2_EXPORT_SYMBOL
+void evhttp_uri_set_flags(struct evhttp_uri *uri, unsigned flags);
+
+/** Return the scheme of an evhttp_uri, or NULL if there is no scheme has
+ * been set and the evhttp_uri contains a Relative-Ref. */
+EVENT2_EXPORT_SYMBOL
+const char *evhttp_uri_get_scheme(const struct evhttp_uri *uri);
+/**
+ * Return the userinfo part of an evhttp_uri, or NULL if it has no userinfo
+ * set.
+ */
+EVENT2_EXPORT_SYMBOL
+const char *evhttp_uri_get_userinfo(const struct evhttp_uri *uri);
+/**
+ * Return the host part of an evhttp_uri, or NULL if it has no host set.
+ * The host may either be a regular hostname (conforming to the RFC 3986
+ * "regname" production), or an IPv4 address, or the empty string, or a
+ * bracketed IPv6 address, or a bracketed 'IP-Future' address.
+ *
+ * Note that having a NULL host means that the URI has no authority
+ * section, but having an empty-string host means that the URI has an
+ * authority section with no host part.  For example,
+ * "mailto:user@example.com" has a host of NULL, but "file:///etc/motd"
+ * has a host of "".
+ */
+EVENT2_EXPORT_SYMBOL
+const char *evhttp_uri_get_host(const struct evhttp_uri *uri);
+/** Return the port part of an evhttp_uri, or -1 if there is no port set. */
+EVENT2_EXPORT_SYMBOL
+int evhttp_uri_get_port(const struct evhttp_uri *uri);
+/** Return the path part of an evhttp_uri, or NULL if it has no path set */
+EVENT2_EXPORT_SYMBOL
+const char *evhttp_uri_get_path(const struct evhttp_uri *uri);
+/** Return the query part of an evhttp_uri (excluding the leading "?"), or
+ * NULL if it has no query set */
+EVENT2_EXPORT_SYMBOL
+const char *evhttp_uri_get_query(const struct evhttp_uri *uri);
+/** Return the fragment part of an evhttp_uri (excluding the leading "#"),
+ * or NULL if it has no fragment set */
+EVENT2_EXPORT_SYMBOL
+const char *evhttp_uri_get_fragment(const struct evhttp_uri *uri);
+
+/** Set the scheme of an evhttp_uri, or clear the scheme if scheme==NULL.
+ * Returns 0 on success, -1 if scheme is not well-formed. */
+EVENT2_EXPORT_SYMBOL
+int evhttp_uri_set_scheme(struct evhttp_uri *uri, const char *scheme);
+/** Set the userinfo of an evhttp_uri, or clear the userinfo if userinfo==NULL.
+ * Returns 0 on success, -1 if userinfo is not well-formed. */
+EVENT2_EXPORT_SYMBOL
+int evhttp_uri_set_userinfo(struct evhttp_uri *uri, const char *userinfo);
+/** Set the host of an evhttp_uri, or clear the host if host==NULL.
+ * Returns 0 on success, -1 if host is not well-formed. */
+EVENT2_EXPORT_SYMBOL
+int evhttp_uri_set_host(struct evhttp_uri *uri, const char *host);
+/** Set the port of an evhttp_uri, or clear the port if port==-1.
+ * Returns 0 on success, -1 if port is not well-formed. */
+EVENT2_EXPORT_SYMBOL
+int evhttp_uri_set_port(struct evhttp_uri *uri, int port);
+/** Set the path of an evhttp_uri, or clear the path if path==NULL.
+ * Returns 0 on success, -1 if path is not well-formed. */
+EVENT2_EXPORT_SYMBOL
+int evhttp_uri_set_path(struct evhttp_uri *uri, const char *path);
+/** Set the query of an evhttp_uri, or clear the query if query==NULL.
+ * The query should not include a leading "?".
+ * Returns 0 on success, -1 if query is not well-formed. */
+EVENT2_EXPORT_SYMBOL
+int evhttp_uri_set_query(struct evhttp_uri *uri, const char *query);
+/** Set the fragment of an evhttp_uri, or clear the fragment if fragment==NULL.
+ * The fragment should not include a leading "#".
+ * Returns 0 on success, -1 if fragment is not well-formed. */
+EVENT2_EXPORT_SYMBOL
+int evhttp_uri_set_fragment(struct evhttp_uri *uri, const char *fragment);
+
+/**
+ * Helper function to parse a URI-Reference as specified by RFC3986.
+ *
+ * This function matches the URI-Reference production from RFC3986,
+ * which includes both URIs like
+ *
+ *    scheme://[[userinfo]@]foo.com[:port]]/[path][?query][#fragment]
+ *
+ *  and relative-refs like
+ *
+ *    [path][?query][#fragment]
+ *
+ * Any optional elements portions not present in the original URI are
+ * left set to NULL in the resulting evhttp_uri.  If no port is
+ * specified, the port is set to -1.
+ *
+ * Note that no decoding is performed on percent-escaped characters in
+ * the string; if you want to parse them, use evhttp_uridecode or
+ * evhttp_parse_query_str as appropriate.
+ *
+ * Note also that most URI schemes will have additional constraints that
+ * this function does not know about, and cannot check.  For example,
+ * mailto://www.example.com/cgi-bin/fortune.pl is not a reasonable
+ * mailto url, http://www.example.com:99999/ is not a reasonable HTTP
+ * URL, and ftp:username@example.com is not a reasonable FTP URL.
+ * Nevertheless, all of these URLs conform to RFC3986, and this function
+ * accepts all of them as valid.
+ *
+ * @param source_uri the request URI
+ * @param flags Zero or more EVHTTP_URI_* flags to affect the behavior
+ *              of the parser.
+ * @return uri container to hold parsed data, or NULL if there is error
+ * @see evhttp_uri_free()
+ */
+EVENT2_EXPORT_SYMBOL
+struct evhttp_uri *evhttp_uri_parse_with_flags(const char *source_uri,
+    unsigned flags);
+
+/** Tolerate URIs that do not conform to RFC3986.
+ *
+ * Unfortunately, some HTTP clients generate URIs that, according to RFC3986,
+ * are not conformant URIs.  If you need to support these URIs, you can
+ * do so by passing this flag to evhttp_uri_parse_with_flags.
+ *
+ * Currently, these changes are:
+ * <ul>
+ *   <li> Nonconformant URIs are allowed to contain otherwise unreasonable
+ *        characters in their path, query, and fragment components.
+ * </ul>
+ */
+#define EVHTTP_URI_NONCONFORMANT 0x01
+
+/** Alias for evhttp_uri_parse_with_flags(source_uri, 0) */
+EVENT2_EXPORT_SYMBOL
+struct evhttp_uri *evhttp_uri_parse(const char *source_uri);
+
+/**
+ * Free all memory allocated for a parsed uri.  Only use this for URIs
+ * generated by evhttp_uri_parse.
+ *
+ * @param uri container with parsed data
+ * @see evhttp_uri_parse()
+ */
+EVENT2_EXPORT_SYMBOL
+void evhttp_uri_free(struct evhttp_uri *uri);
+
+/**
+ * Join together the uri parts from parsed data to form a URI-Reference.
+ *
+ * Note that no escaping of reserved characters is done on the members
+ * of the evhttp_uri, so the generated string might not be a valid URI
+ * unless the members of evhttp_uri are themselves valid.
+ *
+ * @param uri container with parsed data
+ * @param buf destination buffer
+ * @param limit destination buffer size
+ * @return an joined uri as string or NULL on error
+ * @see evhttp_uri_parse()
+ */
+EVENT2_EXPORT_SYMBOL
+char *evhttp_uri_join(struct evhttp_uri *uri, char *buf, size_t limit);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EVENT2_HTTP_H_INCLUDED_ */
Index: dep/libevent/inc/event2/http_compat.h
===================================================================
--- dep/libevent/inc/event2/http_compat.h	(revision 49)
+++ dep/libevent/inc/event2/http_compat.h	(working copy)
@@ -1,90 +1,90 @@
-/*
- * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
- * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _EVENT2_HTTP_COMPAT_H_
-#define _EVENT2_HTTP_COMPAT_H_
-
-/** @file event2/http_compat.h
-
-  Potentially non-threadsafe versions of the functions in http.h: provided
-  only for backwards compatibility.
-
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <event2/event-config.h>
-#ifdef _EVENT_HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-#ifdef _EVENT_HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif
-
-/* For int types. */
-#include <event2/util.h>
-
-/**
- * Start an HTTP server on the specified address and port
- *
- * @deprecated It does not allow an event base to be specified
- *
- * @param address the address to which the HTTP server should be bound
- * @param port the port number on which the HTTP server should listen
- * @return an struct evhttp object
- */
-struct evhttp *evhttp_start(const char *address, unsigned short port);
-
-/**
- * A connection object that can be used to for making HTTP requests.  The
- * connection object tries to establish the connection when it is given an
- * http request object.
- *
- * @deprecated It does not allow an event base to be specified
- */
-struct evhttp_connection *evhttp_connection_new(
-	const char *address, unsigned short port);
-
-/**
- * Associates an event base with the connection - can only be called
- * on a freshly created connection object that has not been used yet.
- *
- * @deprecated XXXX Why?
- */
-void evhttp_connection_set_base(struct evhttp_connection *evcon,
-    struct event_base *base);
-
-
-/** Returns the request URI */
-#define evhttp_request_uri evhttp_request_get_uri
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _EVENT2_EVENT_COMPAT_H_ */
+/*
+ * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
+ * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EVENT2_HTTP_COMPAT_H_INCLUDED_
+#define EVENT2_HTTP_COMPAT_H_INCLUDED_
+
+/** @file event2/http_compat.h
+
+  Potentially non-threadsafe versions of the functions in http.h: provided
+  only for backwards compatibility.
+
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <event2/event-config.h>
+#ifdef EVENT__HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef EVENT__HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+
+/* For int types. */
+#include <event2/util.h>
+
+/**
+ * Start an HTTP server on the specified address and port
+ *
+ * @deprecated It does not allow an event base to be specified
+ *
+ * @param address the address to which the HTTP server should be bound
+ * @param port the port number on which the HTTP server should listen
+ * @return an struct evhttp object
+ */
+struct evhttp *evhttp_start(const char *address, unsigned short port);
+
+/**
+ * A connection object that can be used to for making HTTP requests.  The
+ * connection object tries to establish the connection when it is given an
+ * http request object.
+ *
+ * @deprecated It does not allow an event base to be specified
+ */
+struct evhttp_connection *evhttp_connection_new(
+	const char *address, unsigned short port);
+
+/**
+ * Associates an event base with the connection - can only be called
+ * on a freshly created connection object that has not been used yet.
+ *
+ * @deprecated XXXX Why?
+ */
+void evhttp_connection_set_base(struct evhttp_connection *evcon,
+    struct event_base *base);
+
+
+/** Returns the request URI */
+#define evhttp_request_uri evhttp_request_get_uri
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EVENT2_EVENT_COMPAT_H_INCLUDED_ */
Index: dep/libevent/inc/event2/http_struct.h
===================================================================
--- dep/libevent/inc/event2/http_struct.h	(revision 49)
+++ dep/libevent/inc/event2/http_struct.h	(working copy)
@@ -1,130 +1,152 @@
-/*
- * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
- * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _EVENT2_HTTP_STRUCT_H_
-#define _EVENT2_HTTP_STRUCT_H_
-
-/** @file event2/http_struct.h
-
-  Data structures for http.  Using these structures may hurt forward
-  compatibility with later versions of Libevent: be careful!
-
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <event2/event-config.h>
-#ifdef _EVENT_HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-#ifdef _EVENT_HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif
-
-/* For int types. */
-#include <event2/util.h>
-
-/**
- * the request structure that a server receives.
- * WARNING: expect this structure to change.  I will try to provide
- * reasonable accessors.
- */
-struct evhttp_request {
-#if defined(TAILQ_ENTRY)
-	TAILQ_ENTRY(evhttp_request) next;
-#else
-struct {
-	struct evhttp_request *tqe_next;
-	struct evhttp_request **tqe_prev;
-}       next;
-#endif
-
-	/* the connection object that this request belongs to */
-	struct evhttp_connection *evcon;
-	int flags;
-/** The request obj owns the evhttp connection and needs to free it */
-#define EVHTTP_REQ_OWN_CONNECTION	0x0001
-/** Request was made via a proxy */
-#define EVHTTP_PROXY_REQUEST		0x0002
-/** The request object is owned by the user; the user must free it */
-#define EVHTTP_USER_OWNED		0x0004
-/** The request will be used again upstack; freeing must be deferred */
-#define EVHTTP_REQ_DEFER_FREE		0x0008
-/** The request should be freed upstack */
-#define EVHTTP_REQ_NEEDS_FREE		0x0010
-
-	struct evkeyvalq *input_headers;
-	struct evkeyvalq *output_headers;
-
-	/* address of the remote host and the port connection came from */
-	char *remote_host;
-	ev_uint16_t remote_port;
-
-	/* cache of the hostname for evhttp_request_get_host */
-	char *host_cache;
-
-	enum evhttp_request_kind kind;
-	enum evhttp_cmd_type type;
-
-	size_t headers_size;
-	size_t body_size;
-
-	char *uri;			/* uri after HTTP request was parsed */
-	struct evhttp_uri *uri_elems;	/* uri elements */
-
-	char major;			/* HTTP Major number */
-	char minor;			/* HTTP Minor number */
-
-	int response_code;		/* HTTP Response code */
-	char *response_code_line;	/* Readable response */
-
-	struct evbuffer *input_buffer;	/* read data */
-	ev_int64_t ntoread;
-	unsigned chunked:1,		/* a chunked request */
-	    userdone:1;			/* the user has sent all data */
-
-	struct evbuffer *output_buffer;	/* outgoing post or data */
-
-	/* Callback */
-	void (*cb)(struct evhttp_request *, void *);
-	void *cb_arg;
-
-	/*
-	 * Chunked data callback - call for each completed chunk if
-	 * specified.  If not specified, all the data is delivered via
-	 * the regular callback.
-	 */
-	void (*chunk_cb)(struct evhttp_request *, void *);
-};
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _EVENT2_HTTP_STRUCT_H_ */
-
+/*
+ * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
+ * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EVENT2_HTTP_STRUCT_H_INCLUDED_
+#define EVENT2_HTTP_STRUCT_H_INCLUDED_
+
+/** @file event2/http_struct.h
+
+  Data structures for http.  Using these structures may hurt forward
+  compatibility with later versions of Libevent: be careful!
+
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <event2/event-config.h>
+#ifdef EVENT__HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef EVENT__HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+
+/* For int types. */
+#include <event2/util.h>
+
+/**
+ * the request structure that a server receives.
+ * WARNING: expect this structure to change.  I will try to provide
+ * reasonable accessors.
+ */
+struct evhttp_request {
+#if defined(TAILQ_ENTRY)
+	TAILQ_ENTRY(evhttp_request) next;
+#else
+struct {
+	struct evhttp_request *tqe_next;
+	struct evhttp_request **tqe_prev;
+}       next;
+#endif
+
+	/* the connection object that this request belongs to */
+	struct evhttp_connection *evcon;
+	int flags;
+/** The request obj owns the evhttp connection and needs to free it */
+#define EVHTTP_REQ_OWN_CONNECTION	0x0001
+/** Request was made via a proxy */
+#define EVHTTP_PROXY_REQUEST		0x0002
+/** The request object is owned by the user; the user must free it */
+#define EVHTTP_USER_OWNED		0x0004
+/** The request will be used again upstack; freeing must be deferred */
+#define EVHTTP_REQ_DEFER_FREE		0x0008
+/** The request should be freed upstack */
+#define EVHTTP_REQ_NEEDS_FREE		0x0010
+
+	struct evkeyvalq *input_headers;
+	struct evkeyvalq *output_headers;
+
+	/* address of the remote host and the port connection came from */
+	char *remote_host;
+	ev_uint16_t remote_port;
+
+	/* cache of the hostname for evhttp_request_get_host */
+	char *host_cache;
+
+	enum evhttp_request_kind kind;
+	enum evhttp_cmd_type type;
+
+	size_t headers_size;
+	size_t body_size;
+
+	char *uri;			/* uri after HTTP request was parsed */
+	struct evhttp_uri *uri_elems;	/* uri elements */
+
+	char major;			/* HTTP Major number */
+	char minor;			/* HTTP Minor number */
+
+	int response_code;		/* HTTP Response code */
+	char *response_code_line;	/* Readable response */
+
+	struct evbuffer *input_buffer;	/* read data */
+	ev_int64_t ntoread;
+	unsigned chunked:1,		/* a chunked request */
+	    userdone:1;			/* the user has sent all data */
+
+	struct evbuffer *output_buffer;	/* outgoing post or data */
+
+	/* Callback */
+	void (*cb)(struct evhttp_request *, void *);
+	void *cb_arg;
+
+	/*
+	 * Chunked data callback - call for each completed chunk if
+	 * specified.  If not specified, all the data is delivered via
+	 * the regular callback.
+	 */
+	void (*chunk_cb)(struct evhttp_request *, void *);
+
+	/*
+	 * Callback added for forked-daapd so they can collect ICY
+	 * (shoutcast) metadata from the http header. If return
+	 * int is negative the connection will be closed.
+	 */
+	int (*header_cb)(struct evhttp_request *, void *);
+
+	/*
+	 * Error callback - called when error is occured.
+	 * @see evhttp_request_error for error types.
+	 *
+	 * @see evhttp_request_set_error_cb()
+	 */
+	void (*error_cb)(enum evhttp_request_error, void *);
+
+	/*
+	 * Send complete callback - called when the request is actually
+	 * sent and completed.
+	 */
+	void (*on_complete_cb)(struct evhttp_request *, void *);
+	void *on_complete_cb_arg;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EVENT2_HTTP_STRUCT_H_INCLUDED_ */
+
Index: dep/libevent/inc/event2/keyvalq_struct.h
===================================================================
--- dep/libevent/inc/event2/keyvalq_struct.h	(revision 49)
+++ dep/libevent/inc/event2/keyvalq_struct.h	(working copy)
@@ -1,80 +1,80 @@
-/*
- * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
- * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _EVENT2_EVENT_KEYVALQ_STRUCT_H_
-#define _EVENT2_EVENT_KEYVALQ_STRUCT_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Fix so that people don't have to run with <sys/queue.h> */
-/* XXXX This code is duplicated with event_struct.h */
-#ifndef TAILQ_ENTRY
-#define _EVENT_DEFINED_TQENTRY
-#define TAILQ_ENTRY(type)						\
-struct {								\
-	struct type *tqe_next;	/* next element */			\
-	struct type **tqe_prev;	/* address of previous next element */	\
-}
-#endif /* !TAILQ_ENTRY */
-
-#ifndef TAILQ_HEAD
-#define _EVENT_DEFINED_TQHEAD
-#define TAILQ_HEAD(name, type)			\
-struct name {					\
-	struct type *tqh_first;			\
-	struct type **tqh_last;			\
-}
-#endif
-
-/*
- * Key-Value pairs.  Can be used for HTTP headers but also for
- * query argument parsing.
- */
-struct evkeyval {
-	TAILQ_ENTRY(evkeyval) next;
-
-	char *key;
-	char *value;
-};
-
-TAILQ_HEAD (evkeyvalq, evkeyval);
-
-/* XXXX This code is duplicated with event_struct.h */
-#ifdef _EVENT_DEFINED_TQENTRY
-#undef TAILQ_ENTRY
-#endif
-
-#ifdef _EVENT_DEFINED_TQHEAD
-#undef TAILQ_HEAD
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
+ * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EVENT2_KEYVALQ_STRUCT_H_INCLUDED_
+#define EVENT2_KEYVALQ_STRUCT_H_INCLUDED_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Fix so that people don't have to run with <sys/queue.h> */
+/* XXXX This code is duplicated with event_struct.h */
+#ifndef TAILQ_ENTRY
+#define EVENT_DEFINED_TQENTRY_
+#define TAILQ_ENTRY(type)						\
+struct {								\
+	struct type *tqe_next;	/* next element */			\
+	struct type **tqe_prev;	/* address of previous next element */	\
+}
+#endif /* !TAILQ_ENTRY */
+
+#ifndef TAILQ_HEAD
+#define EVENT_DEFINED_TQHEAD_
+#define TAILQ_HEAD(name, type)			\
+struct name {					\
+	struct type *tqh_first;			\
+	struct type **tqh_last;			\
+}
+#endif
+
+/*
+ * Key-Value pairs.  Can be used for HTTP headers but also for
+ * query argument parsing.
+ */
+struct evkeyval {
+	TAILQ_ENTRY(evkeyval) next;
+
+	char *key;
+	char *value;
+};
+
+TAILQ_HEAD (evkeyvalq, evkeyval);
+
+/* XXXX This code is duplicated with event_struct.h */
+#ifdef EVENT_DEFINED_TQENTRY_
+#undef TAILQ_ENTRY
+#endif
+
+#ifdef EVENT_DEFINED_TQHEAD_
+#undef TAILQ_HEAD
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Index: dep/libevent/inc/event2/listener.h
===================================================================
--- dep/libevent/inc/event2/listener.h	(revision 49)
+++ dep/libevent/inc/event2/listener.h	(working copy)
@@ -1,143 +1,180 @@
-/*
- * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
- * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _EVENT2_LISTENER_H_
-#define _EVENT2_LISTENER_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <event2/event.h>
-
-struct sockaddr;
-struct evconnlistener;
-
-/**
-   A callback that we invoke when a listener has a new connection.
-
-   @param listener The evconnlistener
-   @param fd The new file descriptor
-   @param addr The source address of the connection
-   @param socklen The length of addr
-   @param user_arg the pointer passed to evconnlistener_new()
- */
-typedef void (*evconnlistener_cb)(struct evconnlistener *, evutil_socket_t, struct sockaddr *, int socklen, void *);
-
-/**
-   A callback that we invoke when a listener encounters a non-retriable error.
-
-   @param listener The evconnlistener
-   @param user_arg the pointer passed to evconnlistener_new()
- */
-typedef void (*evconnlistener_errorcb)(struct evconnlistener *, void *);
-
-/** Flag: Indicates that we should not make incoming sockets nonblocking
- * before passing them to the callback. */
-#define LEV_OPT_LEAVE_SOCKETS_BLOCKING	(1u<<0)
-/** Flag: Indicates that freeing the listener should close the underlying
- * socket. */
-#define LEV_OPT_CLOSE_ON_FREE		(1u<<1)
-/** Flag: Indicates that we should set the close-on-exec flag, if possible */
-#define LEV_OPT_CLOSE_ON_EXEC		(1u<<2)
-/** Flag: Indicates that we should disable the timeout (if any) between when
- * this socket is closed and when we can listen again on the same port. */
-#define LEV_OPT_REUSEABLE		(1u<<3)
-/** Flag: Indicates that the listener should be locked so it's safe to use
- * from multiple threadcs at once. */
-#define LEV_OPT_THREADSAFE		(1u<<4)
-
-/**
-   Allocate a new evconnlistener object to listen for incoming TCP connections
-   on a given file descriptor.
-
-   @param base The event base to associate the listener with.
-   @param cb A callback to be invoked when a new connection arrives.  If the
-      callback is NULL, the listener will be treated as disabled until the
-      callback is set.
-   @param ptr A user-supplied pointer to give to the callback.
-   @param flags Any number of LEV_OPT_* flags
-   @param backlog Passed to the listen() call to determine the length of the
-      acceptable connection backlog.  Set to -1 for a reasonable default.
-      Set to 0 if the socket is already listening.
-   @param fd The file descriptor to listen on.  It must be a nonblocking
-      file descriptor, and it should already be bound to an appropriate
-      port and address.
-*/
-struct evconnlistener *evconnlistener_new(struct event_base *base,
-    evconnlistener_cb cb, void *ptr, unsigned flags, int backlog,
-    evutil_socket_t fd);
-/**
-   Allocate a new evconnlistener object to listen for incoming TCP connections
-   on a given address.
-
-   @param base The event base to associate the listener with.
-   @param cb A callback to be invoked when a new connection arrives. If the
-      callback is NULL, the listener will be treated as disabled until the
-      callback is set.
-   @param ptr A user-supplied pointer to give to the callback.
-   @param flags Any number of LEV_OPT_* flags
-   @param backlog Passed to the listen() call to determine the length of the
-      acceptable connection backlog.  Set to -1 for a reasonable default.
-   @param addr The address to listen for connections on.
-   @param socklen The length of the address.
- */
-struct evconnlistener *evconnlistener_new_bind(struct event_base *base,
-    evconnlistener_cb cb, void *ptr, unsigned flags, int backlog,
-    const struct sockaddr *sa, int socklen);
-/**
-   Disable and deallocate an evconnlistener.
- */
-void evconnlistener_free(struct evconnlistener *lev);
-/**
-   Re-enable an evconnlistener that has been disabled.
- */
-int evconnlistener_enable(struct evconnlistener *lev);
-/**
-   Stop listening for connections on an evconnlistener.
- */
-int evconnlistener_disable(struct evconnlistener *lev);
-
-/** Return an evconnlistener's associated event_base. */
-struct event_base *evconnlistener_get_base(struct evconnlistener *lev);
-
-/** Return the socket that an evconnlistner is listening on. */
-evutil_socket_t evconnlistener_get_fd(struct evconnlistener *lev);
-
-/** Change the callback on the listener to cb and its user_data to arg.
- */
-void evconnlistener_set_cb(struct evconnlistener *lev,
-    evconnlistener_cb cb, void *arg);
-
-/** Set an evconnlistener's error callback. */
-void evconnlistener_set_error_cb(struct evconnlistener *lev,
-    evconnlistener_errorcb errorcb);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/*
+ * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
+ * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EVENT2_LISTENER_H_INCLUDED_
+#define EVENT2_LISTENER_H_INCLUDED_
+
+#include <event2/visibility.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <event2/event.h>
+
+struct sockaddr;
+struct evconnlistener;
+
+/**
+   A callback that we invoke when a listener has a new connection.
+
+   @param listener The evconnlistener
+   @param fd The new file descriptor
+   @param addr The source address of the connection
+   @param socklen The length of addr
+   @param user_arg the pointer passed to evconnlistener_new()
+ */
+typedef void (*evconnlistener_cb)(struct evconnlistener *, evutil_socket_t, struct sockaddr *, int socklen, void *);
+
+/**
+   A callback that we invoke when a listener encounters a non-retriable error.
+
+   @param listener The evconnlistener
+   @param user_arg the pointer passed to evconnlistener_new()
+ */
+typedef void (*evconnlistener_errorcb)(struct evconnlistener *, void *);
+
+/** Flag: Indicates that we should not make incoming sockets nonblocking
+ * before passing them to the callback. */
+#define LEV_OPT_LEAVE_SOCKETS_BLOCKING	(1u<<0)
+/** Flag: Indicates that freeing the listener should close the underlying
+ * socket. */
+#define LEV_OPT_CLOSE_ON_FREE		(1u<<1)
+/** Flag: Indicates that we should set the close-on-exec flag, if possible */
+#define LEV_OPT_CLOSE_ON_EXEC		(1u<<2)
+/** Flag: Indicates that we should disable the timeout (if any) between when
+ * this socket is closed and when we can listen again on the same port. */
+#define LEV_OPT_REUSEABLE		(1u<<3)
+/** Flag: Indicates that the listener should be locked so it's safe to use
+ * from multiple threadcs at once. */
+#define LEV_OPT_THREADSAFE		(1u<<4)
+/** Flag: Indicates that the listener should be created in disabled
+ * state. Use evconnlistener_enable() to enable it later. */
+#define LEV_OPT_DISABLED		(1u<<5)
+/** Flag: Indicates that the listener should defer accept() until data is
+ * available, if possible.  Ignored on platforms that do not support this.
+ *
+ * This option can help performance for protocols where the client transmits
+ * immediately after connecting.  Do not use this option if your protocol
+ * _doesn't_ start out with the client transmitting data, since in that case
+ * this option will sometimes cause the kernel to never tell you about the
+ * connection.
+ *
+ * This option is only supported by evconnlistener_new_bind(): it can't
+ * work with evconnlistener_new_fd(), since the listener needs to be told
+ * to use the option before it is actually bound.
+ */
+#define LEV_OPT_DEFERRED_ACCEPT		(1u<<6)
+/** Flag: Indicates that we ask to allow multiple servers (processes or
+ * threads) to bind to the same port if they each set the option. 
+ * 
+ * SO_REUSEPORT is what most people would expect SO_REUSEADDR to be, however
+ * SO_REUSEPORT does not imply SO_REUSEADDR.
+ *
+ * This is only available on Linux and kernel 3.9+
+ */
+#define LEV_OPT_REUSEABLE_PORT		(1u<<7)
+
+/**
+   Allocate a new evconnlistener object to listen for incoming TCP connections
+   on a given file descriptor.
+
+   @param base The event base to associate the listener with.
+   @param cb A callback to be invoked when a new connection arrives.  If the
+      callback is NULL, the listener will be treated as disabled until the
+      callback is set.
+   @param ptr A user-supplied pointer to give to the callback.
+   @param flags Any number of LEV_OPT_* flags
+   @param backlog Passed to the listen() call to determine the length of the
+      acceptable connection backlog.  Set to -1 for a reasonable default.
+      Set to 0 if the socket is already listening.
+   @param fd The file descriptor to listen on.  It must be a nonblocking
+      file descriptor, and it should already be bound to an appropriate
+      port and address.
+*/
+EVENT2_EXPORT_SYMBOL
+struct evconnlistener *evconnlistener_new(struct event_base *base,
+    evconnlistener_cb cb, void *ptr, unsigned flags, int backlog,
+    evutil_socket_t fd);
+/**
+   Allocate a new evconnlistener object to listen for incoming TCP connections
+   on a given address.
+
+   @param base The event base to associate the listener with.
+   @param cb A callback to be invoked when a new connection arrives. If the
+      callback is NULL, the listener will be treated as disabled until the
+      callback is set.
+   @param ptr A user-supplied pointer to give to the callback.
+   @param flags Any number of LEV_OPT_* flags
+   @param backlog Passed to the listen() call to determine the length of the
+      acceptable connection backlog.  Set to -1 for a reasonable default.
+   @param addr The address to listen for connections on.
+   @param socklen The length of the address.
+ */
+EVENT2_EXPORT_SYMBOL
+struct evconnlistener *evconnlistener_new_bind(struct event_base *base,
+    evconnlistener_cb cb, void *ptr, unsigned flags, int backlog,
+    const struct sockaddr *sa, int socklen);
+/**
+   Disable and deallocate an evconnlistener.
+ */
+EVENT2_EXPORT_SYMBOL
+void evconnlistener_free(struct evconnlistener *lev);
+/**
+   Re-enable an evconnlistener that has been disabled.
+ */
+EVENT2_EXPORT_SYMBOL
+int evconnlistener_enable(struct evconnlistener *lev);
+/**
+   Stop listening for connections on an evconnlistener.
+ */
+EVENT2_EXPORT_SYMBOL
+int evconnlistener_disable(struct evconnlistener *lev);
+
+/** Return an evconnlistener's associated event_base. */
+EVENT2_EXPORT_SYMBOL
+struct event_base *evconnlistener_get_base(struct evconnlistener *lev);
+
+/** Return the socket that an evconnlistner is listening on. */
+EVENT2_EXPORT_SYMBOL
+evutil_socket_t evconnlistener_get_fd(struct evconnlistener *lev);
+
+/** Change the callback on the listener to cb and its user_data to arg.
+ */
+EVENT2_EXPORT_SYMBOL
+void evconnlistener_set_cb(struct evconnlistener *lev,
+    evconnlistener_cb cb, void *arg);
+
+/** Set an evconnlistener's error callback. */
+EVENT2_EXPORT_SYMBOL
+void evconnlistener_set_error_cb(struct evconnlistener *lev,
+    evconnlistener_errorcb errorcb);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Index: dep/libevent/inc/event2/rpc.h
===================================================================
--- dep/libevent/inc/event2/rpc.h	(revision 49)
+++ dep/libevent/inc/event2/rpc.h	(working copy)
@@ -1,596 +1,596 @@
-/*
- * Copyright (c) 2006-2007 Niels Provos <provos@citi.umich.edu>
- * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _EVENT2_RPC_H_
-#define _EVENT2_RPC_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** @file rpc.h
- *
- * This header files provides basic support for an RPC server and client.
- *
- * To support RPCs in a server, every supported RPC command needs to be
- * defined and registered.
- *
- * EVRPC_HEADER(SendCommand, Request, Reply);
- *
- *  SendCommand is the name of the RPC command.
- *  Request is the name of a structure generated by event_rpcgen.py.
- *    It contains all parameters relating to the SendCommand RPC.  The
- *    server needs to fill in the Reply structure.
- *  Reply is the name of a structure generated by event_rpcgen.py.  It
- *    contains the answer to the RPC.
- *
- * To register an RPC with an HTTP server, you need to first create an RPC
- * base with:
- *
- *   struct evrpc_base *base = evrpc_init(http);
- *
- * A specific RPC can then be registered with
- *
- * EVRPC_REGISTER(base, SendCommand, Request, Reply,  FunctionCB, arg);
- *
- * when the server receives an appropriately formatted RPC, the user callback
- * is invoked.   The callback needs to fill in the reply structure.
- *
- * void FunctionCB(EVRPC_STRUCT(SendCommand)* rpc, void *arg);
- *
- * To send the reply, call EVRPC_REQUEST_DONE(rpc);
- *
- * See the regression test for an example.
- */
-
-/**
-   Determines if the member has been set in the message
-
-   @param msg the message to inspect
-   @param member the member variable to test for presences
-   @return 1 if it's present or 0 otherwise.
-*/
-#define EVTAG_HAS(msg, member) \
-	((msg)->member##_set == 1)
-
-#ifndef _EVENT2_RPC_COMPAT_H_
-
-/**
-   Assigns a value to the member in the message.
-
-   @param msg the message to which to assign a value
-   @param member the name of the member variable
-   @param value the value to assign
-*/
-#define EVTAG_ASSIGN(msg, member, value) \
-	(*(msg)->base->member##_assign)((msg), (value))
-/**
-   Assigns a value to the member in the message.
-
-   @param msg the message to which to assign a value
-   @param member the name of the member variable
-   @param value the value to assign
-   @param len the length of the value
-*/
-#define EVTAG_ASSIGN_WITH_LEN(msg, member, value, len)	\
-	(*(msg)->base->member##_assign)((msg), (value), (len))
-/**
-   Returns the value for a member.
-
-   @param msg the message from which to get the value
-   @param member the name of the member variable
-   @param pvalue a pointer to the variable to hold the value
-   @return 0 on success, -1 otherwise.
-*/
-#define EVTAG_GET(msg, member, pvalue) \
-	(*(msg)->base->member##_get)((msg), (pvalue))
-/**
-   Returns the value for a member.
-
-   @param msg the message from which to get the value
-   @param member the name of the member variable
-   @param pvalue a pointer to the variable to hold the value
-   @param plen a pointer to the length of the value
-   @return 0 on success, -1 otherwise.
-*/
-#define EVTAG_GET_WITH_LEN(msg, member, pvalue, plen)	\
-	(*(msg)->base->member##_get)((msg), (pvalue), (plen))
-
-#endif  /* _EVENT2_RPC_COMPAT_H_ */
-
-/**
-   Adds a value to an array.
-*/
-#define EVTAG_ARRAY_ADD_VALUE(msg, member, value) \
-	(*(msg)->base->member##_add)((msg), (value))
-/**
-   Allocates a new entry in the array and returns it.
-*/
-#define EVTAG_ARRAY_ADD(msg, member) \
-	(*(msg)->base->member##_add)(msg)
-/**
-   Gets a variable at the specified offset from the array.
-*/
-#define EVTAG_ARRAY_GET(msg, member, offset, pvalue)	\
-	(*(msg)->base->member##_get)((msg), (offset), (pvalue))
-/**
-   Returns the number of entries in the array.
-*/
-#define EVTAG_ARRAY_LEN(msg, member) ((msg)->member##_length)
-
-
-struct evbuffer;
-struct event_base;
-struct evrpc_req_generic;
-struct evrpc_request_wrapper;
-struct evrpc;
-
-/** The type of a specific RPC Message
- *
- * @param rpcname the name of the RPC message
- */
-#define EVRPC_STRUCT(rpcname) struct evrpc_req__##rpcname
-
-struct evhttp_request;
-struct evrpc_status;
-struct evrpc_hook_meta;
-
-/** Creates the definitions and prototypes for an RPC
- *
- * You need to use EVRPC_HEADER to create structures and function prototypes
- * needed by the server and client implementation.  The structures have to be
- * defined in an .rpc file and converted to source code via event_rpcgen.py
- *
- * @param rpcname the name of the RPC
- * @param reqstruct the name of the RPC request structure
- * @param replystruct the name of the RPC reply structure
- * @see EVRPC_GENERATE()
- */
-#define EVRPC_HEADER(rpcname, reqstruct, rplystruct) \
-EVRPC_STRUCT(rpcname) {	\
-	struct evrpc_hook_meta *hook_meta; \
-	struct reqstruct* request; \
-	struct rplystruct* reply; \
-	struct evrpc* rpc; \
-	struct evhttp_request* http_req; \
-	struct evbuffer* rpc_data; \
-};								     \
-int evrpc_send_request_##rpcname(struct evrpc_pool *, \
-    struct reqstruct *, struct rplystruct *, \
-    void (*)(struct evrpc_status *, \
-	struct reqstruct *, struct rplystruct *, void *cbarg),	\
-    void *);
-
-struct evrpc_pool;
-
-/** use EVRPC_GENERATE instead */
-struct evrpc_request_wrapper *evrpc_make_request_ctx(
-	struct evrpc_pool *pool, void *request, void *reply,
-	const char *rpcname,
-	void (*req_marshal)(struct evbuffer*, void *),
-	void (*rpl_clear)(void *),
-	int (*rpl_unmarshal)(void *, struct evbuffer *),
-	void (*cb)(struct evrpc_status *, void *, void *, void *),
-	void *cbarg);
-
-/** Creates a context structure that contains rpc specific information.
- *
- * EVRPC_MAKE_CTX is used to populate a RPC specific context that
- * contains information about marshaling the RPC data types.
- *
- * @param rpcname the name of the RPC
- * @param reqstruct the name of the RPC request structure
- * @param replystruct the name of the RPC reply structure
- * @param pool the evrpc_pool over which to make the request
- * @param request a pointer to the RPC request structure object
- * @param reply a pointer to the RPC reply structure object
- * @param cb the callback function to call when the RPC has completed
- * @param cbarg the argument to supply to the callback
- */
-#define EVRPC_MAKE_CTX(rpcname, reqstruct, rplystruct, \
-    pool, request, reply, cb, cbarg)					\
-	evrpc_make_request_ctx(pool, request, reply,			\
-	    #rpcname,							\
-	    (void (*)(struct evbuffer *, void *))reqstruct##_marshal,	\
-	    (void (*)(void *))rplystruct##_clear,			\
-	    (int (*)(void *, struct evbuffer *))rplystruct##_unmarshal, \
-	    (void (*)(struct evrpc_status *, void *, void *, void *))cb, \
-	    cbarg)
-
-/** Generates the code for receiving and sending an RPC message
- *
- * EVRPC_GENERATE is used to create the code corresponding to sending
- * and receiving a particular RPC message
- *
- * @param rpcname the name of the RPC
- * @param reqstruct the name of the RPC request structure
- * @param replystruct the name of the RPC reply structure
- * @see EVRPC_HEADER()
- */
-#define EVRPC_GENERATE(rpcname, reqstruct, rplystruct)			\
-	int evrpc_send_request_##rpcname(struct evrpc_pool *pool,	\
-	    struct reqstruct *request, struct rplystruct *reply,	\
-	    void (*cb)(struct evrpc_status *,				\
-		struct reqstruct *, struct rplystruct *, void *cbarg),	\
-	    void *cbarg) {						\
-	return evrpc_send_request_generic(pool, request, reply,	\
-	    (void (*)(struct evrpc_status *, void *, void *, void *))cb, \
-	    cbarg,							\
-	    #rpcname,							\
-	    (void (*)(struct evbuffer *, void *))reqstruct##_marshal,	\
-	    (void (*)(void *))rplystruct##_clear,			\
-	    (int (*)(void *, struct evbuffer *))rplystruct##_unmarshal); \
-}
-
-/** Provides access to the HTTP request object underlying an RPC
- *
- * Access to the underlying http object; can be used to look at headers or
- * for getting the remote ip address
- *
- * @param rpc_req the rpc request structure provided to the server callback
- * @return an struct evhttp_request object that can be inspected for
- * HTTP headers or sender information.
- */
-#define EVRPC_REQUEST_HTTP(rpc_req) (rpc_req)->http_req
-
-/** completes the server response to an rpc request */
-void evrpc_request_done(struct evrpc_req_generic *req);
-
-/** accessors for request and reply */
-void *evrpc_get_request(struct evrpc_req_generic *req);
-void *evrpc_get_reply(struct evrpc_req_generic *req);
-
-/** Creates the reply to an RPC request
- *
- * EVRPC_REQUEST_DONE is used to answer a request; the reply is expected
- * to have been filled in.  The request and reply pointers become invalid
- * after this call has finished.
- *
- * @param rpc_req the rpc request structure provided to the server callback
- */
-#define EVRPC_REQUEST_DONE(rpc_req) do { \
-  struct evrpc_req_generic *_req = (struct evrpc_req_generic *)(rpc_req); \
-  evrpc_request_done(_req);					\
-} while (0)
-
-
-struct evrpc_base;
-struct evhttp;
-
-/* functions to start up the rpc system */
-
-/** Creates a new rpc base from which RPC requests can be received
- *
- * @param server a pointer to an existing HTTP server
- * @return a newly allocated evrpc_base struct
- * @see evrpc_free()
- */
-struct evrpc_base *evrpc_init(struct evhttp *server);
-
-/**
- * Frees the evrpc base
- *
- * For now, you are responsible for making sure that no rpcs are ongoing.
- *
- * @param base the evrpc_base object to be freed
- * @see evrpc_init
- */
-void evrpc_free(struct evrpc_base *base);
-
-/** register RPCs with the HTTP Server
- *
- * registers a new RPC with the HTTP server, each RPC needs to have
- * a unique name under which it can be identified.
- *
- * @param base the evrpc_base structure in which the RPC should be
- *   registered.
- * @param name the name of the RPC
- * @param request the name of the RPC request structure
- * @param reply the name of the RPC reply structure
- * @param callback the callback that should be invoked when the RPC
- * is received.  The callback has the following prototype
- *   void (*callback)(EVRPC_STRUCT(Message)* rpc, void *arg)
- * @param cbarg an additional parameter that can be passed to the callback.
- *   The parameter can be used to carry around state.
- */
-#define EVRPC_REGISTER(base, name, request, reply, callback, cbarg)	\
-	evrpc_register_generic(base, #name,				\
-	    (void (*)(struct evrpc_req_generic *, void *))callback, cbarg, \
-	    (void *(*)(void *))request##_new, NULL,			\
-	    (void (*)(void *))request##_free,				\
-	    (int (*)(void *, struct evbuffer *))request##_unmarshal,	\
-	    (void *(*)(void *))reply##_new, NULL,			\
-	    (void (*)(void *))reply##_free, \
-	    (int (*)(void *))reply##_complete, \
-	    (void (*)(struct evbuffer *, void *))reply##_marshal)
-
-/**
-   Low level function for registering an RPC with a server.
-
-   Use EVRPC_REGISTER() instead.
-
-   @see EVRPC_REGISTER()
-*/
-int evrpc_register_rpc(struct evrpc_base *, struct evrpc *,
-    void (*)(struct evrpc_req_generic*, void *), void *);
-
-/**
- * Unregisters an already registered RPC
- *
- * @param base the evrpc_base object from which to unregister an RPC
- * @param name the name of the rpc to unregister
- * @return -1 on error or 0 when successful.
- * @see EVRPC_REGISTER()
- */
-#define EVRPC_UNREGISTER(base, name) evrpc_unregister_rpc((base), #name)
-
-int evrpc_unregister_rpc(struct evrpc_base *base, const char *name);
-
-/*
- * Client-side RPC support
- */
-
-struct evhttp_connection;
-struct evrpc_status;
-
-/** launches an RPC and sends it to the server
- *
- * EVRPC_MAKE_REQUEST() is used by the client to send an RPC to the server.
- *
- * @param name the name of the RPC
- * @param pool the evrpc_pool that contains the connection objects over which
- *   the request should be sent.
- * @param request a pointer to the RPC request structure - it contains the
- *   data to be sent to the server.
- * @param reply a pointer to the RPC reply structure.  It is going to be filled
- *   if the request was answered successfully
- * @param cb the callback to invoke when the RPC request has been answered
- * @param cbarg an additional argument to be passed to the client
- * @return 0 on success, -1 on failure
- */
-#define EVRPC_MAKE_REQUEST(name, pool, request, reply, cb, cbarg)	\
-	evrpc_send_request_##name((pool), (request), (reply), (cb), (cbarg))
-
-/**
-   Makes an RPC request based on the provided context.
-
-   This is a low-level function and should not be used directly
-   unless a custom context object is provided.  Use EVRPC_MAKE_REQUEST()
-   instead.
-
-   @param ctx a context from EVRPC_MAKE_CTX()
-   @returns 0 on success, -1 otherwise.
-   @see EVRPC_MAKE_REQUEST(), EVRPC_MAKE_CTX()
-*/
-int evrpc_make_request(struct evrpc_request_wrapper *ctx);
-
-/** creates an rpc connection pool
- *
- * a pool has a number of connections associated with it.
- * rpc requests are always made via a pool.
- *
- * @param base a pointer to an struct event_based object; can be left NULL
- *   in singled-threaded applications
- * @return a newly allocated struct evrpc_pool object
- * @see evrpc_pool_free()
- */
-struct evrpc_pool *evrpc_pool_new(struct event_base *base);
-/** frees an rpc connection pool
- *
- * @param pool a pointer to an evrpc_pool allocated via evrpc_pool_new()
- * @see evrpc_pool_new()
- */
-void evrpc_pool_free(struct evrpc_pool *pool);
-
-/**
- * Adds a connection over which rpc can be dispatched to the pool.
- *
- * The connection object must have been newly created.
- *
- * @param pool the pool to which to add the connection
- * @param evcon the connection to add to the pool.
- */
-void evrpc_pool_add_connection(struct evrpc_pool *pool,
-    struct evhttp_connection *evcon);
-
-/**
- * Removes a connection from the pool.
- *
- * The connection object must have been newly created.
- *
- * @param pool the pool from which to remove the connection
- * @param evcon the connection to remove from the pool.
- */
-void evrpc_pool_remove_connection(struct evrpc_pool *pool,
-    struct evhttp_connection *evcon);
-
-/**
- * Sets the timeout in secs after which a request has to complete.  The
- * RPC is completely aborted if it does not complete by then.  Setting
- * the timeout to 0 means that it never timeouts and can be used to
- * implement callback type RPCs.
- *
- * Any connection already in the pool will be updated with the new
- * timeout.  Connections added to the pool after set_timeout has be
- * called receive the pool timeout only if no timeout has been set
- * for the connection itself.
- *
- * @param pool a pointer to a struct evrpc_pool object
- * @param timeout_in_secs the number of seconds after which a request should
- *   timeout and a failure be returned to the callback.
- */
-void evrpc_pool_set_timeout(struct evrpc_pool *pool, int timeout_in_secs);
-
-/**
- * Hooks for changing the input and output of RPCs; this can be used to
- * implement compression, authentication, encryption, ...
- */
-
-enum EVRPC_HOOK_TYPE {
-	EVRPC_INPUT,		/**< apply the function to an input hook */
-	EVRPC_OUTPUT		/**< apply the function to an output hook */
-};
-
-#ifndef WIN32
-/** Deprecated alias for EVRPC_INPUT.  Not available on windows, where it
- * conflicts with platform headers. */
-#define INPUT EVRPC_INPUT
-/** Deprecated alias for EVRPC_OUTPUT.  Not available on windows, where it
- * conflicts with platform headers. */
-#define OUTPUT EVRPC_OUTPUT
-#endif
-
-/**
- * Return value from hook processing functions
- */
-
-enum EVRPC_HOOK_RESULT {
-	EVRPC_TERMINATE = -1,	/**< indicates the rpc should be terminated */
-	EVRPC_CONTINUE = 0,	/**< continue processing the rpc */
-	EVRPC_PAUSE = 1		/**< pause processing request until resumed */
-};
-
-/** adds a processing hook to either an rpc base or rpc pool
- *
- * If a hook returns TERMINATE, the processing is aborted. On CONTINUE,
- * the request is immediately processed after the hook returns.  If the
- * hook returns PAUSE, request processing stops until evrpc_resume_request()
- * has been called.
- *
- * The add functions return handles that can be used for removing hooks.
- *
- * @param vbase a pointer to either struct evrpc_base or struct evrpc_pool
- * @param hook_type either INPUT or OUTPUT
- * @param cb the callback to call when the hook is activated
- * @param cb_arg an additional argument for the callback
- * @return a handle to the hook so it can be removed later
- * @see evrpc_remove_hook()
- */
-void *evrpc_add_hook(void *vbase,
-    enum EVRPC_HOOK_TYPE hook_type,
-    int (*cb)(void *, struct evhttp_request *, struct evbuffer *, void *),
-    void *cb_arg);
-
-/** removes a previously added hook
- *
- * @param vbase a pointer to either struct evrpc_base or struct evrpc_pool
- * @param hook_type either INPUT or OUTPUT
- * @param handle a handle returned by evrpc_add_hook()
- * @return 1 on success or 0 on failure
- * @see evrpc_add_hook()
- */
-int evrpc_remove_hook(void *vbase,
-    enum EVRPC_HOOK_TYPE hook_type,
-    void *handle);
-
-/** resume a paused request
- *
- * @param vbase a pointer to either struct evrpc_base or struct evrpc_pool
- * @param ctx the context pointer provided to the original hook call
- */
-int
-evrpc_resume_request(void *vbase, void *ctx, enum EVRPC_HOOK_RESULT res);
-
-/** adds meta data to request
- *
- * evrpc_hook_add_meta() allows hooks to add meta data to a request. for
- * a client request, the meta data can be inserted by an outgoing request hook
- * and retrieved by the incoming request hook.
- *
- * @param ctx the context provided to the hook call
- * @param key a NUL-terminated c-string
- * @param data the data to be associated with the key
- * @param data_size the size of the data
- */
-void evrpc_hook_add_meta(void *ctx, const char *key,
-    const void *data, size_t data_size);
-
-/** retrieves meta data previously associated
- *
- * evrpc_hook_find_meta() can be used to retrieve meta data associated to a
- * request by a previous hook.
- * @param ctx the context provided to the hook call
- * @param key a NUL-terminated c-string
- * @param data pointer to a data pointer that will contain the retrieved data
- * @param data_size pointer to the size of the data
- * @return 0 on success or -1 on failure
- */
-int evrpc_hook_find_meta(void *ctx, const char *key,
-    void **data, size_t *data_size);
-
-/**
- * returns the connection object associated with the request
- *
- * @param ctx the context provided to the hook call
- * @return a pointer to the evhttp_connection object
- */
-struct evhttp_connection *evrpc_hook_get_connection(void *ctx);
-
-/**
-   Function for sending a generic RPC request.
-
-   Do not call this function directly, use EVRPC_MAKE_REQUEST() instead.
-
-   @see EVRPC_MAKE_REQUEST()
- */
-int evrpc_send_request_generic(struct evrpc_pool *pool,
-    void *request, void *reply,
-    void (*cb)(struct evrpc_status *, void *, void *, void *),
-    void *cb_arg,
-    const char *rpcname,
-    void (*req_marshal)(struct evbuffer *, void *),
-    void (*rpl_clear)(void *),
-    int (*rpl_unmarshal)(void *, struct evbuffer *));
-
-/**
-   Function for registering a generic RPC with the RPC base.
-
-   Do not call this function directly, use EVRPC_REGISTER() instead.
-
-   @see EVRPC_REGISTER()
- */
-int
-evrpc_register_generic(struct evrpc_base *base, const char *name,
-    void (*callback)(struct evrpc_req_generic *, void *), void *cbarg,
-    void *(*req_new)(void *), void *req_new_arg, void (*req_free)(void *),
-    int (*req_unmarshal)(void *, struct evbuffer *),
-    void *(*rpl_new)(void *), void *rpl_new_arg, void (*rpl_free)(void *),
-    int (*rpl_complete)(void *),
-    void (*rpl_marshal)(struct evbuffer *, void *));
-
-/** accessors for obscure and undocumented functionality */
-struct evrpc_pool* evrpc_request_get_pool(struct evrpc_request_wrapper *ctx);
-void evrpc_request_set_pool(struct evrpc_request_wrapper *ctx,
-    struct evrpc_pool *pool);
-void evrpc_request_set_cb(struct evrpc_request_wrapper *ctx,
-    void (*cb)(struct evrpc_status*, void *request, void *reply, void *arg),
-    void *cb_arg);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _EVENT2_RPC_H_ */
+/*
+ * Copyright (c) 2006-2007 Niels Provos <provos@citi.umich.edu>
+ * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EVENT2_RPC_H_INCLUDED_
+#define EVENT2_RPC_H_INCLUDED_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @file rpc.h
+ *
+ * This header files provides basic support for an RPC server and client.
+ *
+ * To support RPCs in a server, every supported RPC command needs to be
+ * defined and registered.
+ *
+ * EVRPC_HEADER(SendCommand, Request, Reply);
+ *
+ *  SendCommand is the name of the RPC command.
+ *  Request is the name of a structure generated by event_rpcgen.py.
+ *    It contains all parameters relating to the SendCommand RPC.  The
+ *    server needs to fill in the Reply structure.
+ *  Reply is the name of a structure generated by event_rpcgen.py.  It
+ *    contains the answer to the RPC.
+ *
+ * To register an RPC with an HTTP server, you need to first create an RPC
+ * base with:
+ *
+ *   struct evrpc_base *base = evrpc_init(http);
+ *
+ * A specific RPC can then be registered with
+ *
+ * EVRPC_REGISTER(base, SendCommand, Request, Reply,  FunctionCB, arg);
+ *
+ * when the server receives an appropriately formatted RPC, the user callback
+ * is invoked.   The callback needs to fill in the reply structure.
+ *
+ * void FunctionCB(EVRPC_STRUCT(SendCommand)* rpc, void *arg);
+ *
+ * To send the reply, call EVRPC_REQUEST_DONE(rpc);
+ *
+ * See the regression test for an example.
+ */
+
+/**
+   Determines if the member has been set in the message
+
+   @param msg the message to inspect
+   @param member the member variable to test for presences
+   @return 1 if it's present or 0 otherwise.
+*/
+#define EVTAG_HAS(msg, member) \
+	((msg)->member##_set == 1)
+
+#ifndef EVENT2_RPC_COMPAT_H_INCLUDED_
+
+/**
+   Assigns a value to the member in the message.
+
+   @param msg the message to which to assign a value
+   @param member the name of the member variable
+   @param value the value to assign
+*/
+#define EVTAG_ASSIGN(msg, member, value) \
+	(*(msg)->base->member##_assign)((msg), (value))
+/**
+   Assigns a value to the member in the message.
+
+   @param msg the message to which to assign a value
+   @param member the name of the member variable
+   @param value the value to assign
+   @param len the length of the value
+*/
+#define EVTAG_ASSIGN_WITH_LEN(msg, member, value, len)	\
+	(*(msg)->base->member##_assign)((msg), (value), (len))
+/**
+   Returns the value for a member.
+
+   @param msg the message from which to get the value
+   @param member the name of the member variable
+   @param pvalue a pointer to the variable to hold the value
+   @return 0 on success, -1 otherwise.
+*/
+#define EVTAG_GET(msg, member, pvalue) \
+	(*(msg)->base->member##_get)((msg), (pvalue))
+/**
+   Returns the value for a member.
+
+   @param msg the message from which to get the value
+   @param member the name of the member variable
+   @param pvalue a pointer to the variable to hold the value
+   @param plen a pointer to the length of the value
+   @return 0 on success, -1 otherwise.
+*/
+#define EVTAG_GET_WITH_LEN(msg, member, pvalue, plen)	\
+	(*(msg)->base->member##_get)((msg), (pvalue), (plen))
+
+#endif  /* EVENT2_RPC_COMPAT_H_INCLUDED_ */
+
+/**
+   Adds a value to an array.
+*/
+#define EVTAG_ARRAY_ADD_VALUE(msg, member, value) \
+	(*(msg)->base->member##_add)((msg), (value))
+/**
+   Allocates a new entry in the array and returns it.
+*/
+#define EVTAG_ARRAY_ADD(msg, member) \
+	(*(msg)->base->member##_add)(msg)
+/**
+   Gets a variable at the specified offset from the array.
+*/
+#define EVTAG_ARRAY_GET(msg, member, offset, pvalue)	\
+	(*(msg)->base->member##_get)((msg), (offset), (pvalue))
+/**
+   Returns the number of entries in the array.
+*/
+#define EVTAG_ARRAY_LEN(msg, member) ((msg)->member##_length)
+
+
+struct evbuffer;
+struct event_base;
+struct evrpc_req_generic;
+struct evrpc_request_wrapper;
+struct evrpc;
+
+/** The type of a specific RPC Message
+ *
+ * @param rpcname the name of the RPC message
+ */
+#define EVRPC_STRUCT(rpcname) struct evrpc_req__##rpcname
+
+struct evhttp_request;
+struct evrpc_status;
+struct evrpc_hook_meta;
+
+/** Creates the definitions and prototypes for an RPC
+ *
+ * You need to use EVRPC_HEADER to create structures and function prototypes
+ * needed by the server and client implementation.  The structures have to be
+ * defined in an .rpc file and converted to source code via event_rpcgen.py
+ *
+ * @param rpcname the name of the RPC
+ * @param reqstruct the name of the RPC request structure
+ * @param replystruct the name of the RPC reply structure
+ * @see EVRPC_GENERATE()
+ */
+#define EVRPC_HEADER(rpcname, reqstruct, rplystruct) \
+EVRPC_STRUCT(rpcname) {	\
+	struct evrpc_hook_meta *hook_meta; \
+	struct reqstruct* request; \
+	struct rplystruct* reply; \
+	struct evrpc* rpc; \
+	struct evhttp_request* http_req; \
+	struct evbuffer* rpc_data; \
+};								     \
+int evrpc_send_request_##rpcname(struct evrpc_pool *, \
+    struct reqstruct *, struct rplystruct *, \
+    void (*)(struct evrpc_status *, \
+	struct reqstruct *, struct rplystruct *, void *cbarg),	\
+    void *);
+
+struct evrpc_pool;
+
+/** use EVRPC_GENERATE instead */
+struct evrpc_request_wrapper *evrpc_make_request_ctx(
+	struct evrpc_pool *pool, void *request, void *reply,
+	const char *rpcname,
+	void (*req_marshal)(struct evbuffer*, void *),
+	void (*rpl_clear)(void *),
+	int (*rpl_unmarshal)(void *, struct evbuffer *),
+	void (*cb)(struct evrpc_status *, void *, void *, void *),
+	void *cbarg);
+
+/** Creates a context structure that contains rpc specific information.
+ *
+ * EVRPC_MAKE_CTX is used to populate a RPC specific context that
+ * contains information about marshaling the RPC data types.
+ *
+ * @param rpcname the name of the RPC
+ * @param reqstruct the name of the RPC request structure
+ * @param replystruct the name of the RPC reply structure
+ * @param pool the evrpc_pool over which to make the request
+ * @param request a pointer to the RPC request structure object
+ * @param reply a pointer to the RPC reply structure object
+ * @param cb the callback function to call when the RPC has completed
+ * @param cbarg the argument to supply to the callback
+ */
+#define EVRPC_MAKE_CTX(rpcname, reqstruct, rplystruct, \
+    pool, request, reply, cb, cbarg)					\
+	evrpc_make_request_ctx(pool, request, reply,			\
+	    #rpcname,							\
+	    (void (*)(struct evbuffer *, void *))reqstruct##_marshal,	\
+	    (void (*)(void *))rplystruct##_clear,			\
+	    (int (*)(void *, struct evbuffer *))rplystruct##_unmarshal, \
+	    (void (*)(struct evrpc_status *, void *, void *, void *))cb, \
+	    cbarg)
+
+/** Generates the code for receiving and sending an RPC message
+ *
+ * EVRPC_GENERATE is used to create the code corresponding to sending
+ * and receiving a particular RPC message
+ *
+ * @param rpcname the name of the RPC
+ * @param reqstruct the name of the RPC request structure
+ * @param replystruct the name of the RPC reply structure
+ * @see EVRPC_HEADER()
+ */
+#define EVRPC_GENERATE(rpcname, reqstruct, rplystruct)			\
+	int evrpc_send_request_##rpcname(struct evrpc_pool *pool,	\
+	    struct reqstruct *request, struct rplystruct *reply,	\
+	    void (*cb)(struct evrpc_status *,				\
+		struct reqstruct *, struct rplystruct *, void *cbarg),	\
+	    void *cbarg) {						\
+	return evrpc_send_request_generic(pool, request, reply,	\
+	    (void (*)(struct evrpc_status *, void *, void *, void *))cb, \
+	    cbarg,							\
+	    #rpcname,							\
+	    (void (*)(struct evbuffer *, void *))reqstruct##_marshal,	\
+	    (void (*)(void *))rplystruct##_clear,			\
+	    (int (*)(void *, struct evbuffer *))rplystruct##_unmarshal); \
+}
+
+/** Provides access to the HTTP request object underlying an RPC
+ *
+ * Access to the underlying http object; can be used to look at headers or
+ * for getting the remote ip address
+ *
+ * @param rpc_req the rpc request structure provided to the server callback
+ * @return an struct evhttp_request object that can be inspected for
+ * HTTP headers or sender information.
+ */
+#define EVRPC_REQUEST_HTTP(rpc_req) (rpc_req)->http_req
+
+/** completes the server response to an rpc request */
+void evrpc_request_done(struct evrpc_req_generic *req);
+
+/** accessors for request and reply */
+void *evrpc_get_request(struct evrpc_req_generic *req);
+void *evrpc_get_reply(struct evrpc_req_generic *req);
+
+/** Creates the reply to an RPC request
+ *
+ * EVRPC_REQUEST_DONE is used to answer a request; the reply is expected
+ * to have been filled in.  The request and reply pointers become invalid
+ * after this call has finished.
+ *
+ * @param rpc_req the rpc request structure provided to the server callback
+ */
+#define EVRPC_REQUEST_DONE(rpc_req) do { \
+  struct evrpc_req_generic *req_ = (struct evrpc_req_generic *)(rpc_req); \
+  evrpc_request_done(req_);					\
+} while (0)
+
+
+struct evrpc_base;
+struct evhttp;
+
+/* functions to start up the rpc system */
+
+/** Creates a new rpc base from which RPC requests can be received
+ *
+ * @param server a pointer to an existing HTTP server
+ * @return a newly allocated evrpc_base struct
+ * @see evrpc_free()
+ */
+struct evrpc_base *evrpc_init(struct evhttp *server);
+
+/**
+ * Frees the evrpc base
+ *
+ * For now, you are responsible for making sure that no rpcs are ongoing.
+ *
+ * @param base the evrpc_base object to be freed
+ * @see evrpc_init
+ */
+void evrpc_free(struct evrpc_base *base);
+
+/** register RPCs with the HTTP Server
+ *
+ * registers a new RPC with the HTTP server, each RPC needs to have
+ * a unique name under which it can be identified.
+ *
+ * @param base the evrpc_base structure in which the RPC should be
+ *   registered.
+ * @param name the name of the RPC
+ * @param request the name of the RPC request structure
+ * @param reply the name of the RPC reply structure
+ * @param callback the callback that should be invoked when the RPC
+ * is received.  The callback has the following prototype
+ *   void (*callback)(EVRPC_STRUCT(Message)* rpc, void *arg)
+ * @param cbarg an additional parameter that can be passed to the callback.
+ *   The parameter can be used to carry around state.
+ */
+#define EVRPC_REGISTER(base, name, request, reply, callback, cbarg)	\
+	evrpc_register_generic(base, #name,				\
+	    (void (*)(struct evrpc_req_generic *, void *))callback, cbarg, \
+	    (void *(*)(void *))request##_new, NULL,			\
+	    (void (*)(void *))request##_free,				\
+	    (int (*)(void *, struct evbuffer *))request##_unmarshal,	\
+	    (void *(*)(void *))reply##_new, NULL,			\
+	    (void (*)(void *))reply##_free, \
+	    (int (*)(void *))reply##_complete, \
+	    (void (*)(struct evbuffer *, void *))reply##_marshal)
+
+/**
+   Low level function for registering an RPC with a server.
+
+   Use EVRPC_REGISTER() instead.
+
+   @see EVRPC_REGISTER()
+*/
+int evrpc_register_rpc(struct evrpc_base *, struct evrpc *,
+    void (*)(struct evrpc_req_generic*, void *), void *);
+
+/**
+ * Unregisters an already registered RPC
+ *
+ * @param base the evrpc_base object from which to unregister an RPC
+ * @param name the name of the rpc to unregister
+ * @return -1 on error or 0 when successful.
+ * @see EVRPC_REGISTER()
+ */
+#define EVRPC_UNREGISTER(base, name) evrpc_unregister_rpc((base), #name)
+
+int evrpc_unregister_rpc(struct evrpc_base *base, const char *name);
+
+/*
+ * Client-side RPC support
+ */
+
+struct evhttp_connection;
+struct evrpc_status;
+
+/** launches an RPC and sends it to the server
+ *
+ * EVRPC_MAKE_REQUEST() is used by the client to send an RPC to the server.
+ *
+ * @param name the name of the RPC
+ * @param pool the evrpc_pool that contains the connection objects over which
+ *   the request should be sent.
+ * @param request a pointer to the RPC request structure - it contains the
+ *   data to be sent to the server.
+ * @param reply a pointer to the RPC reply structure.  It is going to be filled
+ *   if the request was answered successfully
+ * @param cb the callback to invoke when the RPC request has been answered
+ * @param cbarg an additional argument to be passed to the client
+ * @return 0 on success, -1 on failure
+ */
+#define EVRPC_MAKE_REQUEST(name, pool, request, reply, cb, cbarg)	\
+	evrpc_send_request_##name((pool), (request), (reply), (cb), (cbarg))
+
+/**
+   Makes an RPC request based on the provided context.
+
+   This is a low-level function and should not be used directly
+   unless a custom context object is provided.  Use EVRPC_MAKE_REQUEST()
+   instead.
+
+   @param ctx a context from EVRPC_MAKE_CTX()
+   @returns 0 on success, -1 otherwise.
+   @see EVRPC_MAKE_REQUEST(), EVRPC_MAKE_CTX()
+*/
+int evrpc_make_request(struct evrpc_request_wrapper *ctx);
+
+/** creates an rpc connection pool
+ *
+ * a pool has a number of connections associated with it.
+ * rpc requests are always made via a pool.
+ *
+ * @param base a pointer to an struct event_based object; can be left NULL
+ *   in singled-threaded applications
+ * @return a newly allocated struct evrpc_pool object
+ * @see evrpc_pool_free()
+ */
+struct evrpc_pool *evrpc_pool_new(struct event_base *base);
+/** frees an rpc connection pool
+ *
+ * @param pool a pointer to an evrpc_pool allocated via evrpc_pool_new()
+ * @see evrpc_pool_new()
+ */
+void evrpc_pool_free(struct evrpc_pool *pool);
+
+/**
+ * Adds a connection over which rpc can be dispatched to the pool.
+ *
+ * The connection object must have been newly created.
+ *
+ * @param pool the pool to which to add the connection
+ * @param evcon the connection to add to the pool.
+ */
+void evrpc_pool_add_connection(struct evrpc_pool *pool,
+    struct evhttp_connection *evcon);
+
+/**
+ * Removes a connection from the pool.
+ *
+ * The connection object must have been newly created.
+ *
+ * @param pool the pool from which to remove the connection
+ * @param evcon the connection to remove from the pool.
+ */
+void evrpc_pool_remove_connection(struct evrpc_pool *pool,
+    struct evhttp_connection *evcon);
+
+/**
+ * Sets the timeout in secs after which a request has to complete.  The
+ * RPC is completely aborted if it does not complete by then.  Setting
+ * the timeout to 0 means that it never timeouts and can be used to
+ * implement callback type RPCs.
+ *
+ * Any connection already in the pool will be updated with the new
+ * timeout.  Connections added to the pool after set_timeout has be
+ * called receive the pool timeout only if no timeout has been set
+ * for the connection itself.
+ *
+ * @param pool a pointer to a struct evrpc_pool object
+ * @param timeout_in_secs the number of seconds after which a request should
+ *   timeout and a failure be returned to the callback.
+ */
+void evrpc_pool_set_timeout(struct evrpc_pool *pool, int timeout_in_secs);
+
+/**
+ * Hooks for changing the input and output of RPCs; this can be used to
+ * implement compression, authentication, encryption, ...
+ */
+
+enum EVRPC_HOOK_TYPE {
+	EVRPC_INPUT,		/**< apply the function to an input hook */
+	EVRPC_OUTPUT		/**< apply the function to an output hook */
+};
+
+#ifndef _WIN32
+/** Deprecated alias for EVRPC_INPUT.  Not available on windows, where it
+ * conflicts with platform headers. */
+#define INPUT EVRPC_INPUT
+/** Deprecated alias for EVRPC_OUTPUT.  Not available on windows, where it
+ * conflicts with platform headers. */
+#define OUTPUT EVRPC_OUTPUT
+#endif
+
+/**
+ * Return value from hook processing functions
+ */
+
+enum EVRPC_HOOK_RESULT {
+	EVRPC_TERMINATE = -1,	/**< indicates the rpc should be terminated */
+	EVRPC_CONTINUE = 0,	/**< continue processing the rpc */
+	EVRPC_PAUSE = 1		/**< pause processing request until resumed */
+};
+
+/** adds a processing hook to either an rpc base or rpc pool
+ *
+ * If a hook returns TERMINATE, the processing is aborted. On CONTINUE,
+ * the request is immediately processed after the hook returns.  If the
+ * hook returns PAUSE, request processing stops until evrpc_resume_request()
+ * has been called.
+ *
+ * The add functions return handles that can be used for removing hooks.
+ *
+ * @param vbase a pointer to either struct evrpc_base or struct evrpc_pool
+ * @param hook_type either INPUT or OUTPUT
+ * @param cb the callback to call when the hook is activated
+ * @param cb_arg an additional argument for the callback
+ * @return a handle to the hook so it can be removed later
+ * @see evrpc_remove_hook()
+ */
+void *evrpc_add_hook(void *vbase,
+    enum EVRPC_HOOK_TYPE hook_type,
+    int (*cb)(void *, struct evhttp_request *, struct evbuffer *, void *),
+    void *cb_arg);
+
+/** removes a previously added hook
+ *
+ * @param vbase a pointer to either struct evrpc_base or struct evrpc_pool
+ * @param hook_type either INPUT or OUTPUT
+ * @param handle a handle returned by evrpc_add_hook()
+ * @return 1 on success or 0 on failure
+ * @see evrpc_add_hook()
+ */
+int evrpc_remove_hook(void *vbase,
+    enum EVRPC_HOOK_TYPE hook_type,
+    void *handle);
+
+/** resume a paused request
+ *
+ * @param vbase a pointer to either struct evrpc_base or struct evrpc_pool
+ * @param ctx the context pointer provided to the original hook call
+ */
+int
+evrpc_resume_request(void *vbase, void *ctx, enum EVRPC_HOOK_RESULT res);
+
+/** adds meta data to request
+ *
+ * evrpc_hook_add_meta() allows hooks to add meta data to a request. for
+ * a client request, the meta data can be inserted by an outgoing request hook
+ * and retrieved by the incoming request hook.
+ *
+ * @param ctx the context provided to the hook call
+ * @param key a NUL-terminated c-string
+ * @param data the data to be associated with the key
+ * @param data_size the size of the data
+ */
+void evrpc_hook_add_meta(void *ctx, const char *key,
+    const void *data, size_t data_size);
+
+/** retrieves meta data previously associated
+ *
+ * evrpc_hook_find_meta() can be used to retrieve meta data associated to a
+ * request by a previous hook.
+ * @param ctx the context provided to the hook call
+ * @param key a NUL-terminated c-string
+ * @param data pointer to a data pointer that will contain the retrieved data
+ * @param data_size pointer to the size of the data
+ * @return 0 on success or -1 on failure
+ */
+int evrpc_hook_find_meta(void *ctx, const char *key,
+    void **data, size_t *data_size);
+
+/**
+ * returns the connection object associated with the request
+ *
+ * @param ctx the context provided to the hook call
+ * @return a pointer to the evhttp_connection object
+ */
+struct evhttp_connection *evrpc_hook_get_connection(void *ctx);
+
+/**
+   Function for sending a generic RPC request.
+
+   Do not call this function directly, use EVRPC_MAKE_REQUEST() instead.
+
+   @see EVRPC_MAKE_REQUEST()
+ */
+int evrpc_send_request_generic(struct evrpc_pool *pool,
+    void *request, void *reply,
+    void (*cb)(struct evrpc_status *, void *, void *, void *),
+    void *cb_arg,
+    const char *rpcname,
+    void (*req_marshal)(struct evbuffer *, void *),
+    void (*rpl_clear)(void *),
+    int (*rpl_unmarshal)(void *, struct evbuffer *));
+
+/**
+   Function for registering a generic RPC with the RPC base.
+
+   Do not call this function directly, use EVRPC_REGISTER() instead.
+
+   @see EVRPC_REGISTER()
+ */
+int
+evrpc_register_generic(struct evrpc_base *base, const char *name,
+    void (*callback)(struct evrpc_req_generic *, void *), void *cbarg,
+    void *(*req_new)(void *), void *req_new_arg, void (*req_free)(void *),
+    int (*req_unmarshal)(void *, struct evbuffer *),
+    void *(*rpl_new)(void *), void *rpl_new_arg, void (*rpl_free)(void *),
+    int (*rpl_complete)(void *),
+    void (*rpl_marshal)(struct evbuffer *, void *));
+
+/** accessors for obscure and undocumented functionality */
+struct evrpc_pool* evrpc_request_get_pool(struct evrpc_request_wrapper *ctx);
+void evrpc_request_set_pool(struct evrpc_request_wrapper *ctx,
+    struct evrpc_pool *pool);
+void evrpc_request_set_cb(struct evrpc_request_wrapper *ctx,
+    void (*cb)(struct evrpc_status*, void *request, void *reply, void *arg),
+    void *cb_arg);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EVENT2_RPC_H_INCLUDED_ */
Index: dep/libevent/inc/event2/rpc_compat.h
===================================================================
--- dep/libevent/inc/event2/rpc_compat.h	(revision 49)
+++ dep/libevent/inc/event2/rpc_compat.h	(working copy)
@@ -1,61 +1,61 @@
-/*
- * Copyright (c) 2006-2007 Niels Provos <provos@citi.umich.edu>
- * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _EVENT2_RPC_COMPAT_H_
-#define _EVENT2_RPC_COMPAT_H_
-
-/** @file event2/rpc_compat.h
-
-  Deprecated versions of the functions in rpc.h: provided only for
-  backwards compatibility.
-
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** backwards compatible accessors that work only with gcc */
-#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
-
-#undef EVTAG_ASSIGN
-#undef EVTAG_GET
-#undef EVTAG_ADD
-
-#define EVTAG_ASSIGN(msg, member, args...) \
-	(*(msg)->base->member##_assign)(msg, ## args)
-#define EVTAG_GET(msg, member, args...) \
-	(*(msg)->base->member##_get)(msg, ## args)
-#define EVTAG_ADD(msg, member, args...) \
-	(*(msg)->base->member##_add)(msg, ## args)
-#endif
-#define EVTAG_LEN(msg, member) ((msg)->member##_length)
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _EVENT2_EVENT_COMPAT_H_ */
+/*
+ * Copyright (c) 2006-2007 Niels Provos <provos@citi.umich.edu>
+ * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EVENT2_RPC_COMPAT_H_INCLUDED_
+#define EVENT2_RPC_COMPAT_H_INCLUDED_
+
+/** @file event2/rpc_compat.h
+
+  Deprecated versions of the functions in rpc.h: provided only for
+  backwards compatibility.
+
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** backwards compatible accessors that work only with gcc */
+#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
+
+#undef EVTAG_ASSIGN
+#undef EVTAG_GET
+#undef EVTAG_ADD
+
+#define EVTAG_ASSIGN(msg, member, args...) \
+	(*(msg)->base->member##_assign)(msg, ## args)
+#define EVTAG_GET(msg, member, args...) \
+	(*(msg)->base->member##_get)(msg, ## args)
+#define EVTAG_ADD(msg, member, args...) \
+	(*(msg)->base->member##_add)(msg, ## args)
+#endif
+#define EVTAG_LEN(msg, member) ((msg)->member##_length)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EVENT2_EVENT_COMPAT_H_INCLUDED_ */
Index: dep/libevent/inc/event2/rpc_struct.h
===================================================================
--- dep/libevent/inc/event2/rpc_struct.h	(revision 49)
+++ dep/libevent/inc/event2/rpc_struct.h	(working copy)
@@ -1,100 +1,100 @@
-/*
- * Copyright (c) 2006-2007 Niels Provos <provos@citi.umich.edu>
- * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _EVENT2_RPC_STRUCT_H_
-#define _EVENT2_RPC_STRUCT_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** @file event2/rpc_struct.h
-
-  Structures used by rpc.h.  Using these structures directly may harm
-  forward compatibility: be careful!
-
- */
-
-/**
- * provides information about the completed RPC request.
- */
-struct evrpc_status {
-#define EVRPC_STATUS_ERR_NONE		0
-#define EVRPC_STATUS_ERR_TIMEOUT	1
-#define EVRPC_STATUS_ERR_BADPAYLOAD	2
-#define EVRPC_STATUS_ERR_UNSTARTED	3
-#define EVRPC_STATUS_ERR_HOOKABORTED	4
-	int error;
-
-	/* for looking at headers or other information */
-	struct evhttp_request *http_req;
-};
-
-/* the structure below needs to be synchronized with evrpc_req_generic */
-
-/* Encapsulates a request */
-struct evrpc {
-	TAILQ_ENTRY(evrpc) next;
-
-	/* the URI at which the request handler lives */
-	const char* uri;
-
-	/* creates a new request structure */
-	void *(*request_new)(void *);
-	void *request_new_arg;
-
-	/* frees the request structure */
-	void (*request_free)(void *);
-
-	/* unmarshals the buffer into the proper request structure */
-	int (*request_unmarshal)(void *, struct evbuffer *);
-
-	/* creates a new reply structure */
-	void *(*reply_new)(void *);
-	void *reply_new_arg;
-
-	/* frees the reply structure */
-	void (*reply_free)(void *);
-
-	/* verifies that the reply is valid */
-	int (*reply_complete)(void *);
-
-	/* marshals the reply into a buffer */
-	void (*reply_marshal)(struct evbuffer*, void *);
-
-	/* the callback invoked for each received rpc */
-	void (*cb)(struct evrpc_req_generic *, void *);
-	void *cb_arg;
-
-	/* reference for further configuration */
-	struct evrpc_base *base;
-};
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _EVENT2_RPC_STRUCT_H_ */
+/*
+ * Copyright (c) 2006-2007 Niels Provos <provos@citi.umich.edu>
+ * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EVENT2_RPC_STRUCT_H_INCLUDED_
+#define EVENT2_RPC_STRUCT_H_INCLUDED_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @file event2/rpc_struct.h
+
+  Structures used by rpc.h.  Using these structures directly may harm
+  forward compatibility: be careful!
+
+ */
+
+/**
+ * provides information about the completed RPC request.
+ */
+struct evrpc_status {
+#define EVRPC_STATUS_ERR_NONE		0
+#define EVRPC_STATUS_ERR_TIMEOUT	1
+#define EVRPC_STATUS_ERR_BADPAYLOAD	2
+#define EVRPC_STATUS_ERR_UNSTARTED	3
+#define EVRPC_STATUS_ERR_HOOKABORTED	4
+	int error;
+
+	/* for looking at headers or other information */
+	struct evhttp_request *http_req;
+};
+
+/* the structure below needs to be synchronized with evrpc_req_generic */
+
+/* Encapsulates a request */
+struct evrpc {
+	TAILQ_ENTRY(evrpc) next;
+
+	/* the URI at which the request handler lives */
+	const char* uri;
+
+	/* creates a new request structure */
+	void *(*request_new)(void *);
+	void *request_new_arg;
+
+	/* frees the request structure */
+	void (*request_free)(void *);
+
+	/* unmarshals the buffer into the proper request structure */
+	int (*request_unmarshal)(void *, struct evbuffer *);
+
+	/* creates a new reply structure */
+	void *(*reply_new)(void *);
+	void *reply_new_arg;
+
+	/* frees the reply structure */
+	void (*reply_free)(void *);
+
+	/* verifies that the reply is valid */
+	int (*reply_complete)(void *);
+
+	/* marshals the reply into a buffer */
+	void (*reply_marshal)(struct evbuffer*, void *);
+
+	/* the callback invoked for each received rpc */
+	void (*cb)(struct evrpc_req_generic *, void *);
+	void *cb_arg;
+
+	/* reference for further configuration */
+	struct evrpc_base *base;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EVENT2_RPC_STRUCT_H_INCLUDED_ */
Index: dep/libevent/inc/event2/tag.h
===================================================================
--- dep/libevent/inc/event2/tag.h	(revision 49)
+++ dep/libevent/inc/event2/tag.h	(working copy)
@@ -1,124 +1,146 @@
-/*
- * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
- * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _EVENT2_TAG_H_
-#define _EVENT2_TAG_H_
-
-/** @file event2/tag.h
-
-  Helper functions for reading and writing tagged data onto buffers.
-
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <event2/event-config.h>
-#ifdef _EVENT_HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-#ifdef _EVENT_HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif
-
-/* For int types. */
-#include <event2/util.h>
-
-struct evbuffer;
-
-/*
- * Marshaling tagged data - We assume that all tags are inserted in their
- * numeric order - so that unknown tags will always be higher than the
- * known ones - and we can just ignore the end of an event buffer.
- */
-
-void evtag_init(void);
-
-/**
-   Unmarshals the header and returns the length of the payload
-
-   @param evbuf the buffer from which to unmarshal data
-   @param ptag a pointer in which the tag id is being stored
-   @returns -1 on failure or the number of bytes in the remaining payload.
-*/
-int evtag_unmarshal_header(struct evbuffer *evbuf, ev_uint32_t *ptag);
-
-void evtag_marshal(struct evbuffer *evbuf, ev_uint32_t tag, const void *data,
-    ev_uint32_t len);
-void evtag_marshal_buffer(struct evbuffer *evbuf, ev_uint32_t tag,
-    struct evbuffer *data);
-
-/**
-  Encode an integer and store it in an evbuffer.
-
-  We encode integers by nybbles; the first nibble contains the number
-  of significant nibbles - 1;  this allows us to encode up to 64-bit
-  integers.  This function is byte-order independent.
-
-  @param evbuf evbuffer to store the encoded number
-  @param number a 32-bit integer
- */
-void evtag_encode_int(struct evbuffer *evbuf, ev_uint32_t number);
-void evtag_encode_int64(struct evbuffer *evbuf, ev_uint64_t number);
-
-void evtag_marshal_int(struct evbuffer *evbuf, ev_uint32_t tag,
-    ev_uint32_t integer);
-void evtag_marshal_int64(struct evbuffer *evbuf, ev_uint32_t tag,
-    ev_uint64_t integer);
-
-void evtag_marshal_string(struct evbuffer *buf, ev_uint32_t tag,
-    const char *string);
-
-void evtag_marshal_timeval(struct evbuffer *evbuf, ev_uint32_t tag,
-    struct timeval *tv);
-
-int evtag_unmarshal(struct evbuffer *src, ev_uint32_t *ptag,
-    struct evbuffer *dst);
-int evtag_peek(struct evbuffer *evbuf, ev_uint32_t *ptag);
-int evtag_peek_length(struct evbuffer *evbuf, ev_uint32_t *plength);
-int evtag_payload_length(struct evbuffer *evbuf, ev_uint32_t *plength);
-int evtag_consume(struct evbuffer *evbuf);
-
-int evtag_unmarshal_int(struct evbuffer *evbuf, ev_uint32_t need_tag,
-    ev_uint32_t *pinteger);
-int evtag_unmarshal_int64(struct evbuffer *evbuf, ev_uint32_t need_tag,
-    ev_uint64_t *pinteger);
-
-int evtag_unmarshal_fixed(struct evbuffer *src, ev_uint32_t need_tag,
-    void *data, size_t len);
-
-int evtag_unmarshal_string(struct evbuffer *evbuf, ev_uint32_t need_tag,
-    char **pstring);
-
-int evtag_unmarshal_timeval(struct evbuffer *evbuf, ev_uint32_t need_tag,
-    struct timeval *ptv);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _EVENT2_TAG_H_ */
+/*
+ * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
+ * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EVENT2_TAG_H_INCLUDED_
+#define EVENT2_TAG_H_INCLUDED_
+
+/** @file event2/tag.h
+
+  Helper functions for reading and writing tagged data onto buffers.
+
+ */
+
+#include <event2/visibility.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <event2/event-config.h>
+#ifdef EVENT__HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef EVENT__HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+
+/* For int types. */
+#include <event2/util.h>
+
+struct evbuffer;
+
+/*
+ * Marshaling tagged data - We assume that all tags are inserted in their
+ * numeric order - so that unknown tags will always be higher than the
+ * known ones - and we can just ignore the end of an event buffer.
+ */
+
+EVENT2_EXPORT_SYMBOL
+void evtag_init(void);
+
+/**
+   Unmarshals the header and returns the length of the payload
+
+   @param evbuf the buffer from which to unmarshal data
+   @param ptag a pointer in which the tag id is being stored
+   @returns -1 on failure or the number of bytes in the remaining payload.
+*/
+EVENT2_EXPORT_SYMBOL
+int evtag_unmarshal_header(struct evbuffer *evbuf, ev_uint32_t *ptag);
+
+EVENT2_EXPORT_SYMBOL
+void evtag_marshal(struct evbuffer *evbuf, ev_uint32_t tag, const void *data,
+    ev_uint32_t len);
+EVENT2_EXPORT_SYMBOL
+void evtag_marshal_buffer(struct evbuffer *evbuf, ev_uint32_t tag,
+    struct evbuffer *data);
+
+/**
+  Encode an integer and store it in an evbuffer.
+
+  We encode integers by nybbles; the first nibble contains the number
+  of significant nibbles - 1;  this allows us to encode up to 64-bit
+  integers.  This function is byte-order independent.
+
+  @param evbuf evbuffer to store the encoded number
+  @param number a 32-bit integer
+ */
+EVENT2_EXPORT_SYMBOL
+void evtag_encode_int(struct evbuffer *evbuf, ev_uint32_t number);
+EVENT2_EXPORT_SYMBOL
+void evtag_encode_int64(struct evbuffer *evbuf, ev_uint64_t number);
+
+EVENT2_EXPORT_SYMBOL
+void evtag_marshal_int(struct evbuffer *evbuf, ev_uint32_t tag,
+    ev_uint32_t integer);
+EVENT2_EXPORT_SYMBOL
+void evtag_marshal_int64(struct evbuffer *evbuf, ev_uint32_t tag,
+    ev_uint64_t integer);
+
+EVENT2_EXPORT_SYMBOL
+void evtag_marshal_string(struct evbuffer *buf, ev_uint32_t tag,
+    const char *string);
+
+EVENT2_EXPORT_SYMBOL
+void evtag_marshal_timeval(struct evbuffer *evbuf, ev_uint32_t tag,
+    struct timeval *tv);
+
+EVENT2_EXPORT_SYMBOL
+int evtag_unmarshal(struct evbuffer *src, ev_uint32_t *ptag,
+    struct evbuffer *dst);
+EVENT2_EXPORT_SYMBOL
+int evtag_peek(struct evbuffer *evbuf, ev_uint32_t *ptag);
+EVENT2_EXPORT_SYMBOL
+int evtag_peek_length(struct evbuffer *evbuf, ev_uint32_t *plength);
+EVENT2_EXPORT_SYMBOL
+int evtag_payload_length(struct evbuffer *evbuf, ev_uint32_t *plength);
+EVENT2_EXPORT_SYMBOL
+int evtag_consume(struct evbuffer *evbuf);
+
+EVENT2_EXPORT_SYMBOL
+int evtag_unmarshal_int(struct evbuffer *evbuf, ev_uint32_t need_tag,
+    ev_uint32_t *pinteger);
+EVENT2_EXPORT_SYMBOL
+int evtag_unmarshal_int64(struct evbuffer *evbuf, ev_uint32_t need_tag,
+    ev_uint64_t *pinteger);
+
+EVENT2_EXPORT_SYMBOL
+int evtag_unmarshal_fixed(struct evbuffer *src, ev_uint32_t need_tag,
+    void *data, size_t len);
+
+EVENT2_EXPORT_SYMBOL
+int evtag_unmarshal_string(struct evbuffer *evbuf, ev_uint32_t need_tag,
+    char **pstring);
+
+EVENT2_EXPORT_SYMBOL
+int evtag_unmarshal_timeval(struct evbuffer *evbuf, ev_uint32_t need_tag,
+    struct timeval *ptv);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EVENT2_TAG_H_INCLUDED_ */
Index: dep/libevent/inc/event2/tag_compat.h
===================================================================
--- dep/libevent/inc/event2/tag_compat.h	(revision 49)
+++ dep/libevent/inc/event2/tag_compat.h	(working copy)
@@ -1,49 +1,49 @@
-/*
- * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
- * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _EVENT2_TAG_COMPAT_H_
-#define _EVENT2_TAG_COMPAT_H_
-
-/** @file event2/tag_compat.h
-
-    Obsolete/deprecated functions from tag.h; provided only for backwards
-    compatibility.
- */
-
-/**
-   @name Misnamed functions
-
-   @deprecated These macros are deprecated because their names don't follow
-     Libevent's naming conventions.  Use evtag_encode_int and
-     evtag_encode_int64 instead.
-
-   @{
-*/
-#define encode_int(evbuf, number) evtag_encode_int((evbuf), (number))
-#define encode_int64(evbuf, number) evtag_encode_int64((evbuf), (number))
-/**@}*/
-
-#endif /* _EVENT2_TAG_H_ */
+/*
+ * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
+ * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EVENT2_TAG_COMPAT_H_INCLUDED_
+#define EVENT2_TAG_COMPAT_H_INCLUDED_
+
+/** @file event2/tag_compat.h
+
+    Obsolete/deprecated functions from tag.h; provided only for backwards
+    compatibility.
+ */
+
+/**
+   @name Misnamed functions
+
+   @deprecated These macros are deprecated because their names don't follow
+     Libevent's naming conventions.  Use evtag_encode_int and
+     evtag_encode_int64 instead.
+
+   @{
+*/
+#define encode_int(evbuf, number) evtag_encode_int((evbuf), (number))
+#define encode_int64(evbuf, number) evtag_encode_int64((evbuf), (number))
+/**@}*/
+
+#endif /* EVENT2_TAG_H_INCLUDED_ */
Index: dep/libevent/inc/event2/thread.h
===================================================================
--- dep/libevent/inc/event2/thread.h	(revision 49)
+++ dep/libevent/inc/event2/thread.h	(working copy)
@@ -1,236 +1,253 @@
-/*
- * Copyright (c) 2008-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _EVENT2_THREAD_H_
-#define _EVENT2_THREAD_H_
-
-/** @file event2/thread.h
-
-  Functions for multi-threaded applications using Libevent.
-
-  When using a multi-threaded application in which multiple threads
-  add and delete events from a single event base, Libevent needs to
-  lock its data structures.
-
-  Like the memory-management function hooks, all of the threading functions
-  _must_ be set up before an event_base is created if you want the base to
-  use them.
-
-  Most programs will either be using Windows threads or Posix threads.  You
-  can configure Libevent to use one of these event_use_windows_threads() or
-  event_use_pthreads() respectively.  If you're using another threading
-  library, you'll need to configure threading functions manually using
-  evthread_set_lock_callbacks() and evthread_set_condition_callbacks().
-
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <event2/event-config.h>
-
-/**
-   @name Flags passed to lock functions
-
-   @{
-*/
-/** A flag passed to a locking callback when the lock was allocated as a
- * read-write lock, and we want to acquire or release the lock for writing. */
-#define EVTHREAD_WRITE	0x04
-/** A flag passed to a locking callback when the lock was allocated as a
- * read-write lock, and we want to acquire or release the lock for reading. */
-#define EVTHREAD_READ	0x08
-/** A flag passed to a locking callback when we don't want to block waiting
- * for the lock; if we can't get the lock immediately, we will instead
- * return nonzero from the locking callback. */
-#define EVTHREAD_TRY    0x10
-/**@}*/
-
-#if !defined(_EVENT_DISABLE_THREAD_SUPPORT) || defined(_EVENT_IN_DOXYGEN)
-
-#define EVTHREAD_LOCK_API_VERSION 1
-
-/**
-   @name Types of locks
-
-   @{*/
-/** A recursive lock is one that can be acquired multiple times at once by the
- * same thread.  No other process can allocate the lock until the thread that
- * has been holding it has unlocked it as many times as it locked it. */
-#define EVTHREAD_LOCKTYPE_RECURSIVE 1
-/* A read-write lock is one that allows multiple simultaneous readers, but
- * where any one writer excludes all other writers and readers. */
-#define EVTHREAD_LOCKTYPE_READWRITE 2
-/**@}*/
-
-/** This structure describes the interface a threading library uses for
- * locking.   It's used to tell evthread_set_lock_callbacks() how to use
- * locking on this platform.
- */
-struct evthread_lock_callbacks {
-	/** The current version of the locking API.  Set this to
-	 * EVTHREAD_LOCK_API_VERSION */
-	int lock_api_version;
-	/** Which kinds of locks does this version of the locking API
-	 * support?  A bitfield of EVTHREAD_LOCKTYPE_RECURSIVE and
-	 * EVTHREAD_LOCKTYPE_READWRITE.
-	 *
-	 * (Note that RECURSIVE locks are currently mandatory, and
-	 * READWRITE locks are not currently used.)
-	 **/
-	unsigned supported_locktypes;
-	/** Function to allocate and initialize new lock of type 'locktype'.
-	 * Returns NULL on failure. */
-	void *(*alloc)(unsigned locktype);
-	/** Funtion to release all storage held in 'lock', which was created
-	 * with type 'locktype'. */
-	void (*free)(void *lock, unsigned locktype);
-	/** Acquire an already-allocated lock at 'lock' with mode 'mode'.
-	 * Returns 0 on success, and nonzero on failure. */
-	int (*lock)(unsigned mode, void *lock);
-	/** Release a lock at 'lock' using mode 'mode'.  Returns 0 on success,
-	 * and nonzero on failure. */
-	int (*unlock)(unsigned mode, void *lock);
-};
-
-/** Sets a group of functions that Libevent should use for locking.
- * For full information on the required callback API, see the
- * documentation for the individual members of evthread_lock_callbacks.
- *
- * Note that if you're using Windows or the Pthreads threading library, you
- * probably shouldn't call this function; instead, use
- * evthread_use_windows_threads() or evthread_use_posix_threads() if you can.
- */
-int evthread_set_lock_callbacks(const struct evthread_lock_callbacks *);
-
-#define EVTHREAD_CONDITION_API_VERSION 1
-
-struct timeval;
-
-/** This structure describes the interface a threading library uses for
- * condition variables.  It's used to tell evthread_set_condition_callbacks
- * how to use locking on this platform.
- */
-struct evthread_condition_callbacks {
-	/** The current version of the conditions API.  Set this to
-	 * EVTHREAD_CONDITION_API_VERSION */
-	int condition_api_version;
-	/** Function to allocate and initialize a new condition variable.
-	 * Returns the condition variable on success, and NULL on failure.
-	 * The 'condtype' argument will be 0 with this API version.
-	 */
-	void *(*alloc_condition)(unsigned condtype);
-	/** Function to free a condition variable. */
-	void (*free_condition)(void *cond);
-	/** Function to signal a condition variable.  If 'broadcast' is 1, all
-	 * threads waiting on 'cond' should be woken; otherwise, only on one
-	 * thread is worken.  Should return 0 on success, -1 on failure.
-	 * This function will only be called while holding the associated
-	 * lock for the condition.
-	 */
-	int (*signal_condition)(void *cond, int broadcast);
-	/** Function to wait for a condition variable.  The lock 'lock'
-	 * will be held when this function is called; should be released
-	 * while waiting for the condition to be come signalled, and
-	 * should be held again when this function returns.
-	 * If timeout is provided, it is interval of seconds to wait for
-	 * the event to become signalled; if it is NULL, the function
-	 * should wait indefinitely.
-	 *
-	 * The function should return -1 on error; 0 if the condition
-	 * was signalled, or 1 on a timeout. */
-	int (*wait_condition)(void *cond, void *lock,
-	    const struct timeval *timeout);
-};
-
-/** Sets a group of functions that Libevent should use for condition variables.
- * For full information on the required callback API, see the
- * documentation for the individual members of evthread_condition_callbacks.
- *
- * Note that if you're using Windows or the Pthreads threading library, you
- * probably shouldn't call this function; instead, use
- * evthread_use_windows_threads() or evthread_use_pthreads() if you can.
- */
-int evthread_set_condition_callbacks(
-	const struct evthread_condition_callbacks *);
-
-/**
-   Sets the function for determining the thread id.
-
-   @param base the event base for which to set the id function
-   @param id_fn the identify function Libevent should invoke to
-     determine the identity of a thread.
-*/
-void evthread_set_id_callback(
-    unsigned long (*id_fn)(void));
-
-#if (defined(WIN32) && !defined(_EVENT_DISABLE_THREAD_SUPPORT)) || defined(_EVENT_IN_DOXYGEN)
-/** Sets up Libevent for use with Windows builtin locking and thread ID
-    functions.  Unavailable if Libevent is not built for Windows.
-
-    @return 0 on success, -1 on failure. */
-int evthread_use_windows_threads(void);
-/**
-   Defined if Libevent was built with support for evthread_use_windows_threads()
-*/
-#define EVTHREAD_USE_WINDOWS_THREADS_IMPLEMENTED 1
-#endif
-
-#if defined(_EVENT_HAVE_PTHREADS) || defined(_EVENT_IN_DOXYGEN)
-/** Sets up Libevent for use with Pthreads locking and thread ID functions.
-    Unavailable if Libevent is not build for use with pthreads.  Requires
-    libraries to link against Libevent_pthreads as well as Libevent.
-
-    @return 0 on success, -1 on failure. */
-int evthread_use_pthreads(void);
-/** Defined if Libevent was built with support for evthread_use_pthreads() */
-#define EVTHREAD_USE_PTHREADS_IMPLEMENTED 1
-
-#endif
-
-/** Enable debugging wrappers around the current lock callbacks.  If Libevent
- * makes one of several common locking errors, exit with an assertion failure.
- *
- * If you're going to call this function, you must do so before any locks are
- * allocated.
- **/
-void evthread_enable_lock_debuging(void);
-
-#endif /* _EVENT_DISABLE_THREAD_SUPPORT */
-
-struct event_base;
-/** Make sure it's safe to tell an event base to wake up from another thread
-    or a signal handler.
-
-    @return 0 on success, -1 on failure.
- */
-int evthread_make_base_notifiable(struct event_base *base);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _EVENT2_THREAD_H_ */
+/*
+ * Copyright (c) 2008-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EVENT2_THREAD_H_INCLUDED_
+#define EVENT2_THREAD_H_INCLUDED_
+
+/** @file event2/thread.h
+
+  Functions for multi-threaded applications using Libevent.
+
+  When using a multi-threaded application in which multiple threads
+  add and delete events from a single event base, Libevent needs to
+  lock its data structures.
+
+  Like the memory-management function hooks, all of the threading functions
+  _must_ be set up before an event_base is created if you want the base to
+  use them.
+
+  Most programs will either be using Windows threads or Posix threads.  You
+  can configure Libevent to use one of these event_use_windows_threads() or
+  event_use_pthreads() respectively.  If you're using another threading
+  library, you'll need to configure threading functions manually using
+  evthread_set_lock_callbacks() and evthread_set_condition_callbacks().
+
+ */
+
+#include <event2/visibility.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <event2/event-config.h>
+
+/**
+   @name Flags passed to lock functions
+
+   @{
+*/
+/** A flag passed to a locking callback when the lock was allocated as a
+ * read-write lock, and we want to acquire or release the lock for writing. */
+#define EVTHREAD_WRITE	0x04
+/** A flag passed to a locking callback when the lock was allocated as a
+ * read-write lock, and we want to acquire or release the lock for reading. */
+#define EVTHREAD_READ	0x08
+/** A flag passed to a locking callback when we don't want to block waiting
+ * for the lock; if we can't get the lock immediately, we will instead
+ * return nonzero from the locking callback. */
+#define EVTHREAD_TRY    0x10
+/**@}*/
+
+#if !defined(EVENT__DISABLE_THREAD_SUPPORT) || defined(EVENT_IN_DOXYGEN_)
+
+#define EVTHREAD_LOCK_API_VERSION 1
+
+/**
+   @name Types of locks
+
+   @{*/
+/** A recursive lock is one that can be acquired multiple times at once by the
+ * same thread.  No other process can allocate the lock until the thread that
+ * has been holding it has unlocked it as many times as it locked it. */
+#define EVTHREAD_LOCKTYPE_RECURSIVE 1
+/* A read-write lock is one that allows multiple simultaneous readers, but
+ * where any one writer excludes all other writers and readers. */
+#define EVTHREAD_LOCKTYPE_READWRITE 2
+/**@}*/
+
+/** This structure describes the interface a threading library uses for
+ * locking.   It's used to tell evthread_set_lock_callbacks() how to use
+ * locking on this platform.
+ */
+struct evthread_lock_callbacks {
+	/** The current version of the locking API.  Set this to
+	 * EVTHREAD_LOCK_API_VERSION */
+	int lock_api_version;
+	/** Which kinds of locks does this version of the locking API
+	 * support?  A bitfield of EVTHREAD_LOCKTYPE_RECURSIVE and
+	 * EVTHREAD_LOCKTYPE_READWRITE.
+	 *
+	 * (Note that RECURSIVE locks are currently mandatory, and
+	 * READWRITE locks are not currently used.)
+	 **/
+	unsigned supported_locktypes;
+	/** Function to allocate and initialize new lock of type 'locktype'.
+	 * Returns NULL on failure. */
+	void *(*alloc)(unsigned locktype);
+	/** Funtion to release all storage held in 'lock', which was created
+	 * with type 'locktype'. */
+	void (*free)(void *lock, unsigned locktype);
+	/** Acquire an already-allocated lock at 'lock' with mode 'mode'.
+	 * Returns 0 on success, and nonzero on failure. */
+	int (*lock)(unsigned mode, void *lock);
+	/** Release a lock at 'lock' using mode 'mode'.  Returns 0 on success,
+	 * and nonzero on failure. */
+	int (*unlock)(unsigned mode, void *lock);
+};
+
+/** Sets a group of functions that Libevent should use for locking.
+ * For full information on the required callback API, see the
+ * documentation for the individual members of evthread_lock_callbacks.
+ *
+ * Note that if you're using Windows or the Pthreads threading library, you
+ * probably shouldn't call this function; instead, use
+ * evthread_use_windows_threads() or evthread_use_posix_threads() if you can.
+ */
+EVENT2_EXPORT_SYMBOL
+int evthread_set_lock_callbacks(const struct evthread_lock_callbacks *);
+
+#define EVTHREAD_CONDITION_API_VERSION 1
+
+struct timeval;
+
+/** This structure describes the interface a threading library uses for
+ * condition variables.  It's used to tell evthread_set_condition_callbacks
+ * how to use locking on this platform.
+ */
+struct evthread_condition_callbacks {
+	/** The current version of the conditions API.  Set this to
+	 * EVTHREAD_CONDITION_API_VERSION */
+	int condition_api_version;
+	/** Function to allocate and initialize a new condition variable.
+	 * Returns the condition variable on success, and NULL on failure.
+	 * The 'condtype' argument will be 0 with this API version.
+	 */
+	void *(*alloc_condition)(unsigned condtype);
+	/** Function to free a condition variable. */
+	void (*free_condition)(void *cond);
+	/** Function to signal a condition variable.  If 'broadcast' is 1, all
+	 * threads waiting on 'cond' should be woken; otherwise, only on one
+	 * thread is worken.  Should return 0 on success, -1 on failure.
+	 * This function will only be called while holding the associated
+	 * lock for the condition.
+	 */
+	int (*signal_condition)(void *cond, int broadcast);
+	/** Function to wait for a condition variable.  The lock 'lock'
+	 * will be held when this function is called; should be released
+	 * while waiting for the condition to be come signalled, and
+	 * should be held again when this function returns.
+	 * If timeout is provided, it is interval of seconds to wait for
+	 * the event to become signalled; if it is NULL, the function
+	 * should wait indefinitely.
+	 *
+	 * The function should return -1 on error; 0 if the condition
+	 * was signalled, or 1 on a timeout. */
+	int (*wait_condition)(void *cond, void *lock,
+	    const struct timeval *timeout);
+};
+
+/** Sets a group of functions that Libevent should use for condition variables.
+ * For full information on the required callback API, see the
+ * documentation for the individual members of evthread_condition_callbacks.
+ *
+ * Note that if you're using Windows or the Pthreads threading library, you
+ * probably shouldn't call this function; instead, use
+ * evthread_use_windows_threads() or evthread_use_pthreads() if you can.
+ */
+EVENT2_EXPORT_SYMBOL
+int evthread_set_condition_callbacks(
+	const struct evthread_condition_callbacks *);
+
+/**
+   Sets the function for determining the thread id.
+
+   @param base the event base for which to set the id function
+   @param id_fn the identify function Libevent should invoke to
+     determine the identity of a thread.
+*/
+EVENT2_EXPORT_SYMBOL
+void evthread_set_id_callback(
+    unsigned long (*id_fn)(void));
+
+#if (defined(_WIN32) && !defined(EVENT__DISABLE_THREAD_SUPPORT)) || defined(EVENT_IN_DOXYGEN_)
+/** Sets up Libevent for use with Windows builtin locking and thread ID
+    functions.  Unavailable if Libevent is not built for Windows.
+
+    @return 0 on success, -1 on failure. */
+EVENT2_EXPORT_SYMBOL
+int evthread_use_windows_threads(void);
+/**
+   Defined if Libevent was built with support for evthread_use_windows_threads()
+*/
+#define EVTHREAD_USE_WINDOWS_THREADS_IMPLEMENTED 1
+#endif
+
+#if defined(EVENT__HAVE_PTHREADS) || defined(EVENT_IN_DOXYGEN_)
+/** Sets up Libevent for use with Pthreads locking and thread ID functions.
+    Unavailable if Libevent is not build for use with pthreads.  Requires
+    libraries to link against Libevent_pthreads as well as Libevent.
+
+    @return 0 on success, -1 on failure. */
+EVENT2_EXPORT_SYMBOL
+int evthread_use_pthreads(void);
+/** Defined if Libevent was built with support for evthread_use_pthreads() */
+#define EVTHREAD_USE_PTHREADS_IMPLEMENTED 1
+
+#endif
+
+/** Enable debugging wrappers around the current lock callbacks.  If Libevent
+ * makes one of several common locking errors, exit with an assertion failure.
+ *
+ * If you're going to call this function, you must do so before any locks are
+ * allocated.
+ **/
+EVENT2_EXPORT_SYMBOL
+void evthread_enable_lock_debugging(void);
+
+/* Old (misspelled) version: This is deprecated; use
+ * evthread_enable_log_debugging instead. */
+EVENT2_EXPORT_SYMBOL
+void evthread_enable_lock_debuging(void);
+
+#endif /* EVENT__DISABLE_THREAD_SUPPORT */
+
+struct event_base;
+/** Make sure it's safe to tell an event base to wake up from another thread
+    or a signal handler.
+
+    You shouldn't need to call this by hand; configuring the base with thread
+    support should be necessary and sufficient.
+
+    @return 0 on success, -1 on failure.
+ */
+EVENT2_EXPORT_SYMBOL
+int evthread_make_base_notifiable(struct event_base *base);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EVENT2_THREAD_H_INCLUDED_ */
Index: dep/libevent/inc/event2/util.h
===================================================================
--- dep/libevent/inc/event2/util.h	(revision 49)
+++ dep/libevent/inc/event2/util.h	(working copy)
@@ -1,713 +1,852 @@
-/*
- * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _EVENT2_UTIL_H_
-#define _EVENT2_UTIL_H_
-
-/** @file event2/util.h
-
-  Common convenience functions for cross-platform portability and
-  related socket manipulations.
-
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <event2/event-config.h>
-#ifdef _EVENT_HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif
-#ifdef _EVENT_HAVE_STDINT_H
-#include <stdint.h>
-#elif defined(_EVENT_HAVE_INTTYPES_H)
-#include <inttypes.h>
-#endif
-#ifdef _EVENT_HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-#ifdef _EVENT_HAVE_STDDEF_H
-#include <stddef.h>
-#endif
-#ifdef _MSC_VER
-#include <BaseTsd.h>
-#endif
-#include <stdarg.h>
-#ifdef _EVENT_HAVE_NETDB_H
-#if !defined(_GNU_SOURCE)
-#define _GNU_SOURCE
-#endif
-#include <netdb.h>
-#endif
-
-#ifdef WIN32
-#include <winsock2.h>
-#else
-#include <sys/socket.h>
-#endif
-
-/* Some openbsd autoconf versions get the name of this macro wrong. */
-#if defined(_EVENT_SIZEOF_VOID__) && !defined(_EVENT_SIZEOF_VOID_P)
-#define _EVENT_SIZEOF_VOID_P _EVENT_SIZEOF_VOID__
-#endif
-
-/**
- * @name Standard integer types.
- *
- * Integer type definitions for types that are supposed to be defined in the
- * C99-specified stdint.h.  Shamefully, some platforms do not include
- * stdint.h, so we need to replace it.  (If you are on a platform like this,
- * your C headers are now over 10 years out of date.  You should bug them to
- * do something about this.)
- *
- * We define:
- *
- * <dl>
- *   <dt>ev_uint64_t, ev_uint32_t, ev_uint16_t, ev_uint8_t</dt>
- *      <dd>unsigned integer types of exactly 64, 32, 16, and 8 bits
- *          respectively.</dd>
- *    <dt>ev_int64_t, ev_int32_t, ev_int16_t, ev_int8_t</dt>
- *      <dd>signed integer types of exactly 64, 32, 16, and 8 bits
- *          respectively.</dd>
- *    <dt>ev_uintptr_t, ev_intptr_t</dt>
- *      <dd>unsigned/signed integers large enough
- *      to hold a pointer without loss of bits.</dd>
- *    <dt>ev_ssize_t</dt>
- *      <dd>A signed type of the same size as size_t</dd>
- *    <dt>ev_off_t</dt>
- *      <dd>A signed type typically used to represent offsets within a
- *      (potentially large) file</dd>
- *
- * @{
- */
-#ifdef _EVENT_HAVE_UINT64_T
-#define ev_uint64_t uint64_t
-#define ev_int64_t int64_t
-#elif defined(WIN32)
-#define ev_uint64_t unsigned __int64
-#define ev_int64_t signed __int64
-#elif _EVENT_SIZEOF_LONG_LONG == 8
-#define ev_uint64_t unsigned long long
-#define ev_int64_t long long
-#elif _EVENT_SIZEOF_LONG == 8
-#define ev_uint64_t unsigned long
-#define ev_int64_t long
-#elif defined(_EVENT_IN_DOXYGEN)
-#define ev_uint64_t ...
-#define ev_int64_t ...
-#else
-#error "No way to define ev_uint64_t"
-#endif
-
-#ifdef _EVENT_HAVE_UINT32_T
-#define ev_uint32_t uint32_t
-#define ev_int32_t int32_t
-#elif defined(WIN32)
-#define ev_uint32_t unsigned int
-#define ev_int32_t signed int
-#elif _EVENT_SIZEOF_LONG == 4
-#define ev_uint32_t unsigned long
-#define ev_int32_t signed long
-#elif _EVENT_SIZEOF_INT == 4
-#define ev_uint32_t unsigned int
-#define ev_int32_t signed int
-#elif defined(_EVENT_IN_DOXYGEN)
-#define ev_uint32_t ...
-#define ev_int32_t ...
-#else
-#error "No way to define ev_uint32_t"
-#endif
-
-#ifdef _EVENT_HAVE_UINT16_T
-#define ev_uint16_t uint16_t
-#define ev_int16_t  int16_t
-#elif defined(WIN32)
-#define ev_uint16_t unsigned short
-#define ev_int16_t  signed short
-#elif _EVENT_SIZEOF_INT == 2
-#define ev_uint16_t unsigned int
-#define ev_int16_t  signed int
-#elif _EVENT_SIZEOF_SHORT == 2
-#define ev_uint16_t unsigned short
-#define ev_int16_t  signed short
-#elif defined(_EVENT_IN_DOXYGEN)
-#define ev_uint16_t ...
-#define ev_int16_t ...
-#else
-#error "No way to define ev_uint16_t"
-#endif
-
-#ifdef _EVENT_HAVE_UINT8_T
-#define ev_uint8_t uint8_t
-#define ev_int8_t int8_t
-#elif defined(_EVENT_IN_DOXYGEN)
-#define ev_uint8_t ...
-#define ev_int8_t ...
-#else
-#define ev_uint8_t unsigned char
-#define ev_int8_t signed char
-#endif
-
-#ifdef _EVENT_HAVE_UINTPTR_T
-#define ev_uintptr_t uintptr_t
-#define ev_intptr_t intptr_t
-#elif _EVENT_SIZEOF_VOID_P <= 4
-#define ev_uintptr_t ev_uint32_t
-#define ev_intptr_t ev_int32_t
-#elif _EVENT_SIZEOF_VOID_P <= 8
-#define ev_uintptr_t ev_uint64_t
-#define ev_intptr_t ev_int64_t
-#elif defined(_EVENT_IN_DOXYGEN)
-#define ev_uintptr_t ...
-#define ev_intptr_t ...
-#else
-#error "No way to define ev_uintptr_t"
-#endif
-
-#ifdef _EVENT_ssize_t
-#define ev_ssize_t _EVENT_ssize_t
-#else
-#define ev_ssize_t ssize_t
-#endif
-
-#ifdef WIN32
-#define ev_off_t ev_int64_t
-#else
-#define ev_off_t off_t
-#endif
-/**@}*/
-
-/* Limits for integer types.
-
-   We're making two assumptions here:
-     - The compiler does constant folding properly.
-     - The platform does signed arithmetic in two's complement.
-*/
-
-/**
-   @name Limits for integer types
-
-   These macros hold the largest or smallest values possible for the
-   ev_[u]int*_t types.
-
-   @{
-*/
-#define EV_UINT64_MAX ((((ev_uint64_t)0xffffffffUL) << 32) | 0xffffffffUL)
-#define EV_INT64_MAX  ((((ev_int64_t) 0x7fffffffL) << 32) | 0xffffffffL)
-#define EV_INT64_MIN  ((-EV_INT64_MAX) - 1)
-#define EV_UINT32_MAX ((ev_uint32_t)0xffffffffUL)
-#define EV_INT32_MAX  ((ev_int32_t) 0x7fffffffL)
-#define EV_INT32_MIN  ((-EV_INT32_MAX) - 1)
-#define EV_UINT16_MAX ((ev_uint16_t)0xffffUL)
-#define EV_INT16_MAX  ((ev_int16_t) 0x7fffL)
-#define EV_INT16_MIN  ((-EV_INT16_MAX) - 1)
-#define EV_UINT8_MAX  255
-#define EV_INT8_MAX   127
-#define EV_INT8_MIN   ((-EV_INT8_MAX) - 1)
-/** @} */
-
-/**
-   @name Limits for SIZE_T and SSIZE_T
-
-   @{
-*/
-#if _EVENT_SIZEOF_SIZE_T == 8
-#define EV_SIZE_MAX EV_UINT64_MAX
-#define EV_SSIZE_MAX EV_INT64_MAX
-#elif _EVENT_SIZEOF_SIZE_T == 4
-#define EV_SIZE_MAX EV_UINT32_MAX
-#define EV_SSIZE_MAX EV_INT32_MAX
-#elif defined(_EVENT_IN_DOXYGEN)
-#define EV_SIZE_MAX ...
-#define EV_SSIZE_MAX ...
-#else
-#error "No way to define SIZE_MAX"
-#endif
-
-#define EV_SSIZE_MIN ((-EV_SSIZE_MAX) - 1)
-/**@}*/
-
-#ifdef WIN32
-#define ev_socklen_t int
-#elif defined(_EVENT_socklen_t)
-#define ev_socklen_t _EVENT_socklen_t
-#else
-#define ev_socklen_t socklen_t
-#endif
-
-#ifdef _EVENT_HAVE_STRUCT_SOCKADDR_STORAGE___SS_FAMILY
-#if !defined(_EVENT_HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY) \
- && !defined(ss_family)
-#define ss_family __ss_family
-#endif
-#endif
-
-/**
- * A type wide enough to hold the output of "socket()" or "accept()".  On
- * Windows, this is an intptr_t; elsewhere, it is an int. */
-#ifdef WIN32
-#define evutil_socket_t intptr_t
-#else
-#define evutil_socket_t int
-#endif
-
-/** Create two new sockets that are connected to each other.
-
-    On Unix, this simply calls socketpair().  On Windows, it uses the
-    loopback network interface on 127.0.0.1, and only
-    AF_INET,SOCK_STREAM are supported.
-
-    (This may fail on some Windows hosts where firewall software has cleverly
-    decided to keep 127.0.0.1 from talking to itself.)
-
-    Parameters and return values are as for socketpair()
-*/
-int evutil_socketpair(int d, int type, int protocol, evutil_socket_t sv[2]);
-/** Do platform-specific operations as needed to make a socket nonblocking.
-
-    @param sock The socket to make nonblocking
-    @return 0 on success, -1 on failure
- */
-int evutil_make_socket_nonblocking(evutil_socket_t sock);
-
-/** Do platform-specific operations to make a listener socket reusable.
-
-    Specifically, we want to make sure that another program will be able
-    to bind this address right after we've closed the listener.
-
-    This differs from Windows's interpretation of "reusable", which
-    allows multiple listeners to bind the same address at the same time.
-
-    @param sock The socket to make reusable
-    @return 0 on success, -1 on failure
- */
-int evutil_make_listen_socket_reuseable(evutil_socket_t sock);
-
-/** Do platform-specific operations as needed to close a socket upon a
-    successful execution of one of the exec*() functions.
-
-    @param sock The socket to be closed
-    @return 0 on success, -1 on failure
- */
-int evutil_make_socket_closeonexec(evutil_socket_t sock);
-
-/** Do the platform-specific call needed to close a socket returned from
-    socket() or accept().
-
-    @param sock The socket to be closed
-    @return 0 on success, -1 on failure
- */
-int evutil_closesocket(evutil_socket_t sock);
-#define EVUTIL_CLOSESOCKET(s) evutil_closesocket(s)
-
-
-#ifdef WIN32
-/** Return the most recent socket error.  Not idempotent on all platforms. */
-#define EVUTIL_SOCKET_ERROR() WSAGetLastError()
-/** Replace the most recent socket error with errcode */
-#define EVUTIL_SET_SOCKET_ERROR(errcode)		\
-	do { WSASetLastError(errcode); } while (0)
-/** Return the most recent socket error to occur on sock. */
-int evutil_socket_geterror(evutil_socket_t sock);
-/** Convert a socket error to a string. */
-const char *evutil_socket_error_to_string(int errcode);
-#elif defined(_EVENT_IN_DOXYGEN)
-/**
-   @name Socket error functions
-
-   These functions are needed for making programs compatible between
-   Windows and Unix-like platforms.
-
-   You see, Winsock handles socket errors differently from the rest of
-   the world.  Elsewhere, a socket error is like any other error and is
-   stored in errno.  But winsock functions require you to retrieve the
-   error with a special function, and don't let you use strerror for
-   the error codes.  And handling EWOULDBLOCK is ... different.
-
-   @{
-*/
-/** Return the most recent socket error.  Not idempotent on all platforms. */
-#define EVUTIL_SOCKET_ERROR() ...
-/** Replace the most recent socket error with errcode */
-#define EVUTIL_SET_SOCKET_ERROR(errcode) ...
-/** Return the most recent socket error to occur on sock. */
-#define evutil_socket_geterror(sock) ...
-/** Convert a socket error to a string. */
-#define evutil_socket_error_to_string(errcode) ...
-/**@}*/
-#else
-#define EVUTIL_SOCKET_ERROR() (errno)
-#define EVUTIL_SET_SOCKET_ERROR(errcode)		\
-		do { errno = (errcode); } while (0)
-#define evutil_socket_geterror(sock) (errno)
-#define evutil_socket_error_to_string(errcode) (strerror(errcode))
-#endif
-
-
-/**
- * @name Manipulation macros for struct timeval.
- *
- * We define replacements
- * for timeradd, timersub, timerclear, timercmp, and timerisset.
- *
- * @{
- */
-#ifdef _EVENT_HAVE_TIMERADD
-#define evutil_timeradd(tvp, uvp, vvp) timeradd((tvp), (uvp), (vvp))
-#define evutil_timersub(tvp, uvp, vvp) timersub((tvp), (uvp), (vvp))
-#else
-#define evutil_timeradd(tvp, uvp, vvp)					\
-	do {								\
-		(vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec;		\
-		(vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec;       \
-		if ((vvp)->tv_usec >= 1000000) {			\
-			(vvp)->tv_sec++;				\
-			(vvp)->tv_usec -= 1000000;			\
-		}							\
-	} while (0)
-#define	evutil_timersub(tvp, uvp, vvp)					\
-	do {								\
-		(vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec;		\
-		(vvp)->tv_usec = (tvp)->tv_usec - (uvp)->tv_usec;	\
-		if ((vvp)->tv_usec < 0) {				\
-			(vvp)->tv_sec--;				\
-			(vvp)->tv_usec += 1000000;			\
-		}							\
-	} while (0)
-#endif /* !_EVENT_HAVE_HAVE_TIMERADD */
-
-#ifdef _EVENT_HAVE_TIMERCLEAR
-#define evutil_timerclear(tvp) timerclear(tvp)
-#else
-#define	evutil_timerclear(tvp)	(tvp)->tv_sec = (tvp)->tv_usec = 0
-#endif
-/**@}*/
-
-/** Return true iff the tvp is related to uvp according to the relational
- * operator cmp.  Recognized values for cmp are ==, <=, <, >=, and >. */
-#define	evutil_timercmp(tvp, uvp, cmp)					\
-	(((tvp)->tv_sec == (uvp)->tv_sec) ?				\
-	 ((tvp)->tv_usec cmp (uvp)->tv_usec) :				\
-	 ((tvp)->tv_sec cmp (uvp)->tv_sec))
-
-#ifdef _EVENT_HAVE_TIMERISSET
-#define evutil_timerisset(tvp) timerisset(tvp)
-#else
-#define	evutil_timerisset(tvp)	((tvp)->tv_sec || (tvp)->tv_usec)
-#endif
-
-/** Replacement for offsetof on platforms that don't define it. */
-#ifdef offsetof
-#define evutil_offsetof(type, field) offsetof(type, field)
-#else
-#define evutil_offsetof(type, field) ((off_t)(&((type *)0)->field))
-#endif
-
-/* big-int related functions */
-/** Parse a 64-bit value from a string.  Arguments are as for strtol. */
-ev_int64_t evutil_strtoll(const char *s, char **endptr, int base);
-
-/** Replacement for gettimeofday on platforms that lack it. */
-#ifdef _EVENT_HAVE_GETTIMEOFDAY
-#define evutil_gettimeofday(tv, tz) gettimeofday((tv), (tz))
-#else
-struct timezone;
-int evutil_gettimeofday(struct timeval *tv, struct timezone *tz);
-#endif
-
-/** Replacement for snprintf to get consistent behavior on platforms for
-    which the return value of snprintf does not conform to C99.
- */
-int evutil_snprintf(char *buf, size_t buflen, const char *format, ...)
-#ifdef __GNUC__
-	__attribute__((format(printf, 3, 4)))
-#endif
-;
-/** Replacement for vsnprintf to get consistent behavior on platforms for
-    which the return value of snprintf does not conform to C99.
- */
-int evutil_vsnprintf(char *buf, size_t buflen, const char *format, va_list ap)
-#ifdef __GNUC__
-	__attribute__((format(printf, 3, 0)))
-#endif
-;
-
-/** Replacement for inet_ntop for platforms which lack it. */
-const char *evutil_inet_ntop(int af, const void *src, char *dst, size_t len);
-/** Replacement for inet_pton for platforms which lack it. */
-int evutil_inet_pton(int af, const char *src, void *dst);
-struct sockaddr;
-
-/** Parse an IPv4 or IPv6 address, with optional port, from a string.
-
-    Recognized formats are:
-    - [IPv6Address]:port
-    - [IPv6Address]
-    - IPv6Address
-    - IPv4Address:port
-    - IPv4Address
-
-    If no port is specified, the port in the output is set to 0.
-
-    @param str The string to parse.
-    @param out A struct sockaddr to hold the result.  This should probably be
-       a struct sockaddr_storage.
-    @param outlen A pointer to the number of bytes that that 'out' can safely
-       hold.  Set to the number of bytes used in 'out' on success.
-    @return -1 if the address is not well-formed, if the port is out of range,
-       or if out is not large enough to hold the result.  Otherwise returns
-       0 on success.
-*/
-int evutil_parse_sockaddr_port(const char *str, struct sockaddr *out, int *outlen);
-
-/** Compare two sockaddrs; return 0 if they are equal, or less than 0 if sa1
- * preceeds sa2, or greater than 0 if sa1 follows sa2.  If include_port is
- * true, consider the port as well as the address.  Only implemented for
- * AF_INET and AF_INET6 addresses. The ordering is not guaranteed to remain
- * the same between Libevent versions. */
-int evutil_sockaddr_cmp(const struct sockaddr *sa1, const struct sockaddr *sa2,
-    int include_port);
-
-/** As strcasecmp, but always compares the characters in locale-independent
-    ASCII.  That's useful if you're handling data in ASCII-based protocols.
- */
-int evutil_ascii_strcasecmp(const char *str1, const char *str2);
-/** As strncasecmp, but always compares the characters in locale-independent
-    ASCII.  That's useful if you're handling data in ASCII-based protocols.
- */
-int evutil_ascii_strncasecmp(const char *str1, const char *str2, size_t n);
-
-/* Here we define evutil_addrinfo to the native addrinfo type, or redefine it
- * if this system has no getaddrinfo(). */
-#ifdef _EVENT_HAVE_STRUCT_ADDRINFO
-#define evutil_addrinfo addrinfo
-#else
-/** A definition of struct addrinfo for systems that lack it.
-
-    (This is just an alias for struct addrinfo if the system defines
-    struct addrinfo.)
-*/
-struct evutil_addrinfo {
-	int     ai_flags;     /* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */
-	int     ai_family;    /* PF_xxx */
-	int     ai_socktype;  /* SOCK_xxx */
-	int     ai_protocol;  /* 0 or IPPROTO_xxx for IPv4 and IPv6 */
-	size_t  ai_addrlen;   /* length of ai_addr */
-	char   *ai_canonname; /* canonical name for nodename */
-	struct sockaddr  *ai_addr; /* binary address */
-	struct evutil_addrinfo  *ai_next; /* next structure in linked list */
-};
-#endif
-/** @name evutil_getaddrinfo() error codes
-
-    These values are possible error codes for evutil_getaddrinfo() and
-    related functions.
-
-    @{
-*/
-#ifdef EAI_ADDRFAMILY
-#define EVUTIL_EAI_ADDRFAMILY EAI_ADDRFAMILY
-#else
-#define EVUTIL_EAI_ADDRFAMILY -901
-#endif
-#ifdef EAI_AGAIN
-#define EVUTIL_EAI_AGAIN EAI_AGAIN
-#else
-#define EVUTIL_EAI_AGAIN -902
-#endif
-#ifdef EAI_BADFLAGS
-#define EVUTIL_EAI_BADFLAGS EAI_BADFLAGS
-#else
-#define EVUTIL_EAI_BADFLAGS -903
-#endif
-#ifdef EAI_FAIL
-#define EVUTIL_EAI_FAIL EAI_FAIL
-#else
-#define EVUTIL_EAI_FAIL -904
-#endif
-#ifdef EAI_FAMILY
-#define EVUTIL_EAI_FAMILY EAI_FAMILY
-#else
-#define EVUTIL_EAI_FAMILY -905
-#endif
-#ifdef EAI_MEMORY
-#define EVUTIL_EAI_MEMORY EAI_MEMORY
-#else
-#define EVUTIL_EAI_MEMORY -906
-#endif
-/* This test is a bit complicated, since some MS SDKs decide to
- * remove NODATA or redefine it to be the same as NONAME, in a
- * fun interpretation of RFC 2553 and RFC 3493. */
-#if defined(EAI_NODATA) && (!defined(EAI_NONAME) || EAI_NODATA != EAI_NONAME)
-#define EVUTIL_EAI_NODATA EAI_NODATA
-#else
-#define EVUTIL_EAI_NODATA -907
-#endif
-#ifdef EAI_NONAME
-#define EVUTIL_EAI_NONAME EAI_NONAME
-#else
-#define EVUTIL_EAI_NONAME -908
-#endif
-#ifdef EAI_SERVICE
-#define EVUTIL_EAI_SERVICE EAI_SERVICE
-#else
-#define EVUTIL_EAI_SERVICE -909
-#endif
-#ifdef EAI_SOCKTYPE
-#define EVUTIL_EAI_SOCKTYPE EAI_SOCKTYPE
-#else
-#define EVUTIL_EAI_SOCKTYPE -910
-#endif
-#ifdef EAI_SYSTEM
-#define EVUTIL_EAI_SYSTEM EAI_SYSTEM
-#else
-#define EVUTIL_EAI_SYSTEM -911
-#endif
-
-#define EVUTIL_EAI_CANCEL -90001
-
-#ifdef AI_PASSIVE
-#define EVUTIL_AI_PASSIVE AI_PASSIVE
-#else
-#define EVUTIL_AI_PASSIVE 0x1000
-#endif
-#ifdef AI_CANONNAME
-#define EVUTIL_AI_CANONNAME AI_CANONNAME
-#else
-#define EVUTIL_AI_CANONNAME 0x2000
-#endif
-#ifdef AI_NUMERICHOST
-#define EVUTIL_AI_NUMERICHOST AI_NUMERICHOST
-#else
-#define EVUTIL_AI_NUMERICHOST 0x4000
-#endif
-#ifdef AI_NUMERICSERV
-#define EVUTIL_AI_NUMERICSERV AI_NUMERICSERV
-#else
-#define EVUTIL_AI_NUMERICSERV 0x8000
-#endif
-#ifdef AI_V4MAPPED
-#define EVUTIL_AI_V4MAPPED AI_V4MAPPED
-#else
-#define EVUTIL_AI_V4MAPPED 0x10000
-#endif
-#ifdef AI_ALL
-#define EVUTIL_AI_ALL AI_ALL
-#else
-#define EVUTIL_AI_ALL 0x20000
-#endif
-#ifdef AI_ADDRCONFIG
-#define EVUTIL_AI_ADDRCONFIG AI_ADDRCONFIG
-#else
-#define EVUTIL_AI_ADDRCONFIG 0x40000
-#endif
-/**@}*/
-
-struct evutil_addrinfo;
-/**
- * This function clones getaddrinfo for systems that don't have it.  For full
- * details, see RFC 3493, section 6.1.
- *
- * Limitations:
- * - When the system has no getaddrinfo, we fall back to gethostbyname_r or
- *   gethostbyname, with their attendant issues.
- * - The AI_V4MAPPED and AI_ALL flags are not currently implemented.
- *
- * For a nonblocking variant, see evdns_getaddrinfo.
- */
-int evutil_getaddrinfo(const char *nodename, const char *servname,
-    const struct evutil_addrinfo *hints_in, struct evutil_addrinfo **res);
-
-/** Release storage allocated by evutil_getaddrinfo or evdns_getaddrinfo. */
-void evutil_freeaddrinfo(struct evutil_addrinfo *ai);
-
-const char *evutil_gai_strerror(int err);
-
-/** Generate n bytes of secure pseudorandom data, and store them in buf.
- *
- * Current versions of Libevent use an ARC4-based random number generator,
- * seeded using the platform's entropy source (/dev/urandom on Unix-like
- * systems; CryptGenRandom on Windows).  This is not actually as secure as it
- * should be: ARC4 is a pretty lousy cipher, and the current implementation
- * provides only rudimentary prediction- and backtracking-resistance.  Don't
- * use this for serious cryptographic applications.
- */
-void evutil_secure_rng_get_bytes(void *buf, size_t n);
-
-/**
- * Seed the secure random number generator if needed, and return 0 on
- * success or -1 on failure.
- *
- * It is okay to call this function more than once; it will still return
- * 0 if the RNG has been successfully seeded and -1 if it can't be
- * seeded.
- *
- * Ordinarily you don't need to call this function from your own code;
- * Libevent will seed the RNG itself the first time it needs good random
- * numbers.  You only need to call it if (a) you want to double-check
- * that one of the seeding methods did succeed, or (b) you plan to drop
- * the capability to seed (by chrooting, or dropping capabilities, or
- * whatever), and you want to make sure that seeding happens before your
- * program loses the ability to do it.
- */
-int evutil_secure_rng_init(void);
-
-/**
- * Set a filename to use in place of /dev/urandom for seeding the secure
- * PRNG. Return 0 on success, -1 on failure.
- *
- * Call this function BEFORE calling any other initialization or RNG
- * functions.
- *
- * (This string will _NOT_ be copied internally. Do not free it while any
- * user of the secure RNG might be running. Don't pass anything other than a
- * real /dev/...random device file here, or you might lose security.)
- *
- * This API is unstable, and might change in a future libevent version.
- */
-int evutil_secure_rng_set_urandom_device_file(char *fname);
-
-/** Seed the random number generator with extra random bytes.
-
-    You should almost never need to call this function; it should be
-    sufficient to invoke evutil_secure_rng_init(), or let Libevent take
-    care of calling evutil_secure_rng_init() on its own.
-
-    If you call this function as a _replacement_ for the regular
-    entropy sources, then you need to be sure that your input
-    contains a fairly large amount of strong entropy.  Doing so is
-    notoriously hard: most people who try get it wrong.  Watch out!
-
-    @param dat a buffer full of a strong source of random numbers
-    @param datlen the number of bytes to read from datlen
- */
-void evutil_secure_rng_add_bytes(const char *dat, size_t datlen);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _EVUTIL_H_ */
+/*
+ * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EVENT2_UTIL_H_INCLUDED_
+#define EVENT2_UTIL_H_INCLUDED_
+
+/** @file event2/util.h
+
+  Common convenience functions for cross-platform portability and
+  related socket manipulations.
+
+ */
+#include <event2/visibility.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <event2/event-config.h>
+#ifdef EVENT__HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#ifdef EVENT__HAVE_STDINT_H
+#include <stdint.h>
+#elif defined(EVENT__HAVE_INTTYPES_H)
+#include <inttypes.h>
+#endif
+#ifdef EVENT__HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef EVENT__HAVE_STDDEF_H
+#include <stddef.h>
+#endif
+#ifdef _MSC_VER
+#include <BaseTsd.h>
+#endif
+#include <stdarg.h>
+#ifdef EVENT__HAVE_NETDB_H
+#if !defined(_GNU_SOURCE)
+#define _GNU_SOURCE
+#endif
+#include <netdb.h>
+#endif
+
+#ifdef _WIN32
+#include <winsock2.h>
+#ifdef EVENT__HAVE_GETADDRINFO
+/* for EAI_* definitions. */
+#include <ws2tcpip.h>
+#endif
+#else
+#include <sys/socket.h>
+#endif
+
+/* Some openbsd autoconf versions get the name of this macro wrong. */
+#if defined(EVENT__SIZEOF_VOID__) && !defined(EVENT__SIZEOF_VOID_P)
+#define EVENT__SIZEOF_VOID_P EVENT__SIZEOF_VOID__
+#endif
+
+/**
+ * @name Standard integer types.
+ *
+ * Integer type definitions for types that are supposed to be defined in the
+ * C99-specified stdint.h.  Shamefully, some platforms do not include
+ * stdint.h, so we need to replace it.  (If you are on a platform like this,
+ * your C headers are now over 10 years out of date.  You should bug them to
+ * do something about this.)
+ *
+ * We define:
+ *
+ * <dl>
+ *   <dt>ev_uint64_t, ev_uint32_t, ev_uint16_t, ev_uint8_t</dt>
+ *      <dd>unsigned integer types of exactly 64, 32, 16, and 8 bits
+ *          respectively.</dd>
+ *    <dt>ev_int64_t, ev_int32_t, ev_int16_t, ev_int8_t</dt>
+ *      <dd>signed integer types of exactly 64, 32, 16, and 8 bits
+ *          respectively.</dd>
+ *    <dt>ev_uintptr_t, ev_intptr_t</dt>
+ *      <dd>unsigned/signed integers large enough
+ *      to hold a pointer without loss of bits.</dd>
+ *    <dt>ev_ssize_t</dt>
+ *      <dd>A signed type of the same size as size_t</dd>
+ *    <dt>ev_off_t</dt>
+ *      <dd>A signed type typically used to represent offsets within a
+ *      (potentially large) file</dd>
+ *
+ * @{
+ */
+#ifdef EVENT__HAVE_UINT64_T
+#define ev_uint64_t uint64_t
+#define ev_int64_t int64_t
+#elif defined(_WIN32)
+#define ev_uint64_t unsigned __int64
+#define ev_int64_t signed __int64
+#elif EVENT__SIZEOF_LONG_LONG == 8
+#define ev_uint64_t unsigned long long
+#define ev_int64_t long long
+#elif EVENT__SIZEOF_LONG == 8
+#define ev_uint64_t unsigned long
+#define ev_int64_t long
+#elif defined(EVENT_IN_DOXYGEN_)
+#define ev_uint64_t ...
+#define ev_int64_t ...
+#else
+#error "No way to define ev_uint64_t"
+#endif
+
+#ifdef EVENT__HAVE_UINT32_T
+#define ev_uint32_t uint32_t
+#define ev_int32_t int32_t
+#elif defined(_WIN32)
+#define ev_uint32_t unsigned int
+#define ev_int32_t signed int
+#elif EVENT__SIZEOF_LONG == 4
+#define ev_uint32_t unsigned long
+#define ev_int32_t signed long
+#elif EVENT__SIZEOF_INT == 4
+#define ev_uint32_t unsigned int
+#define ev_int32_t signed int
+#elif defined(EVENT_IN_DOXYGEN_)
+#define ev_uint32_t ...
+#define ev_int32_t ...
+#else
+#error "No way to define ev_uint32_t"
+#endif
+
+#ifdef EVENT__HAVE_UINT16_T
+#define ev_uint16_t uint16_t
+#define ev_int16_t  int16_t
+#elif defined(_WIN32)
+#define ev_uint16_t unsigned short
+#define ev_int16_t  signed short
+#elif EVENT__SIZEOF_INT == 2
+#define ev_uint16_t unsigned int
+#define ev_int16_t  signed int
+#elif EVENT__SIZEOF_SHORT == 2
+#define ev_uint16_t unsigned short
+#define ev_int16_t  signed short
+#elif defined(EVENT_IN_DOXYGEN_)
+#define ev_uint16_t ...
+#define ev_int16_t ...
+#else
+#error "No way to define ev_uint16_t"
+#endif
+
+#ifdef EVENT__HAVE_UINT8_T
+#define ev_uint8_t uint8_t
+#define ev_int8_t int8_t
+#elif defined(EVENT_IN_DOXYGEN_)
+#define ev_uint8_t ...
+#define ev_int8_t ...
+#else
+#define ev_uint8_t unsigned char
+#define ev_int8_t signed char
+#endif
+
+#ifdef EVENT__HAVE_UINTPTR_T
+#define ev_uintptr_t uintptr_t
+#define ev_intptr_t intptr_t
+#elif EVENT__SIZEOF_VOID_P <= 4
+#define ev_uintptr_t ev_uint32_t
+#define ev_intptr_t ev_int32_t
+#elif EVENT__SIZEOF_VOID_P <= 8
+#define ev_uintptr_t ev_uint64_t
+#define ev_intptr_t ev_int64_t
+#elif defined(EVENT_IN_DOXYGEN_)
+#define ev_uintptr_t ...
+#define ev_intptr_t ...
+#else
+#error "No way to define ev_uintptr_t"
+#endif
+
+#ifdef EVENT__ssize_t
+#define ev_ssize_t EVENT__ssize_t
+#else
+#define ev_ssize_t ssize_t
+#endif
+
+/* Note that we define ev_off_t based on the compile-time size of off_t that
+ * we used to build Libevent, and not based on the current size of off_t.
+ * (For example, we don't define ev_off_t to off_t.).  We do this because
+ * some systems let you build your software with different off_t sizes
+ * at runtime, and so putting in any dependency on off_t would risk API
+ * mismatch.
+ */
+#ifdef _WIN32
+#define ev_off_t ev_int64_t
+#elif EVENT__SIZEOF_OFF_T == 8
+#define ev_off_t ev_int64_t
+#elif EVENT__SIZEOF_OFF_T == 4
+#define ev_off_t ev_int32_t
+#elif defined(EVENT_IN_DOXYGEN_)
+#define ev_off_t ...
+#else
+#define ev_off_t off_t
+#endif
+/**@}*/
+
+/* Limits for integer types.
+
+   We're making two assumptions here:
+     - The compiler does constant folding properly.
+     - The platform does signed arithmetic in two's complement.
+*/
+
+/**
+   @name Limits for integer types
+
+   These macros hold the largest or smallest values possible for the
+   ev_[u]int*_t types.
+
+   @{
+*/
+#ifndef EVENT__HAVE_STDINT_H
+#define EV_UINT64_MAX ((((ev_uint64_t)0xffffffffUL) << 32) | 0xffffffffUL)
+#define EV_INT64_MAX  ((((ev_int64_t) 0x7fffffffL) << 32) | 0xffffffffL)
+#define EV_INT64_MIN  ((-EV_INT64_MAX) - 1)
+#define EV_UINT32_MAX ((ev_uint32_t)0xffffffffUL)
+#define EV_INT32_MAX  ((ev_int32_t) 0x7fffffffL)
+#define EV_INT32_MIN  ((-EV_INT32_MAX) - 1)
+#define EV_UINT16_MAX ((ev_uint16_t)0xffffUL)
+#define EV_INT16_MAX  ((ev_int16_t) 0x7fffL)
+#define EV_INT16_MIN  ((-EV_INT16_MAX) - 1)
+#define EV_UINT8_MAX  255
+#define EV_INT8_MAX   127
+#define EV_INT8_MIN   ((-EV_INT8_MAX) - 1)
+#else
+#define EV_UINT64_MAX UINT64_MAX
+#define EV_INT64_MAX  INT64_MAX
+#define EV_INT64_MIN  INT64_MIN
+#define EV_UINT32_MAX UINT32_MAX
+#define EV_INT32_MAX  INT32_MAX
+#define EV_INT32_MIN  INT32_MIN
+#define EV_UINT16_MAX UINT16_MAX
+#define EV_INT16_MAX  INT16_MAX
+#define EV_UINT8_MAX  UINT8_MAX
+#define EV_INT8_MAX   INT8_MAX
+#define EV_INT8_MIN   INT8_MIN
+/** @} */
+#endif
+
+
+/**
+   @name Limits for SIZE_T and SSIZE_T
+
+   @{
+*/
+#if EVENT__SIZEOF_SIZE_T == 8
+#define EV_SIZE_MAX EV_UINT64_MAX
+#define EV_SSIZE_MAX EV_INT64_MAX
+#elif EVENT__SIZEOF_SIZE_T == 4
+#define EV_SIZE_MAX EV_UINT32_MAX
+#define EV_SSIZE_MAX EV_INT32_MAX
+#elif defined(EVENT_IN_DOXYGEN_)
+#define EV_SIZE_MAX ...
+#define EV_SSIZE_MAX ...
+#else
+#error "No way to define SIZE_MAX"
+#endif
+
+#define EV_SSIZE_MIN ((-EV_SSIZE_MAX) - 1)
+/**@}*/
+
+#ifdef _WIN32
+#define ev_socklen_t int
+#elif defined(EVENT__socklen_t)
+#define ev_socklen_t EVENT__socklen_t
+#else
+#define ev_socklen_t socklen_t
+#endif
+
+#ifdef EVENT__HAVE_STRUCT_SOCKADDR_STORAGE___SS_FAMILY
+#if !defined(EVENT__HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY) \
+ && !defined(ss_family)
+#define ss_family __ss_family
+#endif
+#endif
+
+/**
+ * A type wide enough to hold the output of "socket()" or "accept()".  On
+ * Windows, this is an intptr_t; elsewhere, it is an int. */
+#ifdef _WIN32
+#define evutil_socket_t intptr_t
+#else
+#define evutil_socket_t int
+#endif
+
+/**
+ * Structure to hold information about a monotonic timer
+ *
+ * Use this with evutil_configure_monotonic_time() and
+ * evutil_gettime_monotonic().
+ *
+ * This is an opaque structure; you can allocate one using
+ * evutil_monotonic_timer_new().
+ *
+ * @see evutil_monotonic_timer_new(), evutil_monotonic_timer_free(),
+ * evutil_configure_monotonic_time(), evutil_gettime_monotonic()
+ */
+struct evutil_monotonic_timer
+#ifdef EVENT_IN_DOXYGEN_
+{/*Empty body so that doxygen will generate documentation here.*/}
+#endif
+;
+
+#define EV_MONOT_PRECISE  1
+#define EV_MONOT_FALLBACK 2
+
+/** Allocate a new struct evutil_monotonic_timer for use with the
+ * evutil_configure_monotonic_time() and evutil_gettime_monotonic()
+ * functions.  You must configure the timer with
+ * evutil_configure_monotonic_time() before using it.
+ */
+EVENT2_EXPORT_SYMBOL
+struct evutil_monotonic_timer * evutil_monotonic_timer_new(void);
+
+/** Free a struct evutil_monotonic_timer that was allocated using
+ * evutil_monotonic_timer_new().
+ */
+EVENT2_EXPORT_SYMBOL
+void evutil_monotonic_timer_free(struct evutil_monotonic_timer *timer);
+
+/** Set up a struct evutil_monotonic_timer; flags can include
+ * EV_MONOT_PRECISE and EV_MONOT_FALLBACK.
+ */
+EVENT2_EXPORT_SYMBOL
+int evutil_configure_monotonic_time(struct evutil_monotonic_timer *timer,
+                                    int flags);
+
+/** Query the current monotonic time from a struct evutil_monotonic_timer
+ * previously configured with evutil_configure_monotonic_time().  Monotonic
+ * time is guaranteed never to run in reverse, but is not necessarily epoch-
+ * based, or relative to any other definite point.  Use it to make reliable
+ * measurements of elapsed time between events even when the system time
+ * may be changed.
+ *
+ * It is not safe to use this funtion on the same timer from multiple
+ * threads.
+ */
+EVENT2_EXPORT_SYMBOL
+int evutil_gettime_monotonic(struct evutil_monotonic_timer *timer,
+                             struct timeval *tp);
+
+/** Create two new sockets that are connected to each other.
+
+    On Unix, this simply calls socketpair().  On Windows, it uses the
+    loopback network interface on 127.0.0.1, and only
+    AF_INET,SOCK_STREAM are supported.
+
+    (This may fail on some Windows hosts where firewall software has cleverly
+    decided to keep 127.0.0.1 from talking to itself.)
+
+    Parameters and return values are as for socketpair()
+*/
+EVENT2_EXPORT_SYMBOL
+int evutil_socketpair(int d, int type, int protocol, evutil_socket_t sv[2]);
+/** Do platform-specific operations as needed to make a socket nonblocking.
+
+    @param sock The socket to make nonblocking
+    @return 0 on success, -1 on failure
+ */
+EVENT2_EXPORT_SYMBOL
+int evutil_make_socket_nonblocking(evutil_socket_t sock);
+
+/** Do platform-specific operations to make a listener socket reusable.
+
+    Specifically, we want to make sure that another program will be able
+    to bind this address right after we've closed the listener.
+
+    This differs from Windows's interpretation of "reusable", which
+    allows multiple listeners to bind the same address at the same time.
+
+    @param sock The socket to make reusable
+    @return 0 on success, -1 on failure
+ */
+EVENT2_EXPORT_SYMBOL
+int evutil_make_listen_socket_reuseable(evutil_socket_t sock);
+
+/** Do platform-specific operations to make a listener port reusable.
+
+    Specifically, we want to make sure that multiple programs which also
+    set the same socket option will be able to bind, listen at the same time.
+
+    This is a feature available only to Linux 3.9+
+
+    @param sock The socket to make reusable
+    @return 0 on success, -1 on failure
+ */
+EVENT2_EXPORT_SYMBOL
+int evutil_make_listen_socket_reuseable_port(evutil_socket_t sock);
+
+/** Do platform-specific operations as needed to close a socket upon a
+    successful execution of one of the exec*() functions.
+
+    @param sock The socket to be closed
+    @return 0 on success, -1 on failure
+ */
+EVENT2_EXPORT_SYMBOL
+int evutil_make_socket_closeonexec(evutil_socket_t sock);
+
+/** Do the platform-specific call needed to close a socket returned from
+    socket() or accept().
+
+    @param sock The socket to be closed
+    @return 0 on success, -1 on failure
+ */
+EVENT2_EXPORT_SYMBOL
+int evutil_closesocket(evutil_socket_t sock);
+#define EVUTIL_CLOSESOCKET(s) evutil_closesocket(s)
+
+/** Do platform-specific operations, if possible, to make a tcp listener
+ *  socket defer accept()s until there is data to read.
+ *  
+ *  Not all platforms support this.  You don't want to do this for every
+ *  listener socket: only the ones that implement a protocol where the
+ *  client transmits before the server needs to respond.
+ *
+ *  @param sock The listening socket to to make deferred
+ *  @return 0 on success (whether the operation is supported or not),
+ *       -1 on failure
+*/ 
+EVENT2_EXPORT_SYMBOL
+int evutil_make_tcp_listen_socket_deferred(evutil_socket_t sock);
+
+#ifdef _WIN32
+/** Return the most recent socket error.  Not idempotent on all platforms. */
+#define EVUTIL_SOCKET_ERROR() WSAGetLastError()
+/** Replace the most recent socket error with errcode */
+#define EVUTIL_SET_SOCKET_ERROR(errcode)		\
+	do { WSASetLastError(errcode); } while (0)
+/** Return the most recent socket error to occur on sock. */
+EVENT2_EXPORT_SYMBOL
+int evutil_socket_geterror(evutil_socket_t sock);
+/** Convert a socket error to a string. */
+EVENT2_EXPORT_SYMBOL
+const char *evutil_socket_error_to_string(int errcode);
+#elif defined(EVENT_IN_DOXYGEN_)
+/**
+   @name Socket error functions
+
+   These functions are needed for making programs compatible between
+   Windows and Unix-like platforms.
+
+   You see, Winsock handles socket errors differently from the rest of
+   the world.  Elsewhere, a socket error is like any other error and is
+   stored in errno.  But winsock functions require you to retrieve the
+   error with a special function, and don't let you use strerror for
+   the error codes.  And handling EWOULDBLOCK is ... different.
+
+   @{
+*/
+/** Return the most recent socket error.  Not idempotent on all platforms. */
+#define EVUTIL_SOCKET_ERROR() ...
+/** Replace the most recent socket error with errcode */
+#define EVUTIL_SET_SOCKET_ERROR(errcode) ...
+/** Return the most recent socket error to occur on sock. */
+#define evutil_socket_geterror(sock) ...
+/** Convert a socket error to a string. */
+#define evutil_socket_error_to_string(errcode) ...
+/**@}*/
+#else
+#define EVUTIL_SOCKET_ERROR() (errno)
+#define EVUTIL_SET_SOCKET_ERROR(errcode)		\
+		do { errno = (errcode); } while (0)
+#define evutil_socket_geterror(sock) (errno)
+#define evutil_socket_error_to_string(errcode) (strerror(errcode))
+#endif
+
+
+/**
+ * @name Manipulation macros for struct timeval.
+ *
+ * We define replacements
+ * for timeradd, timersub, timerclear, timercmp, and timerisset.
+ *
+ * @{
+ */
+#ifdef EVENT__HAVE_TIMERADD
+#define evutil_timeradd(tvp, uvp, vvp) timeradd((tvp), (uvp), (vvp))
+#define evutil_timersub(tvp, uvp, vvp) timersub((tvp), (uvp), (vvp))
+#else
+#define evutil_timeradd(tvp, uvp, vvp)					\
+	do {								\
+		(vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec;		\
+		(vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec;       \
+		if ((vvp)->tv_usec >= 1000000) {			\
+			(vvp)->tv_sec++;				\
+			(vvp)->tv_usec -= 1000000;			\
+		}							\
+	} while (0)
+#define	evutil_timersub(tvp, uvp, vvp)					\
+	do {								\
+		(vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec;		\
+		(vvp)->tv_usec = (tvp)->tv_usec - (uvp)->tv_usec;	\
+		if ((vvp)->tv_usec < 0) {				\
+			(vvp)->tv_sec--;				\
+			(vvp)->tv_usec += 1000000;			\
+		}							\
+	} while (0)
+#endif /* !EVENT__HAVE_TIMERADD */
+
+#ifdef EVENT__HAVE_TIMERCLEAR
+#define evutil_timerclear(tvp) timerclear(tvp)
+#else
+#define	evutil_timerclear(tvp)	(tvp)->tv_sec = (tvp)->tv_usec = 0
+#endif
+/**@}*/
+
+/** Return true iff the tvp is related to uvp according to the relational
+ * operator cmp.  Recognized values for cmp are ==, <=, <, >=, and >. */
+#define	evutil_timercmp(tvp, uvp, cmp)					\
+	(((tvp)->tv_sec == (uvp)->tv_sec) ?				\
+	 ((tvp)->tv_usec cmp (uvp)->tv_usec) :				\
+	 ((tvp)->tv_sec cmp (uvp)->tv_sec))
+
+#ifdef EVENT__HAVE_TIMERISSET
+#define evutil_timerisset(tvp) timerisset(tvp)
+#else
+#define	evutil_timerisset(tvp)	((tvp)->tv_sec || (tvp)->tv_usec)
+#endif
+
+/** Replacement for offsetof on platforms that don't define it. */
+#ifdef offsetof
+#define evutil_offsetof(type, field) offsetof(type, field)
+#else
+#define evutil_offsetof(type, field) ((off_t)(&((type *)0)->field))
+#endif
+
+/* big-int related functions */
+/** Parse a 64-bit value from a string.  Arguments are as for strtol. */
+EVENT2_EXPORT_SYMBOL
+ev_int64_t evutil_strtoll(const char *s, char **endptr, int base);
+
+/** Replacement for gettimeofday on platforms that lack it. */
+#ifdef EVENT__HAVE_GETTIMEOFDAY
+#define evutil_gettimeofday(tv, tz) gettimeofday((tv), (tz))
+#else
+struct timezone;
+EVENT2_EXPORT_SYMBOL
+int evutil_gettimeofday(struct timeval *tv, struct timezone *tz);
+#endif
+
+/** Replacement for snprintf to get consistent behavior on platforms for
+    which the return value of snprintf does not conform to C99.
+ */
+EVENT2_EXPORT_SYMBOL
+int evutil_snprintf(char *buf, size_t buflen, const char *format, ...)
+#ifdef __GNUC__
+	__attribute__((format(printf, 3, 4)))
+#endif
+;
+/** Replacement for vsnprintf to get consistent behavior on platforms for
+    which the return value of snprintf does not conform to C99.
+ */
+EVENT2_EXPORT_SYMBOL
+int evutil_vsnprintf(char *buf, size_t buflen, const char *format, va_list ap)
+#ifdef __GNUC__
+	__attribute__((format(printf, 3, 0)))
+#endif
+;
+
+/** Replacement for inet_ntop for platforms which lack it. */
+EVENT2_EXPORT_SYMBOL
+const char *evutil_inet_ntop(int af, const void *src, char *dst, size_t len);
+/** Replacement for inet_pton for platforms which lack it. */
+EVENT2_EXPORT_SYMBOL
+int evutil_inet_pton(int af, const char *src, void *dst);
+struct sockaddr;
+
+/** Parse an IPv4 or IPv6 address, with optional port, from a string.
+
+    Recognized formats are:
+    - [IPv6Address]:port
+    - [IPv6Address]
+    - IPv6Address
+    - IPv4Address:port
+    - IPv4Address
+
+    If no port is specified, the port in the output is set to 0.
+
+    @param str The string to parse.
+    @param out A struct sockaddr to hold the result.  This should probably be
+       a struct sockaddr_storage.
+    @param outlen A pointer to the number of bytes that that 'out' can safely
+       hold.  Set to the number of bytes used in 'out' on success.
+    @return -1 if the address is not well-formed, if the port is out of range,
+       or if out is not large enough to hold the result.  Otherwise returns
+       0 on success.
+*/
+EVENT2_EXPORT_SYMBOL
+int evutil_parse_sockaddr_port(const char *str, struct sockaddr *out, int *outlen);
+
+/** Compare two sockaddrs; return 0 if they are equal, or less than 0 if sa1
+ * preceeds sa2, or greater than 0 if sa1 follows sa2.  If include_port is
+ * true, consider the port as well as the address.  Only implemented for
+ * AF_INET and AF_INET6 addresses. The ordering is not guaranteed to remain
+ * the same between Libevent versions. */
+EVENT2_EXPORT_SYMBOL
+int evutil_sockaddr_cmp(const struct sockaddr *sa1, const struct sockaddr *sa2,
+    int include_port);
+
+/** As strcasecmp, but always compares the characters in locale-independent
+    ASCII.  That's useful if you're handling data in ASCII-based protocols.
+ */
+EVENT2_EXPORT_SYMBOL
+int evutil_ascii_strcasecmp(const char *str1, const char *str2);
+/** As strncasecmp, but always compares the characters in locale-independent
+    ASCII.  That's useful if you're handling data in ASCII-based protocols.
+ */
+EVENT2_EXPORT_SYMBOL
+int evutil_ascii_strncasecmp(const char *str1, const char *str2, size_t n);
+
+/* Here we define evutil_addrinfo to the native addrinfo type, or redefine it
+ * if this system has no getaddrinfo(). */
+#ifdef EVENT__HAVE_STRUCT_ADDRINFO
+#define evutil_addrinfo addrinfo
+#else
+/** A definition of struct addrinfo for systems that lack it.
+
+    (This is just an alias for struct addrinfo if the system defines
+    struct addrinfo.)
+*/
+struct evutil_addrinfo {
+	int     ai_flags;     /* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */
+	int     ai_family;    /* PF_xxx */
+	int     ai_socktype;  /* SOCK_xxx */
+	int     ai_protocol;  /* 0 or IPPROTO_xxx for IPv4 and IPv6 */
+	size_t  ai_addrlen;   /* length of ai_addr */
+	char   *ai_canonname; /* canonical name for nodename */
+	struct sockaddr  *ai_addr; /* binary address */
+	struct evutil_addrinfo  *ai_next; /* next structure in linked list */
+};
+#endif
+/** @name evutil_getaddrinfo() error codes
+
+    These values are possible error codes for evutil_getaddrinfo() and
+    related functions.
+
+    @{
+*/
+#if defined(EAI_ADDRFAMILY) && defined(EVENT__HAVE_GETADDRINFO)
+#define EVUTIL_EAI_ADDRFAMILY EAI_ADDRFAMILY
+#else
+#define EVUTIL_EAI_ADDRFAMILY -901
+#endif
+#if defined(EAI_AGAIN) && defined(EVENT__HAVE_GETADDRINFO)
+#define EVUTIL_EAI_AGAIN EAI_AGAIN
+#else
+#define EVUTIL_EAI_AGAIN -902
+#endif
+#if defined(EAI_BADFLAGS) && defined(EVENT__HAVE_GETADDRINFO)
+#define EVUTIL_EAI_BADFLAGS EAI_BADFLAGS
+#else
+#define EVUTIL_EAI_BADFLAGS -903
+#endif
+#if defined(EAI_FAIL) && defined(EVENT__HAVE_GETADDRINFO)
+#define EVUTIL_EAI_FAIL EAI_FAIL
+#else
+#define EVUTIL_EAI_FAIL -904
+#endif
+#if defined(EAI_FAMILY) && defined(EVENT__HAVE_GETADDRINFO)
+#define EVUTIL_EAI_FAMILY EAI_FAMILY
+#else
+#define EVUTIL_EAI_FAMILY -905
+#endif
+#if defined(EAI_MEMORY) && defined(EVENT__HAVE_GETADDRINFO)
+#define EVUTIL_EAI_MEMORY EAI_MEMORY
+#else
+#define EVUTIL_EAI_MEMORY -906
+#endif
+/* This test is a bit complicated, since some MS SDKs decide to
+ * remove NODATA or redefine it to be the same as NONAME, in a
+ * fun interpretation of RFC 2553 and RFC 3493. */
+#if defined(EAI_NODATA) && defined(EVENT__HAVE_GETADDRINFO) && (!defined(EAI_NONAME) || EAI_NODATA != EAI_NONAME)
+#define EVUTIL_EAI_NODATA EAI_NODATA
+#else
+#define EVUTIL_EAI_NODATA -907
+#endif
+#if defined(EAI_NONAME) && defined(EVENT__HAVE_GETADDRINFO)
+#define EVUTIL_EAI_NONAME EAI_NONAME
+#else
+#define EVUTIL_EAI_NONAME -908
+#endif
+#if defined(EAI_SERVICE) && defined(EVENT__HAVE_GETADDRINFO)
+#define EVUTIL_EAI_SERVICE EAI_SERVICE
+#else
+#define EVUTIL_EAI_SERVICE -909
+#endif
+#if defined(EAI_SOCKTYPE) && defined(EVENT__HAVE_GETADDRINFO)
+#define EVUTIL_EAI_SOCKTYPE EAI_SOCKTYPE
+#else
+#define EVUTIL_EAI_SOCKTYPE -910
+#endif
+#if defined(EAI_SYSTEM) && defined(EVENT__HAVE_GETADDRINFO)
+#define EVUTIL_EAI_SYSTEM EAI_SYSTEM
+#else
+#define EVUTIL_EAI_SYSTEM -911
+#endif
+
+#define EVUTIL_EAI_CANCEL -90001
+
+#if defined(AI_PASSIVE) && defined(EVENT__HAVE_GETADDRINFO)
+#define EVUTIL_AI_PASSIVE AI_PASSIVE
+#else
+#define EVUTIL_AI_PASSIVE 0x1000
+#endif
+#if defined(AI_CANONNAME) && defined(EVENT__HAVE_GETADDRINFO)
+#define EVUTIL_AI_CANONNAME AI_CANONNAME
+#else
+#define EVUTIL_AI_CANONNAME 0x2000
+#endif
+#if defined(AI_NUMERICHOST) && defined(EVENT__HAVE_GETADDRINFO)
+#define EVUTIL_AI_NUMERICHOST AI_NUMERICHOST
+#else
+#define EVUTIL_AI_NUMERICHOST 0x4000
+#endif
+#if defined(AI_NUMERICSERV) && defined(EVENT__HAVE_GETADDRINFO)
+#define EVUTIL_AI_NUMERICSERV AI_NUMERICSERV
+#else
+#define EVUTIL_AI_NUMERICSERV 0x8000
+#endif
+#if defined(AI_V4MAPPED) && defined(EVENT__HAVE_GETADDRINFO)
+#define EVUTIL_AI_V4MAPPED AI_V4MAPPED
+#else
+#define EVUTIL_AI_V4MAPPED 0x10000
+#endif
+#if defined(AI_ALL) && defined(EVENT__HAVE_GETADDRINFO)
+#define EVUTIL_AI_ALL AI_ALL
+#else
+#define EVUTIL_AI_ALL 0x20000
+#endif
+#if defined(AI_ADDRCONFIG) && defined(EVENT__HAVE_GETADDRINFO)
+#define EVUTIL_AI_ADDRCONFIG AI_ADDRCONFIG
+#else
+#define EVUTIL_AI_ADDRCONFIG 0x40000
+#endif
+/**@}*/
+
+struct evutil_addrinfo;
+/**
+ * This function clones getaddrinfo for systems that don't have it.  For full
+ * details, see RFC 3493, section 6.1.
+ *
+ * Limitations:
+ * - When the system has no getaddrinfo, we fall back to gethostbyname_r or
+ *   gethostbyname, with their attendant issues.
+ * - The AI_V4MAPPED and AI_ALL flags are not currently implemented.
+ *
+ * For a nonblocking variant, see evdns_getaddrinfo.
+ */
+EVENT2_EXPORT_SYMBOL
+int evutil_getaddrinfo(const char *nodename, const char *servname,
+    const struct evutil_addrinfo *hints_in, struct evutil_addrinfo **res);
+
+/** Release storage allocated by evutil_getaddrinfo or evdns_getaddrinfo. */
+EVENT2_EXPORT_SYMBOL
+void evutil_freeaddrinfo(struct evutil_addrinfo *ai);
+
+EVENT2_EXPORT_SYMBOL
+const char *evutil_gai_strerror(int err);
+
+/** Generate n bytes of secure pseudorandom data, and store them in buf.
+ *
+ * Current versions of Libevent use an ARC4-based random number generator,
+ * seeded using the platform's entropy source (/dev/urandom on Unix-like
+ * systems; CryptGenRandom on Windows).  This is not actually as secure as it
+ * should be: ARC4 is a pretty lousy cipher, and the current implementation
+ * provides only rudimentary prediction- and backtracking-resistance.  Don't
+ * use this for serious cryptographic applications.
+ */
+EVENT2_EXPORT_SYMBOL
+void evutil_secure_rng_get_bytes(void *buf, size_t n);
+
+/**
+ * Seed the secure random number generator if needed, and return 0 on
+ * success or -1 on failure.
+ *
+ * It is okay to call this function more than once; it will still return
+ * 0 if the RNG has been successfully seeded and -1 if it can't be
+ * seeded.
+ *
+ * Ordinarily you don't need to call this function from your own code;
+ * Libevent will seed the RNG itself the first time it needs good random
+ * numbers.  You only need to call it if (a) you want to double-check
+ * that one of the seeding methods did succeed, or (b) you plan to drop
+ * the capability to seed (by chrooting, or dropping capabilities, or
+ * whatever), and you want to make sure that seeding happens before your
+ * program loses the ability to do it.
+ */
+EVENT2_EXPORT_SYMBOL
+int evutil_secure_rng_init(void);
+
+/**
+ * Set a filename to use in place of /dev/urandom for seeding the secure
+ * PRNG. Return 0 on success, -1 on failure.
+ *
+ * Call this function BEFORE calling any other initialization or RNG
+ * functions.
+ *
+ * (This string will _NOT_ be copied internally. Do not free it while any
+ * user of the secure RNG might be running. Don't pass anything other than a
+ * real /dev/...random device file here, or you might lose security.)
+ *
+ * This API is unstable, and might change in a future libevent version.
+ */
+EVENT2_EXPORT_SYMBOL
+int evutil_secure_rng_set_urandom_device_file(char *fname);
+
+/** Seed the random number generator with extra random bytes.
+
+    You should almost never need to call this function; it should be
+    sufficient to invoke evutil_secure_rng_init(), or let Libevent take
+    care of calling evutil_secure_rng_init() on its own.
+
+    If you call this function as a _replacement_ for the regular
+    entropy sources, then you need to be sure that your input
+    contains a fairly large amount of strong entropy.  Doing so is
+    notoriously hard: most people who try get it wrong.  Watch out!
+
+    @param dat a buffer full of a strong source of random numbers
+    @param datlen the number of bytes to read from datlen
+ */
+EVENT2_EXPORT_SYMBOL
+void evutil_secure_rng_add_bytes(const char *dat, size_t datlen);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EVENT1_EVUTIL_H_INCLUDED_ */
Index: dep/libevent/inc/win32/event2/event-config.h
===================================================================
--- dep/libevent/inc/win32/event2/event-config.h	(revision 49)
+++ dep/libevent/inc/win32/event2/event-config.h	(working copy)
@@ -1,363 +1,534 @@
-/* event2/event-config.h
+/* event-config.h
  *
- * This file was generated by autoconf when libevent was built, and post-
- * processed by Libevent so that its macros would have a uniform prefix.
+ * This file was generated by cmake when the makefiles were generated.
  *
  * DO NOT EDIT THIS FILE.
  *
  * Do not rely on macros in this file existing in later versions.
  */
-#ifndef _EVENT_CONFIG_H_
-#define _EVENT_CONFIG_H_
-/* config.h.  Generated by configure.  */
-/* config.h.in.  Generated from configure.in by autoheader.  */
+#ifndef EVENT2_EVENT_CONFIG_H_INCLUDED_
+#define EVENT2_EVENT_CONFIG_H_INCLUDED_
 
+/* Numeric representation of the version */
+#define EVENT__NUMERIC_VERSION 0x02010500
+#define EVENT__PACKAGE_VERSION "2.1.5"
+
+#define EVENT__VERSION_MAJOR 2
+#define EVENT__VERSION_MINOR 1
+#define EVENT__VERSION_PATCH 5
+
+/* Version number of package */
+#define EVENT__VERSION "2.1.5-beta"
+
+/* Name of package */
+#define EVENT__PACKAGE "libevent"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define EVENT__PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define EVENT__PACKAGE_NAME ""
+
+/* Define to the full name and version of this package. */
+#define EVENT__PACKAGE_STRING ""
+
+/* Define to the one symbol short name of this package. */
+#define EVENT__PACKAGE_TARNAME ""
+
+/* Define if libevent should build without support for a debug mode */
+/* #undef EVENT__DISABLE_DEBUG_MODE */
+
 /* Define if libevent should not allow replacing the mm functions */
-/* #undef _EVENT_DISABLE_MM_REPLACEMENT */
+/* #undef EVENT__DISABLE_MM_REPLACEMENT */
 
 /* Define if libevent should not be compiled with thread support */
-/* #undef _EVENT_DISABLE_THREAD_SUPPORT */
+/* #undef EVENT__DISABLE_THREAD_SUPPORT */
 
+/* Define to 1 if you have the `accept4' function. */
+/* #undef EVENT__HAVE_ACCEPT4 */
+
+/* Define to 1 if you have the `arc4random' function. */
+/* #undef EVENT__HAVE_ARC4RANDOM */
+
+/* Define to 1 if you have the `arc4random_buf' function. */
+/* #undef EVENT__HAVE_ARC4RANDOM_BUF */
+
 /* Define if clock_gettime is available in libc */
-/* #undef _EVENT_DNS_USE_CPU_CLOCK_FOR_ID */
+/* #undef EVENT__DNS_USE_CPU_CLOCK_FOR_ID */
 
 /* Define is no secure id variant is available */
-/* #define _EVENT_DNS_USE_GETTIMEOFDAY_FOR_ID 1 */
-#define _EVENT_DNS_USE_FTIME_FOR_ID 1
+/* #undef EVENT__DNS_USE_GETTIMEOFDAY_FOR_ID */
+#define EVENT__DNS_USE_FTIME_FOR_ID
 
 /* Define to 1 if you have the <arpa/inet.h> header file. */
-/* #undef _EVENT_HAVE_ARPA_INET_H */
+/* #undef EVENT__HAVE_ARPA_INET_H */
 
 /* Define to 1 if you have the `clock_gettime' function. */
-/* #undef _EVENT_HAVE_CLOCK_GETTIME */
+/* #undef EVENT__HAVE_CLOCK_GETTIME */
 
+/* Define to 1 if you have the declaration of `CTL_KERN'. */
+/* #undef EVENT__HAVE_DECL_CTL_KERN */
+
+/* Define to 1 if you have the declaration of `KERN_ARND'. */
+/* #undef EVENT__HAVE_DECL_KERN_ARND */
+
+/* Define to 1 if you have the declaration of `KERN_RANDOM'. */
+/* #undef EVENT__HAVE_DECL_KERN_RANDOM */
+
 /* Define if /dev/poll is available */
-/* #undef _EVENT_HAVE_DEVPOLL */
+/* #undef EVENT__HAVE_DEVPOLL */
 
+/* Define to 1 if you have the <netdb.h> header file. */
+/* #undef EVENT__HAVE_NETDB_H */
+
+/* Define to 1 if fd_mask type is defined */
+/* #undef EVENT__HAVE_FD_MASK */
+
+/* Define to 1 if the <sys/queue.h> header file defines TAILQ_FOREACH. */
+/* #undef EVENT__HAVE_TAILQFOREACH */
+
 /* Define to 1 if you have the <dlfcn.h> header file. */
-/* #undef _EVENT_HAVE_DLFCN_H */
+/* #undef EVENT__HAVE_DLFCN_H */
 
 /* Define if your system supports the epoll system calls */
-/* #undef _EVENT_HAVE_EPOLL */
+/* #undef EVENT__HAVE_EPOLL */
 
+/* Define to 1 if you have the `epoll_create1' function. */
+/* #undef EVENT__HAVE_EPOLL_CREATE1 */
+
 /* Define to 1 if you have the `epoll_ctl' function. */
-/* #undef _EVENT_HAVE_EPOLL_CTL */
+/* #undef EVENT__HAVE_EPOLL_CTL */
 
 /* Define to 1 if you have the `eventfd' function. */
-/* #undef _EVENT_HAVE_EVENTFD */
+/* #undef EVENT__HAVE_EVENTFD */
 
 /* Define if your system supports event ports */
-/* #undef _EVENT_HAVE_EVENT_PORTS */
+/* #undef EVENT__HAVE_EVENT_PORTS */
 
 /* Define to 1 if you have the `fcntl' function. */
-/* #undef _EVENT_HAVE_FCNTL */
+/* #undef EVENT__HAVE_FCNTL */
 
 /* Define to 1 if you have the <fcntl.h> header file. */
-#define _EVENT_HAVE_FCNTL_H 1
+#define EVENT__HAVE_FCNTL_H
 
 /* Define to 1 if you have the `getaddrinfo' function. */
-#define _EVENT_HAVE_GETADDRINFO 1
+#define EVENT__HAVE_GETADDRINFO
 
+/* Define to 1 if you have the `getegid' function. */
+/* #undef EVENT__HAVE_GETEGID */
+
+/* Define to 1 if you have the `geteuid' function. */
+/* #undef EVENT__HAVE_GETEUID */
+
+/* TODO: Check for different gethostname argument counts. CheckPrototypeDefinition.cmake can be used. */
+/* Define this if you have any gethostbyname_r() */
+/* #undef EVENT__HAVE_GETHOSTBYNAME_R */
+
+/* Define this if gethostbyname_r takes 3 arguments */
+/* #undef EVENT__HAVE_GETHOSTBYNAME_R_3_ARG */
+
+/* Define this if gethostbyname_r takes 5 arguments */
+/* #undef EVENT__HAVE_GETHOSTBYNAME_R_5_ARG */
+
+/* Define this if gethostbyname_r takes 6 arguments */
+/* #undef EVENT__HAVE_GETHOSTBYNAME_R_6_ARG */
+
+/* Define to 1 if you have the `getifaddrs' function. */
+/* #undef EVENT__HAVE_GETIFADDRS */
+
 /* Define to 1 if you have the `getnameinfo' function. */
-#define _EVENT_HAVE_GETNAMEINFO 1
+#define EVENT__HAVE_GETNAMEINFO
 
 /* Define to 1 if you have the `getprotobynumber' function. */
-#define _EVENT_HAVE_GETPROTOBYNUMBER 1
+#define EVENT__HAVE_GETPROTOBYNUMBER
 
 /* Define to 1 if you have the `getservbyname' function. */
-#define _EVENT_HAVE_GETSERVBYNAME 1
+#define EVENT__HAVE_GETSERVBYNAME
 
 /* Define to 1 if you have the `gettimeofday' function. */
-/* #define _EVENT_HAVE_GETTIMEOFDAY 1 */
+/* #undef EVENT__HAVE_GETTIMEOFDAY */
 
-/* Define to 1 if you have the `inet_aton' function. */
-/* #undef _EVENT_HAVE_INET_ATON */
+/* Define to 1 if you have the <ifaddrs.h> header file. */
+/* #undef EVENT__HAVE_IFADDRS_H */
 
 /* Define to 1 if you have the `inet_ntop' function. */
-/* #undef _EVENT_HAVE_INET_NTOP */
+/* #undef EVENT__HAVE_INET_NTOP */
 
 /* Define to 1 if you have the `inet_pton' function. */
-/* #undef _EVENT_HAVE_INET_PTON */
+/* #undef EVENT__HAVE_INET_PTON */
 
 /* Define to 1 if you have the <inttypes.h> header file. */
-/* #define _EVENT_HAVE_INTTYPES_H 1 */
+#define EVENT__HAVE_INTTYPES_H
 
+/* Define to 1 if you have the `issetugid' function. */
+/* #undef EVENT__HAVE_ISSETUGID */
+
 /* Define to 1 if you have the `kqueue' function. */
-/* #undef _EVENT_HAVE_KQUEUE */
+/* #undef EVENT__HAVE_KQUEUE */
 
 /* Define if the system has zlib */
-/* #undef _EVENT_HAVE_LIBZ */
+/* #undef EVENT__HAVE_LIBZ */
 
+/* Define to 1 if you have the `mach_absolute_time' function. */
+/* #undef EVENT__HAVE_MACH_ABSOLUTE_TIME */
+
+/* Define to 1 if you have the <mach/mach_time.h> header file. */
+/* #undef EVENT__HAVE_MACH_MACH_TIME_H */
+
 /* Define to 1 if you have the <memory.h> header file. */
-#define _EVENT_HAVE_MEMORY_H 1
+#define EVENT__HAVE_MEMORY_H
 
 /* Define to 1 if you have the `mmap' function. */
-/* #undef _EVENT_HAVE_MMAP */
+/* #undef EVENT__HAVE_MMAP */
 
+/* Define to 1 if you have the `nanosleep' function. */
+/* #undef EVENT__HAVE_NANOSLEEP */
+
+/* Define to 1 if you have the `usleep' function. */
+/* #undef EVENT__HAVE_USLEEP */
+
+/* Define to 1 if you have the <netdb.h> header file. */
+/* #undef EVENT__HAVE_NETDB_H */
+
 /* Define to 1 if you have the <netinet/in6.h> header file. */
-/* #undef _EVENT_HAVE_NETINET_IN6_H */
+/* #undef EVENT__HAVE_NETINET_IN6_H */
 
 /* Define to 1 if you have the <netinet/in.h> header file. */
-/* #undef _EVENT_HAVE_NETINET_IN_H */
+/* #undef EVENT__HAVE_NETINET_IN_H */
 
+/* Define to 1 if you have the <netinet/tcp.h> header file. */
+/* #undef EVENT__HAVE_NETINET_TCP_H */
+
+/* Define if the system has openssl */
+/* #undef EVENT__HAVE_OPENSSL */
+
+/* Defines if the system has zlib */
+/* #undef EVENT__HAVE_ZLIB */
+
 /* Define to 1 if you have the `pipe' function. */
-/* #undef _EVENT_HAVE_PIPE */
+/* #undef EVENT__HAVE_PIPE */
 
+/* Define to 1 if you have the `pipe2' function. */
+/* #undef EVENT__HAVE_PIPE2 */
+
 /* Define to 1 if you have the `poll' function. */
-/* #undef _EVENT_HAVE_POLL */
+/* #undef EVENT__HAVE_POLL */
 
 /* Define to 1 if you have the <poll.h> header file. */
-/* #undef _EVENT_HAVE_POLL_H */
+/* #undef EVENT__HAVE_POLL_H */
 
 /* Define to 1 if you have the `port_create' function. */
-/* #undef _EVENT_HAVE_PORT_CREATE */
+/* #undef EVENT__HAVE_PORT_CREATE */
 
 /* Define to 1 if you have the <port.h> header file. */
-/* #undef _EVENT_HAVE_PORT_H */
+/* #undef EVENT__HAVE_PORT_H */
 
 /* Define if you have POSIX threads libraries and header files. */
-/* #undef _EVENT_HAVE_PTHREAD */
+/* #undef EVENT__HAVE_PTHREAD */
 
 /* Define if we have pthreads on this system */
-/* #undef _EVENT_HAVE_PTHREADS */
+/* #undef EVENT__HAVE_PTHREADS */
 
+/* Define to 1 if you have the `putenv' function. */
+#define EVENT__HAVE_PUTENV
+
 /* Define to 1 if the system has the type `sa_family_t'. */
-/* #undef _EVENT_HAVE_SA_FAMILY_T */
+/* #undef EVENT__HAVE_SA_FAMILY_T */
 
 /* Define to 1 if you have the `select' function. */
-/* #undef _EVENT_HAVE_SELECT */
+/* #undef EVENT__HAVE_SELECT */
 
+/* Define to 1 if you have the `setenv' function. */
+/* #undef EVENT__HAVE_SETENV */
+
+/* Define if F_SETFD is defined in <fcntl.h> */
+/* #undef EVENT__HAVE_SETFD */
+
+/* Define to 1 if you have the `setrlimit' function. */
+/* #undef EVENT__HAVE_SETRLIMIT */
+
 /* Define to 1 if you have the `sendfile' function. */
-/* #undef _EVENT_HAVE_SENDFILE */
+/* #undef EVENT__HAVE_SENDFILE */
 
 /* Define if F_SETFD is defined in <fcntl.h> */
-/* #undef _EVENT_HAVE_SETFD */
+/* #undef EVENT__HAVE_SETFD */
 
 /* Define to 1 if you have the `sigaction' function. */
-/* #undef _EVENT_HAVE_SIGACTION */
+/* #undef EVENT__HAVE_SIGACTION */
 
 /* Define to 1 if you have the `signal' function. */
-#define _EVENT_HAVE_SIGNAL 1
+/* #undef EVENT__HAVE_SIGNAL */
 
 /* Define to 1 if you have the `splice' function. */
-/* #undef _EVENT_HAVE_SPLICE */
+/* #undef EVENT__HAVE_SPLICE */
 
 /* Define to 1 if you have the <stdarg.h> header file. */
-#define _EVENT_HAVE_STDARG_H 1
+#define EVENT__HAVE_STDARG_H
 
 /* Define to 1 if you have the <stddef.h> header file. */
-#define _EVENT_HAVE_STDDEF_H 1
+#define EVENT__HAVE_STDDEF_H
 
 /* Define to 1 if you have the <stdint.h> header file. */
-/* #define _EVENT_HAVE_STDINT_H 1 */
+#define EVENT__HAVE_STDINT_H
 
 /* Define to 1 if you have the <stdlib.h> header file. */
-#define _EVENT_HAVE_STDLIB_H 1
+#define EVENT__HAVE_STDLIB_H
 
 /* Define to 1 if you have the <strings.h> header file. */
-#define _EVENT_HAVE_STRINGS_H 1
+/* #undef EVENT__HAVE_STRINGS_H */
 
 /* Define to 1 if you have the <string.h> header file. */
-#define _EVENT_HAVE_STRING_H 1
+#define EVENT__HAVE_STRING_H
 
 /* Define to 1 if you have the `strlcpy' function. */
-/* #undef _EVENT_HAVE_STRLCPY */
+/* #undef EVENT__HAVE_STRLCPY */
 
 /* Define to 1 if you have the `strsep' function. */
-/* #undef _EVENT_HAVE_STRSEP */
+/* #undef EVENT__HAVE_STRSEP */
 
 /* Define to 1 if you have the `strtok_r' function. */
-/* #undef _EVENT_HAVE_STRTOK_R */
+/* #undef EVENT__HAVE_STRTOK_R */
 
 /* Define to 1 if you have the `strtoll' function. */
-/* #define _EVENT_HAVE_STRTOLL 1 */
+#define EVENT__HAVE_STRTOLL
 
-#define _EVENT_HAVE_STRUCT_ADDRINFO 1
+/* Define to 1 if the system has the type `struct addrinfo'. */
+#define EVENT__HAVE_STRUCT_ADDRINFO
 
 /* Define to 1 if the system has the type `struct in6_addr'. */
-#define _EVENT_HAVE_STRUCT_IN6_ADDR 1
+#define EVENT__HAVE_STRUCT_IN6_ADDR
 
 /* Define to 1 if `s6_addr16' is member of `struct in6_addr'. */
-#define _EVENT_HAVE_STRUCT_IN6_ADDR_S6_ADDR16 1
+/* #undef EVENT__HAVE_STRUCT_IN6_ADDR_S6_ADDR16 */
 
 /* Define to 1 if `s6_addr32' is member of `struct in6_addr'. */
-#define _EVENT_HAVE_STRUCT_IN6_ADDR_S6_ADDR32 1
+/* #undef EVENT__HAVE_STRUCT_IN6_ADDR_S6_ADDR32 */
 
 /* Define to 1 if the system has the type `struct sockaddr_in6'. */
-#define _EVENT_HAVE_STRUCT_SOCKADDR_IN6 1
+#define EVENT__HAVE_STRUCT_SOCKADDR_IN6
 
 /* Define to 1 if `sin6_len' is member of `struct sockaddr_in6'. */
-/* #undef _EVENT_HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN */
+/* #undef EVENT__HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN */
 
 /* Define to 1 if `sin_len' is member of `struct sockaddr_in'. */
-/* #undef _EVENT_HAVE_STRUCT_SOCKADDR_IN_SIN_LEN */
+/* #undef EVENT__HAVE_STRUCT_SOCKADDR_IN_SIN_LEN */
 
 /* Define to 1 if the system has the type `struct sockaddr_storage'. */
-#define _EVENT_HAVE_STRUCT_SOCKADDR_STORAGE 1
+#define EVENT__HAVE_STRUCT_SOCKADDR_STORAGE
 
+/* Define to 1 if `ss_family' is a member of `struct sockaddr_storage'. */
+#define EVENT__HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY
+
+/* Define to 1 if `__ss_family' is a member of `struct sockaddr_storage'. */
+/* #undef EVENT__HAVE_STRUCT_SOCKADDR_STORAGE___SS_FAMILY */
+
+/* Define to 1 if you have the `sysctl' function. */
+/* #undef EVENT__HAVE_SYSCTL */
+
 /* Define to 1 if you have the <sys/devpoll.h> header file. */
-/* #undef _EVENT_HAVE_SYS_DEVPOLL_H */
+/* #undef EVENT__HAVE_SYS_DEVPOLL_H */
 
 /* Define to 1 if you have the <sys/epoll.h> header file. */
-/* #undef _EVENT_HAVE_SYS_EPOLL_H */
+/* #undef EVENT__HAVE_SYS_EPOLL_H */
 
 /* Define to 1 if you have the <sys/eventfd.h> header file. */
-/* #undef _EVENT_HAVE_SYS_EVENTFD_H */
+/* #undef EVENT__HAVE_SYS_EVENTFD_H */
 
 /* Define to 1 if you have the <sys/event.h> header file. */
-/* #undef _EVENT_HAVE_SYS_EVENT_H */
+/* #undef EVENT__HAVE_SYS_EVENT_H */
 
 /* Define to 1 if you have the <sys/ioctl.h> header file. */
-/* #undef _EVENT_HAVE_SYS_IOCTL_H */
+/* #undef EVENT__HAVE_SYS_IOCTL_H */
 
 /* Define to 1 if you have the <sys/mman.h> header file. */
-/* #undef _EVENT_HAVE_SYS_MMAN_H */
+/* #undef EVENT__HAVE_SYS_MMAN_H */
 
 /* Define to 1 if you have the <sys/param.h> header file. */
-/* #define _EVENT_HAVE_SYS_PARAM_H 1 */
+/* #undef EVENT__HAVE_SYS_PARAM_H */
 
 /* Define to 1 if you have the <sys/queue.h> header file. */
-/* #undef _EVENT_HAVE_SYS_QUEUE_H */
+/* #undef EVENT__HAVE_SYS_QUEUE_H */
 
+/* Define to 1 if you have the <sys/resource.h> header file. */
+/* #undef EVENT__HAVE_SYS_RESOURCE_H */
+
 /* Define to 1 if you have the <sys/select.h> header file. */
-/* #undef _EVENT_HAVE_SYS_SELECT_H */
+/* #undef EVENT__HAVE_SYS_SELECT_H */
 
 /* Define to 1 if you have the <sys/sendfile.h> header file. */
-/* #undef _EVENT_HAVE_SYS_SENDFILE_H */
+/* #undef EVENT__HAVE_SYS_SENDFILE_H */
 
 /* Define to 1 if you have the <sys/socket.h> header file. */
-/* #undef _EVENT_HAVE_SYS_SOCKET_H */
+/* #undef EVENT__HAVE_SYS_SOCKET_H */
 
 /* Define to 1 if you have the <sys/stat.h> header file. */
-#define _EVENT_HAVE_SYS_STAT_H 1
+#define EVENT__HAVE_SYS_STAT_H
 
+/* Define to 1 if you have the <sys/sysctl.h> header file. */
+/* #undef EVENT__HAVE_SYS_SYSCTL_H */
+
+/* Define to 1 if you have the <sys/timerfd.h> header file. */
+/* #undef EVENT__HAVE_SYS_TIMERFD_H */
+
 /* Define to 1 if you have the <sys/time.h> header file. */
-/* #define _EVENT_HAVE_SYS_TIME_H 1 */
+/* #undef EVENT__HAVE_SYS_TIME_H */
 
 /* Define to 1 if you have the <sys/types.h> header file. */
-#define _EVENT_HAVE_SYS_TYPES_H 1
+#define EVENT__HAVE_SYS_TYPES_H
 
 /* Define to 1 if you have the <sys/uio.h> header file. */
-/* #undef _EVENT_HAVE_SYS_UIO_H */
+/* #undef EVENT__HAVE_SYS_UIO_H */
 
+/* Define to 1 if you have the <sys/wait.h> header file. */
+/* #undef EVENT__HAVE_SYS_WAIT_H */
+
 /* Define if TAILQ_FOREACH is defined in <sys/queue.h> */
-/* #undef _EVENT_HAVE_TAILQFOREACH */
+/* #undef EVENT__HAVE_TAILQFOREACH */
 
 /* Define if timeradd is defined in <sys/time.h> */
-/* #undef _EVENT_HAVE_TIMERADD */
+/* #undef EVENT__HAVE_TIMERADD */
 
 /* Define if timerclear is defined in <sys/time.h> */
-#define _EVENT_HAVE_TIMERCLEAR 1
+/* #undef EVENT__HAVE_TIMERCLEAR */
 
 /* Define if timercmp is defined in <sys/time.h> */
-#define _EVENT_HAVE_TIMERCMP 1
+/* #undef EVENT__HAVE_TIMERCMP */
 
+/* Define to 1 if you have the `timerfd_create' function. */
+/* #undef EVENT__HAVE_TIMERFD_CREATE */
+
 /* Define if timerisset is defined in <sys/time.h> */
-#define _EVENT_HAVE_TIMERISSET 1
+/* #undef EVENT__HAVE_TIMERISSET */
 
+/* Define to 1 if the system has the type `uint8_t'. */
+#define EVENT__HAVE_UINT8_T
+
 /* Define to 1 if the system has the type `uint16_t'. */
-/* #define _EVENT_HAVE_UINT16_T 1 */
+#define EVENT__HAVE_UINT16_T
 
 /* Define to 1 if the system has the type `uint32_t'. */
-/* #define _EVENT_HAVE_UINT32_T 1 */
+#define EVENT__HAVE_UINT32_T
 
 /* Define to 1 if the system has the type `uint64_t'. */
-/* #define _EVENT_HAVE_UINT64_T 1 */
+#define EVENT__HAVE_UINT64_T
 
-/* Define to 1 if the system has the type `uint8_t'. */
-/* #define _EVENT_HAVE_UINT8_T 1 */
+/* Define to 1 if the system has the type `uintptr_t'. */
+#define EVENT__HAVE_UINTPTR_T
 
+/* Define to 1 if you have the `umask' function. */
+/* #undef EVENT__HAVE_UMASK */
+
 /* Define to 1 if you have the <unistd.h> header file. */
-/* #define _EVENT_HAVE_UNISTD_H 1 */
+/* #undef EVENT__HAVE_UNISTD_H */
 
+/* Define to 1 if you have the `unsetenv' function. */
+/* #undef EVENT__HAVE_UNSETENV */
+
 /* Define to 1 if you have the `vasprintf' function. */
-/* #undef _EVENT_HAVE_VASPRINTF */
+/* #undef EVENT__HAVE_VASPRINTF */
 
 /* Define if kqueue works correctly with pipes */
-/* #undef _EVENT_HAVE_WORKING_KQUEUE */
+/* #undef EVENT__HAVE_WORKING_KQUEUE */
 
-/* Numeric representation of the version */
-#define _EVENT_NUMERIC_VERSION 0x02001600
+#ifdef __USE_UNUSED_DEFINITIONS__
+/* Define to necessary symbol if this constant uses a non-standard name on your system. */
+/* XXX: Hello, this isn't even used, nor is it defined anywhere... - Ellzey */
+#define EVENT__PTHREAD_CREATE_JOINABLE 
+#endif
 
-/* Name of package */
-#define _EVENT_PACKAGE "libevent"
+/* The size of `pthread_t', as computed by sizeof. */
+#define EVENT__SIZEOF_PTHREAD_T 
 
-/* Define to the address where bug reports for this package should be sent. */
-#define _EVENT_PACKAGE_BUGREPORT ""
+/* The size of a `int', as computed by sizeof. */
+#define EVENT__SIZEOF_INT 4
 
-/* Define to the full name of this package. */
-#define _EVENT_PACKAGE_NAME ""
+/* The size of a `long', as computed by sizeof. */
+#define EVENT__SIZEOF_LONG 4
 
-/* Define to the full name and version of this package. */
-#define _EVENT_PACKAGE_STRING ""
+/* The size of a `long long', as computed by sizeof. */
+#define EVENT__SIZEOF_LONG_LONG 8
 
-/* Define to the one symbol short name of this package. */
-#define _EVENT_PACKAGE_TARNAME ""
+/* The size of `off_t', as computed by sizeof. */
+#define EVENT__SIZEOF_OFF_T 4
 
-/* Define to the version of this package. */
-#define _EVENT_PACKAGE_VERSION ""
+#define EVENT__SIZEOF_SSIZE_T 
 
-/* Define to necessary symbol if this constant uses a non-standard name on
-   your system. */
-/* #undef _EVENT_PTHREAD_CREATE_JOINABLE */
 
-/* The size of a `int', as computed by sizeof. */
-#define _EVENT_SIZEOF_INT 4
+/* The size of a `short', as computed by sizeof. */
+#define EVENT__SIZEOF_SHORT 2
 
-/* The size of a `long', as computed by sizeof. */
-#define _EVENT_SIZEOF_LONG 4
+/* The size of `size_t', as computed by sizeof. */
+#define EVENT__SIZEOF_SIZE_T 4
 
-/* The size of a `long long', as computed by sizeof. */
-#define _EVENT_SIZEOF_LONG_LONG 8
+/* Define to 1 if you have the ANSI C header files. */
+/* #undef EVENT__STDC_HEADERS */
 
-/* The size of a `short', as computed by sizeof. */
-#define _EVENT_SIZEOF_SHORT 2
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+/* #undef EVENT__TIME_WITH_SYS_TIME */
 
-/* The size of `size_t', as computed by sizeof. */
-#ifdef _WIN64
-#define _EVENT_SIZEOF_SIZE_T 8
-#else
-#define _EVENT_SIZEOF_SIZE_T 4
-#endif
+/* The size of `socklen_t', as computed by sizeof. */
+#define EVENT__SIZEOF_SOCKLEN_T 4
 
-/* The size of `void *', as computed by sizeof. */
-#ifdef _WIN64
-#define _EVENT_SIZEOF_VOID_P 8
+/* The size of 'void *', as computer by sizeof */
+#define EVENT__SIZEOF_VOID_P 4
+
+/* set an alias for whatever __func__ __FUNCTION__ is, what sillyness */
+#if defined (__func__)
+#define EVENT____func__ __func__
+#elif defined(__FUNCTION__)
+#define EVENT____func__  __FUNCTION__
 #else
-#define _EVENT_SIZEOF_VOID_P 4
+#define EVENT____func__ __FILE__
 #endif
 
-/* Define to 1 if you have the ANSI C header files. */
-#define _EVENT_STDC_HEADERS 1
 
-/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
-#define _EVENT_TIME_WITH_SYS_TIME 1
+#ifdef __THESE_ARE_NOT_CONFIG_H_THINGS_THEY_ARE_DASH_D_THINGS__ 
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* Ellzey is not satisfied */ 
+#define EVENT___FILE_OFFSET_BITS 
 
-/* Version number of package */
-#define _EVENT_VERSION "2.0.22-stable"
+/* Define for large files, on AIX-style hosts. */
+#define 
+#endif
 
-/* Define to appropriate substitue if compiler doesnt have __func__ */
-#define _EVENT___func__ __FUNCTION__
-
+#ifdef _WhAT_DOES_THIS_EVEN_DO_
 /* Define to empty if `const' does not conform to ANSI C. */
-/* #undef _EVENT_const */
+/* lolwut? - ellzey */
+#undef EVENT__const
+#endif
 
+
 /* Define to `__inline__' or `__inline' if that's what the C compiler
    calls it, or to nothing if 'inline' is not supported under any name.  */
-#ifndef _EVENT___cplusplus
-#define _EVENT_inline __inline
+#ifndef __cplusplus
+/* why not c++?
+ *
+ *  and are we really expected to use EVENT__inline everywhere,
+ *  shouldn't we just do:
+ *     ifdef EVENT__inline
+ *     define inline EVENT__inline
+ *
+ * - Ellzey
+ */
+
+#define EVENT__inline inline
 #endif
 
-/* Define to `int' if <sys/types.h> does not define. */
-/* #undef _EVENT_pid_t */
+/* Define to `int' if <sys/tyes.h> does not define. */
+#define EVENT__pid_t int
 
 /* Define to `unsigned' if <sys/types.h> does not define. */
-/* #undef _EVENT_size_t */
+#define EVENT__size_t unsigned
 
 /* Define to unsigned int if you dont have it */
-#define _EVENT_socklen_t unsigned int
+#define EVENT__socklen_t socklen_t
 
 /* Define to `int' if <sys/types.h> does not define. */
-#define _EVENT_ssize_t SSIZE_T
+#define EVENT__ssize_t SSIZE_T
 
+/* #undef EVENT__NEED_DLLIMPORT */
+
+/* Define to 1 if you have ERR_remove_thread_stat(). */
+/* #undef EVENT__HAVE_ERR_REMOVE_THREAD_STATE */
+
 #endif
Index: include/networkengine.h
===================================================================
--- include/networkengine.h	(revision 49)
+++ include/networkengine.h	(working copy)
@@ -75,7 +75,7 @@
 
 		virtual r_bool is_running() const = 0;
 
-		virtual void handle_message() = 0;
+		virtual void handle_message(r_uint32 max_packets) = 0;
 
 		virtual void send(void* net, void* data, r_uint32 len) = 0;
 	};
@@ -89,8 +89,8 @@
 			method_post,
 		};
 		typedef std::function<void(r_bool ret, void* request, void* data, r_uint32 len)>	open_url_callback;
-		virtual void* open_url(const char* url, r_bool url_is_RFC3986, method_type method, std::map<const char*, const char*>* propertys, void* pdata, r_uint32 len, r_uint32 timeout, r_uint32 retries, open_url_callback&& callback) = 0;
-		virtual void* open_url(const char* url, r_bool url_is_RFC3986, method_type method, std::map<const char*, const char*>* propertys, void* pdata, r_uint32 len, r_uint32 timeout, r_uint32 retries, open_url_callback& callback) = 0;
+		virtual void* open_url(const char* url, method_type method, std::map<const char*, const char*>* propertys, void* pdata, r_uint32 len, r_uint32 timeout, r_uint32 retries, open_url_callback&& callback) = 0;
+		virtual void* open_url(const char* url, method_type method, std::map<const char*, const char*>* propertys, void* pdata, r_uint32 len, r_uint32 timeout, r_uint32 retries, open_url_callback& callback) = 0;
 		virtual void update(r_uint32 t) = 0;
 	};
 
Index: output/win32d/networkengine.dll
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: output/win32d/networkengine.dll
===================================================================
--- output/win32d/networkengine.dll	(nonexistent)
+++ output/win32d/networkengine.dll	(working copy)

Property changes on: output/win32d/networkengine.dll
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: output/win32d/networkengine.pdb
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: output/win32d/networkengine.pdb
===================================================================
--- output/win32d/networkengine.pdb	(nonexistent)
+++ output/win32d/networkengine.pdb	(working copy)

Property changes on: output/win32d/networkengine.pdb
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: source/networkhttpimpl.cpp
===================================================================
--- source/networkhttpimpl.cpp	(revision 49)
+++ source/networkhttpimpl.cpp	(working copy)
@@ -6,7 +6,6 @@
 #include "event2/buffer.h"
 #include "rapid.h"
 #include <string.h>
-#include <sstream>
 
 rapid::network_http_impl::network_http_impl()
 {
@@ -18,9 +17,9 @@
 	event_base_free(m_event_base);
 }
 
-void * rapid::network_http_impl::open_url(const char * url, r_bool url_is_RFC3986, method_type method, std::map<const char*, const char*>* properties, void * pdata, r_uint32 len, r_uint32 timeout, r_uint32 retries, open_url_callback && callback)
+void * rapid::network_http_impl::open_url(const char * url, method_type method, std::map<const char*, const char*>* properties, void * pdata, r_uint32 len, r_uint32 timeout, r_uint32 retries, open_url_callback && callback)
 {
-	auto http_uri = url_is_RFC3986 ? evhttp_uri_parse(url) : evhttp_uri_parse_with_flags(url, EVHTTP_URI_NONCONFORMANT);
+	auto http_uri = evhttp_uri_parse(url);
 	if (!http_uri)
 		return nullptr;
 
@@ -47,6 +46,9 @@
 		auto path = evhttp_uri_get_path(http_uri);
 		auto port = evhttp_uri_get_port(http_uri);
 
+		if (!scheme || strcmp(scheme, "http") != 0 || !host)
+			break;
+
 		if (port == -1)
 			port = 80;
 
@@ -99,24 +101,9 @@
 			evbuffer_add(buff, pdata, len);
 		}
 
-		if (url_is_RFC3986)
-		{
-			if (evhttp_make_request(_conn, _http_request, _convert_method(method), path) != 0 || !_request->m_request_valid)
-				break;
-		}
-		else
-		{
-			std::stringstream ss;
-			ss << path;
+		if (evhttp_make_request(_conn, _http_request, _convert_method(method), path) != 0 || !_request->m_request_valid)
+			break;
 
-			auto query = evhttp_uri_get_query(http_uri);
-			if (query)
-				ss << "?" << query;
-
-			if (evhttp_make_request(_conn, _http_request, _convert_method(method), ss.str().c_str()) != 0 || !_request->m_request_valid)
-				break;
-		}
-
 		evhttp_uri_free(http_uri);
 		m_requests.push_back(_request);
 
@@ -129,9 +116,9 @@
 	return nullptr;
 }
 
-void * rapid::network_http_impl::open_url(const char * url, r_bool url_is_RFC3986, method_type method, std::map<const char*, const char*>* propertys, void * pdata, r_uint32 len, r_uint32 timeout, r_uint32 retries, open_url_callback & callback)
+void * rapid::network_http_impl::open_url(const char * url, method_type method, std::map<const char*, const char*>* propertys, void * pdata, r_uint32 len, r_uint32 timeout, r_uint32 retries, open_url_callback & callback)
 {
-	return open_url(url, url_is_RFC3986, method, propertys, pdata, len, timeout, retries, std::move(callback));
+	return open_url(url, method, propertys, pdata, len, timeout, retries, std::move(callback));
 }
 
 void rapid::network_http_impl::update(r_uint32 t)
@@ -162,14 +149,20 @@
 	else
 	{
 		m_requests.erase(it);
-		int nErrorCode = evhttp_request_get_response_code(_request->m_http_request);
-		if (nErrorCode == 200)
-		{
-			_request->m_callback(true, _request, (void*)_request->m_data.c_str(), _request->m_data.length());
-		}
+
+		if (!http_req)
+			_request->m_callback(false, _request, nullptr, 0);
 		else
 		{
-			_request->m_callback(false, _request, nullptr, 0);
+			int nErrorCode = evhttp_request_get_response_code(http_req);
+			if (nErrorCode == 200)
+			{
+				_request->m_callback(true, _request, (void*)_request->m_data.c_str(), _request->m_data.length());
+			}
+			else
+			{
+				_request->m_callback(false, _request, nullptr, 0);
+			}
 		}
 		evhttp_connection_free(_request->m_http_connection);
 		delete _request;
@@ -178,7 +171,7 @@
 
 void rapid::network_http_impl::_request_chunk(struct evhttp_request* http_req, r_request* _request)
 {
-	evbuffer* evbuff = evhttp_request_get_input_buffer(_request->m_http_request);
+	evbuffer* evbuff = evhttp_request_get_input_buffer(http_req);
 	int nLength = (int)evbuffer_get_length(evbuff);
 	if (nLength > 0)
 	{
Index: source/networkhttpimpl.h
===================================================================
--- source/networkhttpimpl.h	(revision 49)
+++ source/networkhttpimpl.h	(working copy)
@@ -18,8 +18,8 @@
 		~network_http_impl();
 
 		//  network_http 
-		virtual void * open_url(const char * url, r_bool url_is_RFC3986, method_type method, std::map<const char*, const char*>* properties, void * pdata, r_uint32 len, r_uint32 timeout, r_uint32 retries, open_url_callback && callback) override;
-		virtual void * open_url(const char * url, r_bool url_is_RFC3986, method_type method, std::map<const char*, const char*>* properties, void * pdata, r_uint32 len, r_uint32 timeout, r_uint32 retries, open_url_callback & callback) override;
+		virtual void * open_url(const char * url, method_type method, std::map<const char*, const char*>* properties, void * pdata, r_uint32 len, r_uint32 timeout, r_uint32 retries, open_url_callback && callback) override;
+		virtual void * open_url(const char * url, method_type method, std::map<const char*, const char*>* properties, void * pdata, r_uint32 len, r_uint32 timeout, r_uint32 retries, open_url_callback & callback) override;
 		virtual void update(r_uint32 t) override;
 
 	private:
Index: source/networkserverimpl.cpp
===================================================================
--- source/networkserverimpl.cpp	(revision 49)
+++ source/networkserverimpl.cpp	(working copy)
@@ -115,10 +115,11 @@
 		return !m_end_libevent_thread && m_libevent_thread_activated;
 	}
 
-	void network_server_impl::handle_message()
+	void network_server_impl::handle_message(r_uint32 max_packets)
 	{
 		sock_packet** packet = nullptr;
 
+		r_uint32 packet_count = 0;
 		do
 		{
 			packet = m_incoming_packets.ReadLock();
@@ -144,7 +145,10 @@
 
 			_deallocate_packet(&pPacket);
 
-		} while (true);
+			packet_count++;
+		} while (packet_count < max_packets);
+
+		std::cout << "packet count: " << packet_count << std::endl;
 	}
 
 	r_bool network_server_impl::_is_activated() const
Index: source/networkserverimpl.h
===================================================================
--- source/networkserverimpl.h	(revision 49)
+++ source/networkserverimpl.h	(working copy)
@@ -36,7 +36,7 @@
 
 		virtual r_bool is_running() const override;
 
-		virtual void handle_message() override;
+		virtual void handle_message(r_uint32 max_packets) override;
 
 		virtual void add_listener(network_server_listener & listener) override;
 
